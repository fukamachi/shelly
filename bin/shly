#!/usr/bin/env perl
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/shelly.pm"} = <<'APP_SHELLY';
  package App::shelly;
  
  use strict;
  use warnings;
  
  use Getopt::Long qw(:config gnu_getopt pass_through);
  use File::Which qw(which);
  
  use App::shelly::impl;
  use App::shelly::config qw(config dumped_core_path);
  
  sub impl {
      sub { App::shelly::impl->param(@_); }
  }
  
  sub new {
      my ($class) = @_;
  
      return bless {
          lisp_impl => $ENV{LISP_IMPL} || config->{default_lisp},
          load_libraries => [],
          argv           => [],
      }, $class;
  }
  
  sub parse_options {
      my ( $self, @argv ) = @_;
  
      local @ARGV = @{ $self->{argv} };
      push @ARGV, @argv;
  
      GetOptions(
          'help|h'   => \$self->{help},
          'impl|I=s' => \$self->{lisp_impl},
          'load|L=s' => \my $libraries,
          'no-init'  => \$self->{noinit},
          'verbose'  => \$self->{verbose},
          'debug'    => \$self->{debug},
      );
  
      if ($libraries) {
          $self->{load_libraries} = [ split ',', $libraries ];
      }
  
      $self->{argv} = \@ARGV;
  
      if ( $self->{help} ) {
          $self->{noinit} = 1;
          $self->{argv}   = ['shelly::help'];
      }
  }
  
  sub doit {
      my ($self) = @_;
  
      unless ( $self->{lisp_impl} ) {
          $self->{lisp_impl} = $self->detect_installed_lisp;
      }
  
      local $ENV{LISP_IMPL} = $self->{lisp_impl};
  
      unless ( impl->('impl_name') ) {
          print "Unsupported CL implementation: @{[ $self->{lisp_impl} ]}\n";
          print qq(It must be one of "sbcl", "ccl", "alisp", "clisp", "cmucl" or "ecl".\n);
          exit 1;
      }
  
      my $command = $self->_build_command;
  
      if ( $self->{debug} ) {
          print $command, "\n";
      }
  
      system(qq($command 2>&1));
  }
  
  sub _build_command {
      my ($self) = @_;
  
      my $lisp_bin = impl->('binary') || $ENV{LISP_BINARY} || $self->{lisp_impl};
  
      if ( $self->{noinit} ) {
          $lisp_bin .= ' ' . impl->('noinit_option');
      }
  
      my @evals = ();
  
      if ( -e dumped_core_path ) {
          $lisp_bin = join ' ',
            ( $lisp_bin, impl->('core_option'), dumped_core_path );
      }
      else {
          unless ( $self->{lisp_impl} eq 'ecl' ) {
              print
  "Warning: Core image wasn't found. It is probably slow, isn't it? Try \"shly dump-core\".\n";
          }
  
          push @evals, <<END_OF_LISP;
  (let ((*standard-output* (make-broadcast-stream)))
    (handler-case #+quicklisp (ql:quickload :shelly) #-quicklisp (asdf:load-system :shelly)
      (#+quicklisp ql::system-not-found #-quicklisp asdf:missing-component (c)
       (format *error-output* "~&Error: ~A~&" c)
       #+quicklisp
       (format *error-output* "~&Try (ql:update-all-dists) to ensure your dist is up to date.~%")
       #+allegro (exit 1 :quiet t)
       #-allegro (quit)))
    (values))
  END_OF_LISP
          push @evals, '(shelly.util::shadowing-use-package :shelly)';
      }
  
      if ( config->{version} ) {
          push @evals,
            qq((shelly.util::check-version "@{[ config->{version} ]}"));
      }
  
      for ( @{ $self->{load_libraries} } ) {
          push @evals, "(shelly.util::load-systems :$_)";
      }
  
      {
          my @args = @{ $self->{argv} };
  
          if ( @args > 0 ) {
              my $eval_expr =
                sprintf '(shelly.core::interpret (list %s) :verbose %s)',
                ( join " ", ( map { "\"$_\"" } @args ) ),
                $self->{verbose} ? 't' : 'nil';
              push @evals, $eval_expr;
              push @evals, '(swank-backend:quit-lisp)';
          }
          else {
              push @evals, sprintf '(shelly::run-repl :verbose %s)',
                $self->{verbose} ? 't' : 'nil';
          }
      }
  
      my $command = join ' ', $lisp_bin,
        (
            impl->('pre_options')
          ? impl->('pre_options')
          : ()
        ),
        ( map { ( impl->('eval'), "'$_'" ) } @evals ),
        impl->('other_options');
  
      return $command;
  }
  
  sub detect_installed_lisp {
      print "LISP_IMPL isn't set. Auto detecting...\n";
  
      my (@lisp_impl) =
        grep { which($_) } qw(sbcl ccl alisp clisp cmucl lisp ecl);
      @lisp_impl = map { $_ eq 'lisp' ? 'cmucl' : $_ } @lisp_impl;
  
      unless (@lisp_impl) {
          print "Couldn't detect installed Lisp.\n";
          exit 1;
      }
  
      print "Installed Lisp: " . ( join ', ', @lisp_impl ) . "\n";
  
      if ( @lisp_impl > 1 ) {
          print "Which do you prefer? [@{[ $lisp_impl[0] ]}] : ";
  
          my $input = <STDIN>;
  
          {
              no warnings 'uninitialized';
              chomp $input;
          }
  
          unless ($input) {
              $input = $lisp_impl[0];
              print $input, "\n";
          }
  
          return $input;
      }
  
      return $lisp_impl[0];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  App::shelly
  
  =head1 SYNOPSIS
  
  $ shly [options] [atom...]
  
  =head1 OPTIONS
  
  =over 4
  
  =item B<-h, --help>
  
  Show this help.
  
  =item B<-I, --impl [implementation]>
  
  Tell what Lisp implementation to use. The default is $LISP_IMPL.
  
  =item B<-L, --load [library1,library2,...]>
  
  Load libraries before executing the expression.
  
  =item B<--verbose>
  
  Print some informations.
  
  =item B<--no-init>
  
  Do not load the user init file.
  
  =item B<--debug>
  
  This flag is for Shelly developers.
  
  =back
  
  =cut
APP_SHELLY

$fatpacked{"App/shelly/config.pm"} = <<'APP_SHELLY_CONFIG';
  package App::shelly::config;
  
  use strict;
  use warnings;
  use Exporter::Lite;
  
  our @EXPORT_OK = qw(config config_path dumped_core_path);
  
  my $local_base_path = $ENV{HOME} . '/.shelly/';
  
  sub local_path {
      return $local_base_path . $_[0];
  }
  
  sub config_path {
      my ($impl) = @_;
  
      if ($impl) {
          return local_path( 'config.' . $impl );
      }
  
      return local_path('config');
  }
  
  sub dumped_core_path {
      return local_path('dumped-cores/')
        . ( $_[0] || ( $ENV{LISP_IMPL} . '.core' ) );
  }
  
  sub config {
      my $config_file = &config_path;
  
      my $config =
        -e $config_file
        ? do $config_file
        : {};
  
      return $config;
  }
  
  1;
APP_SHELLY_CONFIG

$fatpacked{"App/shelly/impl.pm"} = <<'APP_SHELLY_IMPL';
  package App::shelly::impl;
  
  use strict;
  use warnings;
  
  use Config::ENV 'LISP_IMPL';
  
  use App::shelly::config;
  
  common + {};
  
  config ccl => +{
      impl_name     => 'ccl',
      eval          => '--eval',
      other_options => '--quiet',
      binary        => App::shelly::config::config('ccl')->{binary_path},
      core_option   => '-I',
      noinit_option => '--no-init',
  };
  
  config sbcl => +{
      impl_name     => 'sbcl',
      pre_options   => '--noinform --disable-debugger',
      eval          => '--eval',
      other_options => '--quiet',
      binary        => App::shelly::config::config('sbcl')->{binary_path},
      core_option   => '--core',
      noinit_option => '--no-userinit',
  };
  
  config alisp => +{
      impl_name     => 'alisp',
      pre_options   => '-L ~/.clinit.cl',
      eval          => '-e',
      other_options => '',
      binary        => App::shelly::config::config('alisp')->{binary_path},
      core_option   => '-I',
      noinit_option => '-q',
  };
  
  config clisp => +{
      impl_name     => 'clisp',
      eval          => '-x',
      other_options => '-q --quiet',
      binary        => App::shelly::config::config('clisp')->{binary_path},
      core_option   => '-M',
      noinit_option => '-norc',
  };
  
  config cmucl => +{
      impl_name     => 'cmucl',
      eval          => '-eval',
      other_options => '-quiet -batch',
      binary => App::shelly::config::config('cmucl')->{binary_path} || 'lisp',
      core_option => '-core',
      noinit_option => '-noinit',
  };
  
  config ecl => +{
      impl_name     => 'ecl',
      eval          => '-eval',
      other_options => '-q',
      binary        => App::shelly::config::config('ecl')->{binary_path},
      noinit_option => '-norc',
  };
  
  1;
APP_SHELLY_IMPL

$fatpacked{"Config/ENV.pm"} = <<'CONFIG_ENV';
  package Config::ENV;
  
  use strict;
  use warnings;
  
  use Carp;
  
  our $VERSION = '0.11';
  
  sub import {
  	my $class   = shift;
  	my $package = caller(0);
  
  	no strict 'refs';
  	if (__PACKAGE__ eq $class) {
  		my $name    = shift;
  		my %opts    = @_;
  
  		push @{"$package\::ISA"}, __PACKAGE__;
  
  		for my $method (qw/common config parent load/) {
  			*{"$package\::$method"} = \&{__PACKAGE__ . "::" . $method}
  		}
  
  		no warnings 'once';
  		${"$package\::data"} = +{
  			common  => {},
  			envs    => {},
  			name    => $name,
  			default => $opts{default} || 'default',
  			export  => $opts{export},
  		};
  	} else {
  		my %opts    = @_;
  		my $data = _data($class);
  		if (my $export = $opts{export} || $data->{export}) {
  			*{"$package\::$export"} = sub () { $class };
  		}
  	}
  }
  
  sub _data {
  	my $package = shift || caller(1);
  	no strict 'refs';
  	no warnings 'once';
  	${"$package\::data"};
  }
  
  sub common ($) { ## no critic
  	my ($hash) = @_;
  	_data->{common} = $hash;
  }
  
  sub config ($$) { ## no critic
  	my ($name, $hash) = @_;
  	_data->{envs}->{$name} = $hash;
  	undef _data->{_merged}->{$name};
  }
  
  sub load ($) {
  	my $filename = shift;
  	my $hash = do "$filename";
  
  	croak $@ if $@;
  	croak $! unless defined $hash;
  	unless (ref($hash) eq 'HASH') {
  		croak "$filename does not return HashRef.";
  	}
  
  	wantarray ? %$hash : $hash;
  }
  
  sub parent ($) { ## no critic
  	my ($name) = @_;
  	%{ _data->{envs}->{$name} || {} };
  }
  
  sub current {
  	my ($package) = @_;
  	my $data = _data($package);
  
  	my $vals = $data->{_merged}->{$package->env} ||= +{
  		%{ $data->{common} },
  		%{ $data->{envs}->{$package->env} || {} },
  		(map { %$_ } @{ $data->{_local} || []}),
  	};
  }
  
  sub param {
  	my ($package, $name) = @_;
  	$package->current->{$name};
  }
  
  sub local {
  	my ($package, %hash) = @_;
  	not defined wantarray and croak "local returns guard object; Can't use in void context.";
  
  	my $data = _data($package);
  	$data->{_local} ||= [];
  	push @{ $data->{_local} }, \%hash;
  	undef $data->{_merged};
  
  	bless sub {
  		pop @{ $data->{_local} };
  		undef $data->{_merged};
  	}, 'Config::ENV::Local';
  }
  
  sub env {
  	my ($package) = @_;
  	my $data = _data($package);
  	$ENV{$data->{name}} || $data->{default};
  }
  
  {
  	package
  		Config::ENV::Local;
  
  	sub DESTROY {
  		my $self = shift;
  		$self->();
  	}
  };
  
  1;
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Config::ENV - Various config determined by %ENV
  
  =head1 SYNOPSIS
  
    package MyConfig;
    
    use Config::ENV 'PLACK_ENV'; # use $ENV{PLACK_ENV} to determine config
    
    common +{
      name => 'foobar',
    };
    
    config development => +{
      dsn_user => 'dbi:mysql:dbname=user;host=localhost',
    };
    
    config test => +{
      dsn_user => 'dbi:mysql:dbname=user;host=localhost',
    };
    
    config production => +{
      dsn_user => 'dbi:mysql:dbname=user;host=127.0.0.254',
    };
    
    config production_bot => +{
      parent('production'),
      bot => 1,
    };
  
    # Use it
  
    use MyConfig;
    MyConfig->param('dsn_user'); #=> ...
  
  =head1 DESCRIPTION
  
  Config::ENV is for switching various configurations by environment variable.
  
  =head1 CONFIG DEFINITION
  
  use this module in your config package:
  
    package MyConfig;
    use Config::ENV 'FOO_ENV';
  
    common +{
      name => 'foobar',
    };
  
    config development => +{};
    config production  => +{};
  
    1;
  
  =over 4
  
  =item common($hash)
  
  Define common config. This $hash is merged with specific environment config.
  
  =item config($env, $hash);
  
  Define environment config. This $hash is just enabled in $env environment.
  
  =item parent($env);
  
  Expand $env configuration to inherit it.
  
  =item load($filename);
  
  `do $filename` and expand it. This can be used following:
  
    # MyConfig.pm
    common +{
      API_KEY => 'Set in config.pl',
      API_SECRET => 'Set in config.pl',
      load('config.pl),
    };
  
    # config.pl
    +{
      API_KEY => 'XFATEAFAFASG',
      API_SECRET => 'ced3a7927fcf22cba72c2559326be2b8e3f14a0f',
    }
  
  =back
  
  =head2 EXPORT
  
  You can specify default export name in config class. If you specify 'exports' option as following:
  
    package MyConfig;
    use Config::ENV 'FOO_ENV', exports => 'config';
  
    ...;
  
  and use it with 'config' function.
  
    package Foobar;
    use MyConfig; # exports 'config' function
  
    config->param('...');
  
  =head1 METHODS
  
  =over 4
  
  =item config->param($name)
  
  Returns config variable named $name.
  
  =item $guard = config->local(%hash)
  
  This is for scope limited config. You can use this when you use other values in temporary. Returns guard object.
  
    is config->param('name'), 'original value';
    {
      my $guard = config->local(name => 'localized');
      is config->param('name'), 'localized';
    };
    is config->param('name'), 'original value';
  
  =item config->env
  
  Returns current environment name.
  
  =item config->current
  
  Returns current configuration as HashRef.
  
  =back
  
  =head1 AUTHOR
  
  cho45 E<lt>cho45@lowreal.netE<gt>
  
  =head1 SEE ALSO
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
CONFIG_ENV

$fatpacked{"Exporter.pm"} = <<'EXPORTER';
  package Exporter;
  
  require 5.006;
  
  # Be lean.
  #use strict;
  #no strict 'refs';
  
  our $Debug = 0;
  our $ExportLevel = 0;
  our $Verbose ||= 0;
  our $VERSION = '5.65';
  our (%Cache);
  
  sub as_heavy {
    require Exporter::Heavy;
    # Unfortunately, this does not work if the caller is aliased as *name = \&foo
    # Thus the need to create a lot of identical subroutines
    my $c = (caller(1))[3];
    $c =~ s/.*:://;
    \&{"Exporter::Heavy::heavy_$c"};
  }
  
  sub export {
    goto &{as_heavy()};
  }
  
  sub import {
    my $pkg = shift;
    my $callpkg = caller($ExportLevel);
  
    if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
      *{$callpkg."::import"} = \&import;
      return;
    }
  
    # We *need* to treat @{"$pkg\::EXPORT_FAIL"} since Carp uses it :-(
    my $exports = \@{"$pkg\::EXPORT"};
    # But, avoid creating things if they don't exist, which saves a couple of
    # hundred bytes per package processed.
    my $fail = ${$pkg . '::'}{EXPORT_FAIL} && \@{"$pkg\::EXPORT_FAIL"};
    return export $pkg, $callpkg, @_
      if $Verbose or $Debug or $fail && @$fail > 1;
    my $export_cache = ($Cache{$pkg} ||= {});
    my $args = @_ or @_ = @$exports;
  
    local $_;
    if ($args and not %$export_cache) {
      s/^&//, $export_cache->{$_} = 1
        foreach (@$exports, @{"$pkg\::EXPORT_OK"});
    }
    my $heavy;
    # Try very hard not to use {} and hence have to  enter scope on the foreach
    # We bomb out of the loop with last as soon as heavy is set.
    if ($args or $fail) {
      ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
                 or $fail and @$fail and $_ eq $fail->[0])) and last
                   foreach (@_);
    } else {
      ($heavy = /\W/) and last
        foreach (@_);
    }
    return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    local $SIG{__WARN__} = 
  	sub {require Carp; &Carp::carp} if not $SIG{__WARN__};
    # shortcut for the common case of no type character
    *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  }
  
  # Default methods
  
  sub export_fail {
      my $self = shift;
      @_;
  }
  
  # Unfortunately, caller(1)[3] "does not work" if the caller is aliased as
  # *name = \&foo.  Thus the need to create a lot of identical subroutines
  # Otherwise we could have aliased them to export().
  
  sub export_to_level {
    goto &{as_heavy()};
  }
  
  sub export_tags {
    goto &{as_heavy()};
  }
  
  sub export_ok_tags {
    goto &{as_heavy()};
  }
  
  sub require_version {
    goto &{as_heavy()};
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Exporter - Implements default import method for modules
  
  =head1 SYNOPSIS
  
  In module F<YourModule.pm>:
  
    package YourModule;
    require Exporter;
    @ISA = qw(Exporter);
    @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
  
  or
  
    package YourModule;
    use Exporter 'import'; # gives you Exporter's import() method directly
    @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
  
  In other files which wish to use C<YourModule>:
  
    use YourModule qw(frobnicate);      # import listed symbols
    frobnicate ($left, $right)          # calls YourModule::frobnicate
  
  Take a look at L</Good Practices> for some variants
  you will like to use in modern Perl code.
  
  =head1 DESCRIPTION
  
  The Exporter module implements an C<import> method which allows a module
  to export functions and variables to its users' namespaces. Many modules
  use Exporter rather than implementing their own C<import> method because
  Exporter provides a highly flexible interface, with an implementation optimised
  for the common case.
  
  Perl automatically calls the C<import> method when processing a
  C<use> statement for a module. Modules and C<use> are documented
  in L<perlfunc> and L<perlmod>. Understanding the concept of
  modules and how the C<use> statement operates is important to
  understanding the Exporter.
  
  =head2 How to Export
  
  The arrays C<@EXPORT> and C<@EXPORT_OK> in a module hold lists of
  symbols that are going to be exported into the users name space by
  default, or which they can request to be exported, respectively.  The
  symbols can represent functions, scalars, arrays, hashes, or typeglobs.
  The symbols must be given by full name with the exception that the
  ampersand in front of a function is optional, e.g.
  
      @EXPORT    = qw(afunc $scalar @array);   # afunc is a function
      @EXPORT_OK = qw(&bfunc %hash *typeglob); # explicit prefix on &bfunc
  
  If you are only exporting function names it is recommended to omit the
  ampersand, as the implementation is faster this way.
  
  =head2 Selecting What To Export
  
  Do B<not> export method names!
  
  Do B<not> export anything else by default without a good reason!
  
  Exports pollute the namespace of the module user.  If you must export
  try to use C<@EXPORT_OK> in preference to C<@EXPORT> and avoid short or
  common symbol names to reduce the risk of name clashes.
  
  Generally anything not exported is still accessible from outside the
  module using the C<YourModule::item_name> (or C<< $blessed_ref->method >>)
  syntax.  By convention you can use a leading underscore on names to
  informally indicate that they are 'internal' and not for public use.
  
  (It is actually possible to get private functions by saying:
  
    my $subref = sub { ... };
    $subref->(@args);            # Call it as a function
    $obj->$subref(@args);        # Use it as a method
  
  However if you use them for methods it is up to you to figure out
  how to make inheritance work.)
  
  As a general rule, if the module is trying to be object oriented
  then export nothing. If it's just a collection of functions then
  C<@EXPORT_OK> anything but use C<@EXPORT> with caution. For function and
  method names use barewords in preference to names prefixed with
  ampersands for the export lists.
  
  Other module design guidelines can be found in L<perlmod>.
  
  =head2 How to Import
  
  In other files which wish to use your module there are three basic ways for
  them to load your module and import its symbols:
  
  =over 4
  
  =item C<use YourModule;>
  
  This imports all the symbols from YourModule's C<@EXPORT> into the namespace
  of the C<use> statement.
  
  =item C<use YourModule ();>
  
  This causes perl to load your module but does not import any symbols.
  
  =item C<use YourModule qw(...);>
  
  This imports only the symbols listed by the caller into their namespace.
  All listed symbols must be in your C<@EXPORT> or C<@EXPORT_OK>, else an error
  occurs. The advanced export features of Exporter are accessed like this,
  but with list entries that are syntactically distinct from symbol names.
  
  =back
  
  Unless you want to use its advanced features, this is probably all you
  need to know to use Exporter.
  
  =head1 Advanced features
  
  =head2 Specialised Import Lists
  
  If any of the entries in an import list begins with !, : or / then
  the list is treated as a series of specifications which either add to
  or delete from the list of names to import. They are processed left to
  right. Specifications are in the form:
  
      [!]name         This name only
      [!]:DEFAULT     All names in @EXPORT
      [!]:tag         All names in $EXPORT_TAGS{tag} anonymous list
      [!]/pattern/    All names in @EXPORT and @EXPORT_OK which match
  
  A leading ! indicates that matching names should be deleted from the
  list of names to import.  If the first specification is a deletion it
  is treated as though preceded by :DEFAULT. If you just want to import
  extra names in addition to the default set you will still need to
  include :DEFAULT explicitly.
  
  e.g., F<Module.pm> defines:
  
      @EXPORT      = qw(A1 A2 A3 A4 A5);
      @EXPORT_OK   = qw(B1 B2 B3 B4 B5);
      %EXPORT_TAGS = (T1 => [qw(A1 A2 B1 B2)], T2 => [qw(A1 A2 B3 B4)]);
  
      Note that you cannot use tags in @EXPORT or @EXPORT_OK.
      Names in EXPORT_TAGS must also appear in @EXPORT or @EXPORT_OK.
  
  An application using Module can say something like:
  
      use Module qw(:DEFAULT :T2 !B3 A3);
  
  Other examples include:
  
      use Socket qw(!/^[AP]F_/ !SOMAXCONN !SOL_SOCKET);
      use POSIX  qw(:errno_h :termios_h !TCSADRAIN !/^EXIT/);
  
  Remember that most patterns (using //) will need to be anchored
  with a leading ^, e.g., C</^EXIT/> rather than C</EXIT/>.
  
  You can say C<BEGIN { $Exporter::Verbose=1 }> to see how the
  specifications are being processed and what is actually being imported
  into modules.
  
  =head2 Exporting without using Exporter's import method
  
  Exporter has a special method, 'export_to_level' which is used in situations
  where you can't directly call Exporter's import method. The export_to_level
  method looks like:
  
      MyPackage->export_to_level($where_to_export, $package, @what_to_export);
  
  where C<$where_to_export> is an integer telling how far up the calling stack
  to export your symbols, and C<@what_to_export> is an array telling what
  symbols *to* export (usually this is C<@_>).  The C<$package> argument is
  currently unused.
  
  For example, suppose that you have a module, A, which already has an
  import function:
  
      package A;
  
      @ISA = qw(Exporter);
      @EXPORT_OK = qw ($b);
  
      sub import
      {
  	$A::b = 1;     # not a very useful import method
      }
  
  and you want to Export symbol C<$A::b> back to the module that called 
  package A. Since Exporter relies on the import method to work, via 
  inheritance, as it stands Exporter::import() will never get called. 
  Instead, say the following:
  
      package A;
      @ISA = qw(Exporter);
      @EXPORT_OK = qw ($b);
  
      sub import
      {
  	$A::b = 1;
  	A->export_to_level(1, @_);
      }
  
  This will export the symbols one level 'above' the current package - ie: to 
  the program or module that used package A. 
  
  Note: Be careful not to modify C<@_> at all before you call export_to_level
  - or people using your package will get very unexplained results!
  
  =head2 Exporting without inheriting from Exporter
  
  By including Exporter in your C<@ISA> you inherit an Exporter's import() method
  but you also inherit several other helper methods which you probably don't
  want. To avoid this you can do
  
    package YourModule;
    use Exporter qw( import );
  
  which will export Exporter's own import() method into YourModule.
  Everything will work as before but you won't need to include Exporter in
  C<@YourModule::ISA>.
  
  Note: This feature was introduced in version 5.57
  of Exporter, released with perl 5.8.3.
  
  =head2 Module Version Checking
  
  The Exporter module will convert an attempt to import a number from a
  module into a call to C<< $module_name->require_version($value) >>. This can
  be used to validate that the version of the module being used is
  greater than or equal to the required version.
  
  The Exporter module supplies a default C<require_version> method which
  checks the value of C<$VERSION> in the exporting module.
  
  Since the default C<require_version> method treats the C<$VERSION> number as
  a simple numeric value it will regard version 1.10 as lower than
  1.9. For this reason it is strongly recommended that you use numbers
  with at least two decimal places, e.g., 1.09.
  
  =head2 Managing Unknown Symbols
  
  In some situations you may want to prevent certain symbols from being
  exported. Typically this applies to extensions which have functions
  or constants that may not exist on some systems.
  
  The names of any symbols that cannot be exported should be listed
  in the C<@EXPORT_FAIL> array.
  
  If a module attempts to import any of these symbols the Exporter
  will give the module an opportunity to handle the situation before
  generating an error. The Exporter will call an export_fail method
  with a list of the failed symbols:
  
    @failed_symbols = $module_name->export_fail(@failed_symbols);
  
  If the C<export_fail> method returns an empty list then no error is
  recorded and all the requested symbols are exported. If the returned
  list is not empty then an error is generated for each symbol and the
  export fails. The Exporter provides a default C<export_fail> method which
  simply returns the list unchanged.
  
  Uses for the C<export_fail> method include giving better error messages
  for some symbols and performing lazy architectural checks (put more
  symbols into C<@EXPORT_FAIL> by default and then take them out if someone
  actually tries to use them and an expensive check shows that they are
  usable on that platform).
  
  =head2 Tag Handling Utility Functions
  
  Since the symbols listed within C<%EXPORT_TAGS> must also appear in either
  C<@EXPORT> or C<@EXPORT_OK>, two utility functions are provided which allow
  you to easily add tagged sets of symbols to C<@EXPORT> or C<@EXPORT_OK>:
  
    %EXPORT_TAGS = (foo => [qw(aa bb cc)], bar => [qw(aa cc dd)]);
  
    Exporter::export_tags('foo');     # add aa, bb and cc to @EXPORT
    Exporter::export_ok_tags('bar');  # add aa, cc and dd to @EXPORT_OK
  
  Any names which are not tags are added to C<@EXPORT> or C<@EXPORT_OK>
  unchanged but will trigger a warning (with C<-w>) to avoid misspelt tags
  names being silently added to C<@EXPORT> or C<@EXPORT_OK>. Future versions
  may make this a fatal error.
  
  =head2 Generating combined tags
  
  If several symbol categories exist in C<%EXPORT_TAGS>, it's usually
  useful to create the utility ":all" to simplify "use" statements.
  
  The simplest way to do this is:
  
    %EXPORT_TAGS = (foo => [qw(aa bb cc)], bar => [qw(aa cc dd)]);
  
    # add all the other ":class" tags to the ":all" class,
    # deleting duplicates
    {
      my %seen;
  
      push @{$EXPORT_TAGS{all}},
        grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}} foreach keys %EXPORT_TAGS;
    }
  
  F<CGI.pm> creates an ":all" tag which contains some (but not really
  all) of its categories.  That could be done with one small
  change:
  
    # add some of the other ":class" tags to the ":all" class,
    # deleting duplicates
    {
      my %seen;
  
      push @{$EXPORT_TAGS{all}},
        grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}}
          foreach qw/html2 html3 netscape form cgi internal/;
    }
  
  Note that the tag names in C<%EXPORT_TAGS> don't have the leading ':'.
  
  =head2 C<AUTOLOAD>ed Constants
  
  Many modules make use of C<AUTOLOAD>ing for constant subroutines to
  avoid having to compile and waste memory on rarely used values (see
  L<perlsub> for details on constant subroutines).  Calls to such
  constant subroutines are not optimized away at compile time because
  they can't be checked at compile time for constancy.
  
  Even if a prototype is available at compile time, the body of the
  subroutine is not (it hasn't been C<AUTOLOAD>ed yet). perl needs to
  examine both the C<()> prototype and the body of a subroutine at
  compile time to detect that it can safely replace calls to that
  subroutine with the constant value.
  
  A workaround for this is to call the constants once in a C<BEGIN> block:
  
     package My ;
  
     use Socket ;
  
     foo( SO_LINGER );     ## SO_LINGER NOT optimized away; called at runtime
     BEGIN { SO_LINGER }
     foo( SO_LINGER );     ## SO_LINGER optimized away at compile time.
  
  This forces the C<AUTOLOAD> for C<SO_LINGER> to take place before
  SO_LINGER is encountered later in C<My> package.
  
  If you are writing a package that C<AUTOLOAD>s, consider forcing
  an C<AUTOLOAD> for any constants explicitly imported by other packages
  or which are usually used when your package is C<use>d.
  
  =head1 Good Practices
  
  =head2 Declaring C<@EXPORT_OK> and Friends
  
  When using C<Exporter> with the standard C<strict> and C<warnings>
  pragmas, the C<our> keyword is needed to declare the package
  variables C<@EXPORT_OK>, C<@EXPORT>, C<@ISA>, etc.
  
    our @ISA = qw(Exporter);
    our @EXPORT_OK = qw(munge frobnicate);
  
  If backward compatibility for Perls under 5.6 is important,
  one must write instead a C<use vars> statement.
  
    use vars qw(@ISA @EXPORT_OK);
    @ISA = qw(Exporter);
    @EXPORT_OK = qw(munge frobnicate);
  
  =head2 Playing Safe
  
  There are some caveats with the use of runtime statements
  like C<require Exporter> and the assignment to package
  variables, which can very subtle for the unaware programmer.
  This may happen for instance with mutually recursive
  modules, which are affected by the time the relevant
  constructions are executed.
  
  The ideal (but a bit ugly) way to never have to think
  about that is to use C<BEGIN> blocks. So the first part
  of the L</SYNOPSIS> code could be rewritten as:
  
    package YourModule;
  
    use strict;
    use warnings;
  
    our (@ISA, @EXPORT_OK);
    BEGIN {
       require Exporter;
       @ISA = qw(Exporter);
       @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
    }
  
  The C<BEGIN> will assure that the loading of F<Exporter.pm>
  and the assignments to C<@ISA> and C<@EXPORT_OK> happen
  immediately, leaving no room for something to get awry
  or just plain wrong.
  
  With respect to loading C<Exporter> and inheriting, there
  are alternatives with the use of modules like C<base> and C<parent>.
  
    use base qw( Exporter );
    # or
    use parent qw( Exporter );
  
  Any of these statements are nice replacements for
  C<BEGIN { require Exporter; @ISA = qw(Exporter); }>
  with the same compile-time effect. The basic difference
  is that C<base> code interacts with declared C<fields>
  while C<parent> is a streamlined version of the older
  C<base> code to just establish the IS-A relationship.
  
  For more details, see the documentation and code of
  L<base> and L<parent>.
  
  Another thorough remedy to that runtime vs. 
  compile-time trap is to use L<Exporter::Easy>,
  which is a wrapper of Exporter that allows all
  boilerplate code at a single gulp in the
  use statement.
  
     use Exporter::Easy (
         OK => [ qw(munge frobnicate) ],
     );
     # @ISA setup is automatic
     # all assignments happen at compile time
  
  =head2 What not to Export
  
  You have been warned already in L</Selecting What To Export>
  to not export:
  
  =over 4
  
  =item *
  
  method names (because you don't need to
  and that's likely to not do what you want),
  
  =item *
  
  anything by default (because you don't want to surprise your users...
  badly)
  
  =item *
  
  anything you don't need to (because less is more)
  
  =back
  
  There's one more item to add to this list. Do B<not>
  export variable names. Just because C<Exporter> lets you
  do that, it does not mean you should.
  
    @EXPORT_OK = qw( $svar @avar %hvar ); # DON'T!
  
  Exporting variables is not a good idea. They can
  change under the hood, provoking horrible
  effects at-a-distance, that are too hard to track
  and to fix. Trust me: they are not worth it.
  
  To provide the capability to set/get class-wide
  settings, it is best instead to provide accessors
  as subroutines or class methods instead.
  
  =head1 SEE ALSO
  
  C<Exporter> is definitely not the only module with
  symbol exporter capabilities. At CPAN, you may find
  a bunch of them. Some are lighter. Some
  provide improved APIs and features. Peek the one
  that fits your needs. The following is
  a sample list of such modules.
  
      Exporter::Easy
      Exporter::Lite
      Exporter::Renaming
      Exporter::Tidy
      Sub::Exporter / Sub::Installer
      Perl6::Export / Perl6::Export::Attrs
  
  =head1 LICENSE
  
  This library is free software. You can redistribute it
  and/or modify it under the same terms as Perl itself.
  
  =cut
  
  
  
EXPORTER

$fatpacked{"Exporter/Heavy.pm"} = <<'EXPORTER_HEAVY';
  package Exporter::Heavy;
  
  use strict;
  no strict 'refs';
  
  # On one line so MakeMaker will see it.
  require Exporter;  our $VERSION = $Exporter::VERSION;
  
  =head1 NAME
  
  Exporter::Heavy - Exporter guts
  
  =head1 SYNOPSIS
  
  (internal use only)
  
  =head1 DESCRIPTION
  
  No user-serviceable parts inside.
  
  =cut
  
  #
  # We go to a lot of trouble not to 'require Carp' at file scope,
  #  because Carp requires Exporter, and something has to give.
  #
  
  sub _rebuild_cache {
      my ($pkg, $exports, $cache) = @_;
      s/^&// foreach @$exports;
      @{$cache}{@$exports} = (1) x @$exports;
      my $ok = \@{"${pkg}::EXPORT_OK"};
      if (@$ok) {
  	s/^&// foreach @$ok;
  	@{$cache}{@$ok} = (1) x @$ok;
      }
  }
  
  sub heavy_export {
  
      # First make import warnings look like they're coming from the "use".
      local $SIG{__WARN__} = sub {
  	my $text = shift;
  	if ($text =~ s/ at \S*Exporter\S*.pm line \d+.*\n//) {
  	    require Carp;
  	    local $Carp::CarpLevel = 1;	# ignore package calling us too.
  	    Carp::carp($text);
  	}
  	else {
  	    warn $text;
  	}
      };
      local $SIG{__DIE__} = sub {
  	require Carp;
  	local $Carp::CarpLevel = 1;	# ignore package calling us too.
  	Carp::croak("$_[0]Illegal null symbol in \@${1}::EXPORT")
  	    if $_[0] =~ /^Unable to create sub named "(.*?)::"/;
      };
  
      my($pkg, $callpkg, @imports) = @_;
      my($type, $sym, $cache_is_current, $oops);
      my($exports, $export_cache) = (\@{"${pkg}::EXPORT"},
                                     $Exporter::Cache{$pkg} ||= {});
  
      if (@imports) {
  	if (!%$export_cache) {
  	    _rebuild_cache ($pkg, $exports, $export_cache);
  	    $cache_is_current = 1;
  	}
  
  	if (grep m{^[/!:]}, @imports) {
  	    my $tagsref = \%{"${pkg}::EXPORT_TAGS"};
  	    my $tagdata;
  	    my %imports;
  	    my($remove, $spec, @names, @allexports);
  	    # negated first item implies starting with default set:
  	    unshift @imports, ':DEFAULT' if $imports[0] =~ m/^!/;
  	    foreach $spec (@imports){
  		$remove = $spec =~ s/^!//;
  
  		if ($spec =~ s/^://){
  		    if ($spec eq 'DEFAULT'){
  			@names = @$exports;
  		    }
  		    elsif ($tagdata = $tagsref->{$spec}) {
  			@names = @$tagdata;
  		    }
  		    else {
  			warn qq["$spec" is not defined in %${pkg}::EXPORT_TAGS];
  			++$oops;
  			next;
  		    }
  		}
  		elsif ($spec =~ m:^/(.*)/$:){
  		    my $patn = $1;
  		    @allexports = keys %$export_cache unless @allexports; # only do keys once
  		    @names = grep(/$patn/, @allexports); # not anchored by default
  		}
  		else {
  		    @names = ($spec); # is a normal symbol name
  		}
  
  		warn "Import ".($remove ? "del":"add").": @names "
  		    if $Exporter::Verbose;
  
  		if ($remove) {
  		   foreach $sym (@names) { delete $imports{$sym} } 
  		}
  		else {
  		    @imports{@names} = (1) x @names;
  		}
  	    }
  	    @imports = keys %imports;
  	}
  
          my @carp;
  	foreach $sym (@imports) {
  	    if (!$export_cache->{$sym}) {
  		if ($sym =~ m/^\d/) {
  		    $pkg->VERSION($sym); # inherit from UNIVERSAL
  		    # If the version number was the only thing specified
  		    # then we should act as if nothing was specified:
  		    if (@imports == 1) {
  			@imports = @$exports;
  			last;
  		    }
  		    # We need a way to emulate 'use Foo ()' but still
  		    # allow an easy version check: "use Foo 1.23, ''";
  		    if (@imports == 2 and !$imports[1]) {
  			@imports = ();
  			last;
  		    }
  		} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {
  		    # Last chance - see if they've updated EXPORT_OK since we
  		    # cached it.
  
  		    unless ($cache_is_current) {
  			%$export_cache = ();
  			_rebuild_cache ($pkg, $exports, $export_cache);
  			$cache_is_current = 1;
  		    }
  
  		    if (!$export_cache->{$sym}) {
  			# accumulate the non-exports
  			push @carp,
  			  qq["$sym" is not exported by the $pkg module\n];
  			$oops++;
  		    }
  		}
  	    }
  	}
  	if ($oops) {
  	    require Carp;
  	    Carp::croak("@{carp}Can't continue after import errors");
  	}
      }
      else {
  	@imports = @$exports;
      }
  
      my($fail, $fail_cache) = (\@{"${pkg}::EXPORT_FAIL"},
                                $Exporter::FailCache{$pkg} ||= {});
  
      if (@$fail) {
  	if (!%$fail_cache) {
  	    # Build cache of symbols. Optimise the lookup by adding
  	    # barewords twice... both with and without a leading &.
  	    # (Technique could be applied to $export_cache at cost of memory)
  	    my @expanded = map { /^\w/ ? ($_, '&'.$_) : $_ } @$fail;
  	    warn "${pkg}::EXPORT_FAIL cached: @expanded" if $Exporter::Verbose;
  	    @{$fail_cache}{@expanded} = (1) x @expanded;
  	}
  	my @failed;
  	foreach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }
  	if (@failed) {
  	    @failed = $pkg->export_fail(@failed);
  	    foreach $sym (@failed) {
                  require Carp;
  		Carp::carp(qq["$sym" is not implemented by the $pkg module ],
  			"on this architecture");
  	    }
  	    if (@failed) {
  		require Carp;
  		Carp::croak("Can't continue after import errors");
  	    }
  	}
      }
  
      warn "Importing into $callpkg from $pkg: ",
  		join(", ",sort @imports) if $Exporter::Verbose;
  
      foreach $sym (@imports) {
  	# shortcut for the common case of no type character
  	(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
  	    unless $sym =~ s/^(\W)//;
  	$type = $1;
  	no warnings 'once';
  	*{"${callpkg}::$sym"} =
  	    $type eq '&' ? \&{"${pkg}::$sym"} :
  	    $type eq '$' ? \${"${pkg}::$sym"} :
  	    $type eq '@' ? \@{"${pkg}::$sym"} :
  	    $type eq '%' ? \%{"${pkg}::$sym"} :
  	    $type eq '*' ?  *{"${pkg}::$sym"} :
  	    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
      }
  }
  
  sub heavy_export_to_level
  {
        my $pkg = shift;
        my $level = shift;
        (undef) = shift;			# XXX redundant arg
        my $callpkg = caller($level);
        $pkg->export($callpkg, @_);
  }
  
  # Utility functions
  
  sub _push_tags {
      my($pkg, $var, $syms) = @_;
      my @nontag = ();
      my $export_tags = \%{"${pkg}::EXPORT_TAGS"};
      push(@{"${pkg}::$var"},
  	map { $export_tags->{$_} ? @{$export_tags->{$_}} 
                                   : scalar(push(@nontag,$_),$_) }
  		(@$syms) ? @$syms : keys %$export_tags);
      if (@nontag and $^W) {
  	# This may change to a die one day
  	require Carp;
  	Carp::carp(join(", ", @nontag)." are not tags of $pkg");
      }
  }
  
  sub heavy_require_version {
      my($self, $wanted) = @_;
      my $pkg = ref $self || $self;
      return ${pkg}->VERSION($wanted);
  }
  
  sub heavy_export_tags {
    _push_tags((caller)[0], "EXPORT",    \@_);
  }
  
  sub heavy_export_ok_tags {
    _push_tags((caller)[0], "EXPORT_OK", \@_);
  }
  
  1;
EXPORTER_HEAVY

$fatpacked{"Exporter/Lite.pm"} = <<'EXPORTER_LITE';
  package Exporter::Lite;
  
  require 5.004;
  
  # Using strict or vars almost doubles our load time.  Turn them back
  # on when debugging.
  #use strict 'vars';  # we're going to be doing a lot of sym refs
  #use vars qw($VERSION @EXPORT);
  
  $VERSION = 0.02;
  @EXPORT = qw(import);   # we'll know pretty fast if it doesn't work :)
  
  
  
  sub import {
      my($exporter, @imports)  = @_;
      my($caller, $file, $line) = caller;
  
      unless( @imports ) {        # Default import.
          @imports = @{$exporter.'::EXPORT'};
      }
      else {
          # Because @EXPORT_OK = () would indicate that nothing is
          # to be exported, we cannot simply check the length of @EXPORT_OK.
          # We must to oddness to see if the variable exists at all as
          # well as avoid autovivification.
          # XXX idea stolen from base.pm, this might be all unnecessary
          my $eokglob;
          if( $eokglob = ${$exporter.'::'}{EXPORT_OK} and *$eokglob{ARRAY} ) {
              if( @{$exporter.'::EXPORT_OK'} ) {
                  # This can also be cached.
                  my %ok = map { s/^&//; $_ => 1 } @{$exporter.'::EXPORT_OK'},
                                                   @{$exporter.'::EXPORT'};
  
                  my($denied) = grep {s/^&//; !$ok{$_}} @imports;
                  _not_exported($denied, $exporter, $file, $line) if $denied;
              }
              else {      # We don't export anything.
                  _not_exported($imports[0], $exporter, $file, $line);
              }
          }
      }
  
      _export($caller, $exporter, @imports);
  }
  
  
  
  sub _export {
      my($caller, $exporter, @imports) = @_;
  
      # Stole this from Exporter::Heavy.  I'm sure it can be written better
      # but I'm lazy at the moment.
      foreach my $sym (@imports) {
          # shortcut for the common case of no type character
          (*{$caller.'::'.$sym} = \&{$exporter.'::'.$sym}, next)
              unless $sym =~ s/^(\W)//;
  
          my $type = $1;
          my $caller_sym = $caller.'::'.$sym;
          my $export_sym = $exporter.'::'.$sym;
          *{$caller_sym} =
              $type eq '&' ? \&{$export_sym} :
              $type eq '$' ? \${$export_sym} :
              $type eq '@' ? \@{$export_sym} :
              $type eq '%' ? \%{$export_sym} :
              $type eq '*' ?  *{$export_sym} :
              do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
      }
  }
  
  
  #"#
  sub _not_exported {
      my($thing, $exporter, $file, $line) = @_;
      die sprintf qq|"%s" is not exported by the %s module at %s line %d\n|,
          $thing, $exporter, $file, $line;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Exporter::Lite - Lightweight exporting of variables
  
  =head1 SYNOPSIS
  
    package Foo;
    use Exporter::Lite;
  
    # Just like Exporter.
    @EXPORT       = qw($This That);
    @EXPORT_OK    = qw(@Left %Right);
  
  
    # Meanwhile, in another piece of code!
    package Bar;
    use Foo;  # exports $This and &That.
  
  
  =head1 DESCRIPTION
  
  This is an alternative to Exporter intended to provide a lightweight
  subset of its functionality.  It supports C<import()>, C<@EXPORT> and
  C<@EXPORT_OK> and not a whole lot else.
  
  Unlike Exporter, it is not necessary to inherit from Exporter::Lite
  (ie. no C<@ISA = qw(Exporter::Lite)> mantra).  Exporter::Lite simply
  exports its import() function.  This might be called a "mix-in".
  
  Setting up a module to export its variables and functions is simple:
  
      package My::Module;
      use Exporter::Lite;
  
      @EXPORT = qw($Foo bar);
  
  now when you C<use My::Module>, C<$Foo> and C<bar()> will show up.
  
  In order to make exporting optional, use @EXPORT_OK.
  
      package My::Module;
      use Exporter::Lite;
  
      @EXPORT_OK = qw($Foo bar);
  
  when My::Module is used, C<$Foo> and C<bar()> will I<not> show up.
  You have to ask for them.  C<use My::Module qw($Foo bar)>.
  
  =head1 Methods
  
  Export::Lite has one public method, import(), which is called
  automaticly when your modules is use()'d.  
  
  In normal usage you don't have to worry about this at all.
  
  =over 4
  
  =item B<import>
  
    Some::Module->import;
    Some::Module->import(@symbols);
  
  Works just like C<Exporter::import()> excepting it only honors
  @Some::Module::EXPORT and @Some::Module::EXPORT_OK.
  
  The given @symbols are exported to the current package provided they
  are in @Some::Module::EXPORT or @Some::Module::EXPORT_OK.  Otherwise
  an exception is thrown (ie. the program dies).
  
  If @symbols is not given, everything in @Some::Module::EXPORT is
  exported.
  
  =back
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item '"%s" is not exported by the %s module'
  
  Attempted to import a symbol which is not in @EXPORT or @EXPORT_OK.
  
  =item 'Can\'t export symbol: %s'
  
  Attempted to import a symbol of an unknown type (ie. the leading $@% salad
  wasn't recognized).
  
  =back
  
  =head1 BUGS and CAVEATS
  
  Its not yet clear if this is actually any lighter or faster than
  Exporter.  I know its at least on par.
  
  OTOH, the docs are much clearer and not having to say C<@ISA =
  qw(Exporter)> is kinda nice.
  
  =head1 AUTHORS
  
  Michael G Schwern <schwern@pobox.com>
  
  =head1 LICENSE
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://www.perl.com/perl/misc/Artistic.html>
  
  =head1 SEE ALSO
  
  L<Exporter>, L<Exporter::Simple>, L<UNIVERSAL::exports>
  
  =cut
EXPORTER_LITE

$fatpacked{"File/Which.pm"} = <<'FILE_WHICH';
  package File::Which;
  
  use 5.004;
  use strict;
  use Exporter   ();
  use File::Spec ();
  
  use vars qw{$VERSION @ISA @EXPORT @EXPORT_OK};
  BEGIN {
  	$VERSION   = '1.09';
  	@ISA       = 'Exporter';
  	@EXPORT    = 'which';
  	@EXPORT_OK = 'where';
  }
  
  use constant IS_VMS => ($^O eq 'VMS');
  use constant IS_MAC => ($^O eq 'MacOS');
  use constant IS_DOS => ($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');
  
  # For Win32 systems, stores the extensions used for
  # executable files
  # For others, the empty string is used
  # because 'perl' . '' eq 'perl' => easier
  my @PATHEXT = ('');
  if ( IS_DOS ) {
  	# WinNT. PATHEXT might be set on Cygwin, but not used.
  	if ( $ENV{PATHEXT} ) {
  		push @PATHEXT, split ';', $ENV{PATHEXT};
  	} else {
  		# Win9X or other: doesn't have PATHEXT, so needs hardcoded.
  		push @PATHEXT, qw{.com .exe .bat};
  	}
  } elsif ( IS_VMS ) {
  	push @PATHEXT, qw{.exe .com};
  }
  
  sub which {
  	my ($exec) = @_;
  
  	return undef unless $exec;
  
  	my $all = wantarray;
  	my @results = ();
  
  	# check for aliases first
  	if ( IS_VMS ) {
  		my $symbol = `SHOW SYMBOL $exec`;
  		chomp($symbol);
  		unless ( $? ) {
  			return $symbol unless $all;
  			push @results, $symbol;
  		}
  	}
  	if ( IS_MAC ) {
  		my @aliases = split /\,/, $ENV{Aliases};
  		foreach my $alias ( @aliases ) {
  			# This has not been tested!!
  			# PPT which says MPW-Perl cannot resolve `Alias $alias`,
  			# let's just hope it's fixed
  			if ( lc($alias) eq lc($exec) ) {
  				chomp(my $file = `Alias $alias`);
  				last unless $file;  # if it failed, just go on the normal way
  				return $file unless $all;
  				push @results, $file;
  				# we can stop this loop as if it finds more aliases matching,
  				# it'll just be the same result anyway
  				last;
  			}
  		}
  	}
  
  	my @path = File::Spec->path;
  	if ( IS_DOS or IS_VMS or IS_MAC ) {
  		unshift @path, File::Spec->curdir;
  	}
  
  	foreach my $base ( map { File::Spec->catfile($_, $exec) } @path ) {
  		for my $ext ( @PATHEXT ) {
  			my $file = $base.$ext;
  
  			# We don't want dirs (as they are -x)
  			next if -d $file;
  
  			if (
  				# Executable, normal case
  				-x _
  				or (
  					# MacOS doesn't mark as executable so we check -e
  					IS_MAC
  					||
  					(
  						IS_DOS
  						and
  						grep {
  							$file =~ /$_\z/i
  						} @PATHEXT[1..$#PATHEXT]
  					)
  					# DOSish systems don't pass -x on
  					# non-exe/bat/com files. so we check -e.
  					# However, we don't want to pass -e on files
  					# that aren't in PATHEXT, like README.
  					and -e _
  				)
  			) {
  				return $file unless $all;
  				push @results, $file;
  			}
  		}
  	}
  
  	if ( $all ) {
  		return @results;
  	} else {
  		return undef;
  	}
  }
  
  sub where {
  	# force wantarray
  	my @res = which($_[0]);
  	return @res;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  File::Which - Portable implementation of the `which' utility
  
  =head1 SYNOPSIS
  
    use File::Which;                  # exports which()
    use File::Which qw(which where);  # exports which() and where()
    
    my $exe_path = which('perldoc');
    
    my @paths = where('perl');
    - Or -
    my @paths = which('perl'); # an array forces search for all of them
  
  =head1 DESCRIPTION
  
  C<File::Which> was created to be able to get the paths to executable programs
  on systems under which the `which' program wasn't implemented in the shell.
  
  C<File::Which> searches the directories of the user's C<PATH> (as returned by
  C<File::Spec-E<gt>path()>), looking for executable files having the name
  specified as a parameter to C<which()>. Under Win32 systems, which do not have a
  notion of directly executable files, but uses special extensions such as C<.exe>
  and C<.bat> to identify them, C<File::Which> takes extra steps to assure that
  you will find the correct file (so for example, you might be searching for
  C<perl>, it'll try F<perl.exe>, F<perl.bat>, etc.)
  
  =head1 Steps Used on Win32, DOS, OS2 and VMS
  
  =head2 Windows NT
  
  Windows NT has a special environment variable called C<PATHEXT>, which is used
  by the shell to look for executable files. Usually, it will contain a list in
  the form C<.EXE;.BAT;.COM;.JS;.VBS> etc. If C<File::Which> finds such an
  environment variable, it parses the list and uses it as the different
  extensions.
  
  =head2 Windows 9x and other ancient Win/DOS/OS2
  
  This set of operating systems don't have the C<PATHEXT> variable, and usually
  you will find executable files there with the extensions C<.exe>, C<.bat> and
  (less likely) C<.com>. C<File::Which> uses this hardcoded list if it's running
  under Win32 but does not find a C<PATHEXT> variable.
  
  =head2 VMS
  
  Same case as Windows 9x: uses C<.exe> and C<.com> (in that order).
  
  =head1 Functions
  
  =head2 which($short_exe_name)
  
  Exported by default.
  
  C<$short_exe_name> is the name used in the shell to call the program (for
  example, C<perl>).
  
  If it finds an executable with the name you specified, C<which()> will return
  the absolute path leading to this executable (for example, F</usr/bin/perl> or
  F<C:\Perl\Bin\perl.exe>).
  
  If it does I<not> find the executable, it returns C<undef>.
  
  If C<which()> is called in list context, it will return I<all> the
  matches.
  
  =head2 where($short_exe_name)
  
  Not exported by default.
  
  Same as C<which($short_exe_name)> in array context. Same as the
  C<`where'> utility, will return an array containing all the path names
  matching C<$short_exe_name>.
  
  =head1 BUGS AND CAVEATS
  
  Not tested on VMS or MacOS, although there is platform specific code
  for those. Anyone who haves a second would be very kind to send me a
  report of how it went.
  
  File::Spec adds the current directory to the front of PATH if on
  Win32, VMS or MacOS. I have no knowledge of those so don't know if the
  current directory is searced first or not. Could someone please tell
  me?
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=File-Which>
  
  For other issues, contact the maintainer.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Per Einar Ellefsen E<lt>pereinar@cpan.orgE<gt>
  
  Originated in F<modperl-2.0/lib/Apache/Build.pm>. Changed for use in DocSet
  (for the mod_perl site) and Win32-awareness by me, with slight modifications
  by Stas Bekman, then extracted to create C<File::Which>.
  
  Version 0.04 had some significant platform-related changes, taken from
  the Perl Power Tools C<`which'> implementation by Abigail with
  enhancements from Peter Prymmer. See
  L<http://www.perl.com/language/ppt/src/which/index.html> for more
  information.
  
  =head1 COPYRIGHT
  
  Copyright 2002 Per Einar Ellefsen.
  
  Some parts copyright 2009 Adam Kennedy.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<File::Spec>, L<which(1)>, Perl Power Tools:
  L<http://www.perl.com/language/ppt/index.html>.
  
  =cut
FILE_WHICH

$fatpacked{"Getopt/Long.pm"} = <<'GETOPT_LONG';
  # Getopt::Long.pm -- Universal options parsing
  
  package Getopt::Long;
  
  # RCS Status      : $Id: Long.pm,v 2.76 2009/03/30 20:54:30 jv Exp $
  # Author          : Johan Vromans
  # Created On      : Tue Sep 11 15:00:12 1990
  # Last Modified By: Johan Vromans
  # Last Modified On: Mon Mar 30 22:51:17 2009
  # Update Count    : 1601
  # Status          : Released
  
  ################ Module Preamble ################
  
  use 5.004;
  
  use strict;
  
  use vars qw($VERSION);
  $VERSION        =  2.38;
  # For testing versions only.
  #use vars qw($VERSION_STRING);
  #$VERSION_STRING = "2.38";
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  # Exported subroutines.
  sub GetOptions(@);		# always
  sub GetOptionsFromArray(@);	# on demand
  sub GetOptionsFromString(@);	# on demand
  sub Configure(@);		# on demand
  sub HelpMessage(@);		# on demand
  sub VersionMessage(@);		# in demand
  
  BEGIN {
      # Init immediately so their contents can be used in the 'use vars' below.
      @EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
      @EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure
  		    &GetOptionsFromArray &GetOptionsFromString);
  }
  
  # User visible variables.
  use vars @EXPORT, @EXPORT_OK;
  use vars qw($error $debug $major_version $minor_version);
  # Deprecated visible variables.
  use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
  	    $passthrough);
  # Official invisible variables.
  use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
  
  # Public subroutines.
  sub config(@);			# deprecated name
  
  # Private subroutines.
  sub ConfigDefaults();
  sub ParseOptionSpec($$);
  sub OptCtl($);
  sub FindOption($$$$$);
  sub ValidValue ($$$$$);
  
  ################ Local Variables ################
  
  # $requested_version holds the version that was mentioned in the 'use'
  # or 'require', if any. It can be used to enable or disable specific
  # features.
  my $requested_version = 0;
  
  ################ Resident subroutines ################
  
  sub ConfigDefaults() {
      # Handle POSIX compliancy.
      if ( defined $ENV{"POSIXLY_CORRECT"} ) {
  	$genprefix = "(--|-)";
  	$autoabbrev = 0;		# no automatic abbrev of options
  	$bundling = 0;			# no bundling of single letter switches
  	$getopt_compat = 0;		# disallow '+' to start options
  	$order = $REQUIRE_ORDER;
      }
      else {
  	$genprefix = "(--|-|\\+)";
  	$autoabbrev = 1;		# automatic abbrev of options
  	$bundling = 0;			# bundling off by default
  	$getopt_compat = 1;		# allow '+' to start options
  	$order = $PERMUTE;
      }
      # Other configurable settings.
      $debug = 0;			# for debugging
      $error = 0;			# error tally
      $ignorecase = 1;		# ignore case when matching options
      $passthrough = 0;		# leave unrecognized options alone
      $gnu_compat = 0;		# require --opt=val if value is optional
      $longprefix = "(--)";       # what does a long prefix look like
  }
  
  # Override import.
  sub import {
      my $pkg = shift;		# package
      my @syms = ();		# symbols to import
      my @config = ();		# configuration
      my $dest = \@syms;		# symbols first
      for ( @_ ) {
  	if ( $_ eq ':config' ) {
  	    $dest = \@config;	# config next
  	    next;
  	}
  	push(@$dest, $_);	# push
      }
      # Hide one level and call super.
      local $Exporter::ExportLevel = 1;
      push(@syms, qw(&GetOptions)) if @syms; # always export GetOptions
      $pkg->SUPER::import(@syms);
      # And configure.
      Configure(@config) if @config;
  }
  
  ################ Initialization ################
  
  # Values for $order. See GNU getopt.c for details.
  ($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
  # Version major/minor numbers.
  ($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;
  
  ConfigDefaults();
  
  ################ OO Interface ################
  
  package Getopt::Long::Parser;
  
  # Store a copy of the default configuration. Since ConfigDefaults has
  # just been called, what we get from Configure is the default.
  my $default_config = do {
      Getopt::Long::Configure ()
  };
  
  sub new {
      my $that = shift;
      my $class = ref($that) || $that;
      my %atts = @_;
  
      # Register the callers package.
      my $self = { caller_pkg => (caller)[0] };
  
      bless ($self, $class);
  
      # Process config attributes.
      if ( defined $atts{config} ) {
  	my $save = Getopt::Long::Configure ($default_config, @{$atts{config}});
  	$self->{settings} = Getopt::Long::Configure ($save);
  	delete ($atts{config});
      }
      # Else use default config.
      else {
  	$self->{settings} = $default_config;
      }
  
      if ( %atts ) {		# Oops
  	die(__PACKAGE__.": unhandled attributes: ".
  	    join(" ", sort(keys(%atts)))."\n");
      }
  
      $self;
  }
  
  sub configure {
      my ($self) = shift;
  
      # Restore settings, merge new settings in.
      my $save = Getopt::Long::Configure ($self->{settings}, @_);
  
      # Restore orig config and save the new config.
      $self->{settings} = Getopt::Long::Configure ($save);
  }
  
  sub getoptions {
      my ($self) = shift;
  
      # Restore config settings.
      my $save = Getopt::Long::Configure ($self->{settings});
  
      # Call main routine.
      my $ret = 0;
      $Getopt::Long::caller = $self->{caller_pkg};
  
      eval {
  	# Locally set exception handler to default, otherwise it will
  	# be called implicitly here, and again explicitly when we try
  	# to deliver the messages.
  	local ($SIG{__DIE__}) = 'DEFAULT';
  	$ret = Getopt::Long::GetOptions (@_);
      };
  
      # Restore saved settings.
      Getopt::Long::Configure ($save);
  
      # Handle errors and return value.
      die ($@) if $@;
      return $ret;
  }
  
  package Getopt::Long;
  
  ################ Back to Normal ################
  
  # Indices in option control info.
  # Note that ParseOptions uses the fields directly. Search for 'hard-wired'.
  use constant CTL_TYPE    => 0;
  #use constant   CTL_TYPE_FLAG   => '';
  #use constant   CTL_TYPE_NEG    => '!';
  #use constant   CTL_TYPE_INCR   => '+';
  #use constant   CTL_TYPE_INT    => 'i';
  #use constant   CTL_TYPE_INTINC => 'I';
  #use constant   CTL_TYPE_XINT   => 'o';
  #use constant   CTL_TYPE_FLOAT  => 'f';
  #use constant   CTL_TYPE_STRING => 's';
  
  use constant CTL_CNAME   => 1;
  
  use constant CTL_DEFAULT => 2;
  
  use constant CTL_DEST    => 3;
   use constant   CTL_DEST_SCALAR => 0;
   use constant   CTL_DEST_ARRAY  => 1;
   use constant   CTL_DEST_HASH   => 2;
   use constant   CTL_DEST_CODE   => 3;
  
  use constant CTL_AMIN    => 4;
  use constant CTL_AMAX    => 5;
  
  # FFU.
  #use constant CTL_RANGE   => ;
  #use constant CTL_REPEAT  => ;
  
  # Rather liberal patterns to match numbers.
  use constant PAT_INT   => "[-+]?_*[0-9][0-9_]*";
  use constant PAT_XINT  =>
    "(?:".
  	  "[-+]?_*[1-9][0-9_]*".
    "|".
  	  "0x_*[0-9a-f][0-9a-f_]*".
    "|".
  	  "0b_*[01][01_]*".
    "|".
  	  "0[0-7_]*".
    ")";
  use constant PAT_FLOAT => "[-+]?[0-9._]+(\.[0-9_]+)?([eE][-+]?[0-9_]+)?";
  
  sub GetOptions(@) {
      # Shift in default array.
      unshift(@_, \@ARGV);
      # Try to keep caller() and Carp consitent.
      goto &GetOptionsFromArray;
  }
  
  sub GetOptionsFromString(@) {
      my ($string) = shift;
      require Text::ParseWords;
      my $args = [ Text::ParseWords::shellwords($string) ];
      $caller ||= (caller)[0];	# current context
      my $ret = GetOptionsFromArray($args, @_);
      return ( $ret, $args ) if wantarray;
      if ( @$args ) {
  	$ret = 0;
  	warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n");
      }
      $ret;
  }
  
  sub GetOptionsFromArray(@) {
  
      my ($argv, @optionlist) = @_;	# local copy of the option descriptions
      my $argend = '--';		# option list terminator
      my %opctl = ();		# table of option specs
      my $pkg = $caller || (caller)[0];	# current context
  				# Needed if linkage is omitted.
      my @ret = ();		# accum for non-options
      my %linkage;		# linkage
      my $userlinkage;		# user supplied HASH
      my $opt;			# current option
      my $prefix = $genprefix;	# current prefix
  
      $error = '';
  
      if ( $debug ) {
  	# Avoid some warnings if debugging.
  	local ($^W) = 0;
  	print STDERR
  	  ("Getopt::Long $Getopt::Long::VERSION (",
  	   '$Revision: 2.76 $', ") ",
  	   "called from package \"$pkg\".",
  	   "\n  ",
  	   "argv: (@$argv)",
  	   "\n  ",
  	   "autoabbrev=$autoabbrev,".
  	   "bundling=$bundling,",
  	   "getopt_compat=$getopt_compat,",
  	   "gnu_compat=$gnu_compat,",
  	   "order=$order,",
  	   "\n  ",
  	   "ignorecase=$ignorecase,",
  	   "requested_version=$requested_version,",
  	   "passthrough=$passthrough,",
  	   "genprefix=\"$genprefix\",",
  	   "longprefix=\"$longprefix\".",
  	   "\n");
      }
  
      # Check for ref HASH as first argument.
      # First argument may be an object. It's OK to use this as long
      # as it is really a hash underneath.
      $userlinkage = undef;
      if ( @optionlist && ref($optionlist[0]) and
  	 UNIVERSAL::isa($optionlist[0],'HASH') ) {
  	$userlinkage = shift (@optionlist);
  	print STDERR ("=> user linkage: $userlinkage\n") if $debug;
      }
  
      # See if the first element of the optionlist contains option
      # starter characters.
      # Be careful not to interpret '<>' as option starters.
      if ( @optionlist && $optionlist[0] =~ /^\W+$/
  	 && !($optionlist[0] eq '<>'
  	      && @optionlist > 0
  	      && ref($optionlist[1])) ) {
  	$prefix = shift (@optionlist);
  	# Turn into regexp. Needs to be parenthesized!
  	$prefix =~ s/(\W)/\\$1/g;
  	$prefix = "([" . $prefix . "])";
  	print STDERR ("=> prefix=\"$prefix\"\n") if $debug;
      }
  
      # Verify correctness of optionlist.
      %opctl = ();
      while ( @optionlist ) {
  	my $opt = shift (@optionlist);
  
  	unless ( defined($opt) ) {
  	    $error .= "Undefined argument in option spec\n";
  	    next;
  	}
  
  	# Strip leading prefix so people can specify "--foo=i" if they like.
  	$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  
  	if ( $opt eq '<>' ) {
  	    if ( (defined $userlinkage)
  		&& !(@optionlist > 0 && ref($optionlist[0]))
  		&& (exists $userlinkage->{$opt})
  		&& ref($userlinkage->{$opt}) ) {
  		unshift (@optionlist, $userlinkage->{$opt});
  	    }
  	    unless ( @optionlist > 0
  		    && ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
  		$error .= "Option spec <> requires a reference to a subroutine\n";
  		# Kill the linkage (to avoid another error).
  		shift (@optionlist)
  		  if @optionlist && ref($optionlist[0]);
  		next;
  	    }
  	    $linkage{'<>'} = shift (@optionlist);
  	    next;
  	}
  
  	# Parse option spec.
  	my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  	unless ( defined $name ) {
  	    # Failed. $orig contains the error message. Sorry for the abuse.
  	    $error .= $orig;
  	    # Kill the linkage (to avoid another error).
  	    shift (@optionlist)
  	      if @optionlist && ref($optionlist[0]);
  	    next;
  	}
  
  	# If no linkage is supplied in the @optionlist, copy it from
  	# the userlinkage if available.
  	if ( defined $userlinkage ) {
  	    unless ( @optionlist > 0 && ref($optionlist[0]) ) {
  		if ( exists $userlinkage->{$orig} &&
  		     ref($userlinkage->{$orig}) ) {
  		    print STDERR ("=> found userlinkage for \"$orig\": ",
  				  "$userlinkage->{$orig}\n")
  			if $debug;
  		    unshift (@optionlist, $userlinkage->{$orig});
  		}
  		else {
  		    # Do nothing. Being undefined will be handled later.
  		    next;
  		}
  	    }
  	}
  
  	# Copy the linkage. If omitted, link to global variable.
  	if ( @optionlist > 0 && ref($optionlist[0]) ) {
  	    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  		if $debug;
  	    my $rl = ref($linkage{$orig} = shift (@optionlist));
  
  	    if ( $rl eq "ARRAY" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  	    }
  	    elsif ( $rl eq "HASH" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_HASH;
  	    }
  	    elsif ( $rl eq "SCALAR" || $rl eq "REF" ) {
  #		if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  #		    my $t = $linkage{$orig};
  #		    $$t = $linkage{$orig} = [];
  #		}
  #		elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  #		}
  #		else {
  		    # Ok.
  #		}
  	    }
  	    elsif ( $rl eq "CODE" ) {
  		# Ok.
  	    }
  	    else {
  		$error .= "Invalid option linkage for \"$opt\"\n";
  	    }
  	}
  	else {
  	    # Link to global $opt_XXX variable.
  	    # Make sure a valid perl identifier results.
  	    my $ov = $orig;
  	    $ov =~ s/\W/_/g;
  	    if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  		print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;");
  	    }
  	    elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  		print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;");
  	    }
  	    else {
  		print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;");
  	    }
  	}
  
  	if ( $opctl{$name}[CTL_TYPE] eq 'I'
  	     && ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY
  		  || $opctl{$name}[CTL_DEST] == CTL_DEST_HASH )
  	   ) {
  	    $error .= "Invalid option linkage for \"$opt\"\n";
  	}
  
      }
  
      # Bail out if errors found.
      die ($error) if $error;
      $error = 0;
  
      # Supply --version and --help support, if needed and allowed.
      if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{version}) ) {
  	    $opctl{version} = ['','version',0,CTL_DEST_CODE,undef];
  	    $linkage{version} = \&VersionMessage;
  	}
  	$auto_version = 1;
      }
      if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{help}) && !defined($opctl{'?'}) ) {
  	    $opctl{help} = $opctl{'?'} = ['','help',0,CTL_DEST_CODE,undef];
  	    $linkage{help} = \&HelpMessage;
  	}
  	$auto_help = 1;
      }
  
      # Show the options tables if debugging.
      if ( $debug ) {
  	my ($arrow, $k, $v);
  	$arrow = "=> ";
  	while ( ($k,$v) = each(%opctl) ) {
  	    print STDERR ($arrow, "\$opctl{$k} = $v ", OptCtl($v), "\n");
  	    $arrow = "   ";
  	}
      }
  
      # Process argument list
      my $goon = 1;
      while ( $goon && @$argv > 0 ) {
  
  	# Get next argument.
  	$opt = shift (@$argv);
  	print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  
  	# Double dash is option list terminator.
  	if ( $opt eq $argend ) {
  	  push (@ret, $argend) if $passthrough;
  	  last;
  	}
  
  	# Look it up.
  	my $tryopt = $opt;
  	my $found;		# success status
  	my $key;		# key (if hash type)
  	my $arg;		# option argument
  	my $ctl;		# the opctl entry
  
  	($found, $opt, $ctl, $arg, $key) =
  	  FindOption ($argv, $prefix, $argend, $opt, \%opctl);
  
  	if ( $found ) {
  
  	    # FindOption undefines $opt in case of errors.
  	    next unless defined $opt;
  
  	    my $argcnt = 0;
  	    while ( defined $arg ) {
  
  		# Get the canonical name.
  		print STDERR ("=> cname for \"$opt\" is ") if $debug;
  		$opt = $ctl->[CTL_CNAME];
  		print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  
  		if ( defined $linkage{$opt} ) {
  		    print STDERR ("=> ref(\$L{$opt}) -> ",
  				  ref($linkage{$opt}), "\n") if $debug;
  
  		    if ( ref($linkage{$opt}) eq 'SCALAR'
  			 || ref($linkage{$opt}) eq 'REF' ) {
  			if ( $ctl->[CTL_TYPE] eq '+' ) {
  			    print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")
  			      if $debug;
  			    if ( defined ${$linkage{$opt}} ) {
  			        ${$linkage{$opt}} += $arg;
  			    }
  		            else {
  			        ${$linkage{$opt}} = $arg;
  			    }
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to ARRAY\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = [];
  			    print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			      if $debug;
  			    push (@{$linkage{$opt}}, $arg);
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to HASH\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = {};
  			    print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			      if $debug;
  			    $linkage{$opt}->{$key} = $arg;
  			}
  			else {
  			    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  			      if $debug;
  			    ${$linkage{$opt}} = $arg;
  		        }
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
  			print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			    if $debug;
  			push (@{$linkage{$opt}}, $arg);
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'HASH' ) {
  			print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$linkage{$opt}->{$key} = $arg;
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'CODE' ) {
  			print STDERR ("=> &L{$opt}(\"$opt\"",
  				      $ctl->[CTL_DEST] == CTL_DEST_HASH ? ", \"$key\"" : "",
  				      ", \"$arg\")\n")
  			    if $debug;
  			my $eval_error = do {
  			    local $@;
  			    local $SIG{__DIE__}  = 'DEFAULT';
  			    eval {
  				&{$linkage{$opt}}
  				  (Getopt::Long::CallBack->new
  				   (name    => $opt,
  				    ctl     => $ctl,
  				    opctl   => \%opctl,
  				    linkage => \%linkage,
  				    prefix  => $prefix,
  				   ),
  				   $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
  				   $arg);
  			    };
  			    $@;
  			};
  			print STDERR ("=> die($eval_error)\n")
  			  if $debug && $eval_error ne '';
  			if ( $eval_error =~ /^!/ ) {
  			    if ( $eval_error =~ /^!FINISH\b/ ) {
  				$goon = 0;
  			    }
  			}
  			elsif ( $eval_error ne '' ) {
  			    warn ($eval_error);
  			    $error++;
  			}
  		    }
  		    else {
  			print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
  				      "\" in linkage\n");
  			die("Getopt::Long -- internal error!\n");
  		    }
  		}
  		# No entry in linkage means entry in userlinkage.
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")
  			    if $debug;
  			push (@{$userlinkage->{$opt}}, $arg);
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
  			    if $debug;
  			$userlinkage->{$opt} = [$arg];
  		    }
  		}
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$userlinkage->{$opt}->{$key} = $arg;
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
  			    if $debug;
  			$userlinkage->{$opt} = {$key => $arg};
  		    }
  		}
  		else {
  		    if ( $ctl->[CTL_TYPE] eq '+' ) {
  			print STDERR ("=> \$L{$opt} += \"$arg\"\n")
  			  if $debug;
  			if ( defined $userlinkage->{$opt} ) {
  			    $userlinkage->{$opt} += $arg;
  			}
  			else {
  			    $userlinkage->{$opt} = $arg;
  			}
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
  			$userlinkage->{$opt} = $arg;
  		    }
  		}
  
  		$argcnt++;
  		last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  		undef($arg);
  
  		# Need more args?
  		if ( $argcnt < $ctl->[CTL_AMIN] ) {
  		    if ( @$argv ) {
  			if ( ValidValue($ctl, $argv->[0], 1, $argend, $prefix) ) {
  			    $arg = shift(@$argv);
  			    $arg =~ tr/_//d if $ctl->[CTL_TYPE] =~ /^[iIo]$/;
  			    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  			      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  			    next;
  			}
  			warn("Value \"$$argv[0]\" invalid for option $opt\n");
  			$error++;
  		    }
  		    else {
  			warn("Insufficient arguments for option $opt\n");
  			$error++;
  		    }
  		}
  
  		# Any more args?
  		if ( @$argv && ValidValue($ctl, $argv->[0], 0, $argend, $prefix) ) {
  		    $arg = shift(@$argv);
  		    $arg =~ tr/_//d if $ctl->[CTL_TYPE] =~ /^[iIo]$/;
  		    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  		      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  		    next;
  		}
  	    }
  	}
  
  	# Not an option. Save it if we $PERMUTE and don't have a <>.
  	elsif ( $order == $PERMUTE ) {
  	    # Try non-options call-back.
  	    my $cb;
  	    if ( (defined ($cb = $linkage{'<>'})) ) {
  		print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")
  		  if $debug;
  		my $eval_error = do {
  		    local $@;
  		    local $SIG{__DIE__}  = 'DEFAULT';
  		    eval {
  			&$cb
  			  (Getopt::Long::CallBack->new
  			   (name    => $tryopt,
  			    ctl     => $ctl,
  			    opctl   => \%opctl,
  			    linkage => \%linkage,
  			    prefix  => $prefix,
  			   ));
  		    };
  		    $@;
  		};
  		print STDERR ("=> die($eval_error)\n")
  		  if $debug && $eval_error ne '';
  		if ( $eval_error =~ /^!/ ) {
  		    if ( $eval_error =~ /^!FINISH\b/ ) {
  			$goon = 0;
  		    }
  		}
  		elsif ( $eval_error ne '' ) {
  		    warn ($eval_error);
  		    $error++;
  		}
  	    }
  	    else {
  		print STDERR ("=> saving \"$tryopt\" ",
  			      "(not an option, may permute)\n") if $debug;
  		push (@ret, $tryopt);
  	    }
  	    next;
  	}
  
  	# ...otherwise, terminate.
  	else {
  	    # Push this one back and exit.
  	    unshift (@$argv, $tryopt);
  	    return ($error == 0);
  	}
  
      }
  
      # Finish.
      if ( @ret && $order == $PERMUTE ) {
  	#  Push back accumulated arguments
  	print STDERR ("=> restoring \"", join('" "', @ret), "\"\n")
  	    if $debug;
  	unshift (@$argv, @ret);
      }
  
      return ($error == 0);
  }
  
  # A readable representation of what's in an optbl.
  sub OptCtl ($) {
      my ($v) = @_;
      my @v = map { defined($_) ? ($_) : ("<undef>") } @$v;
      "[".
        join(",",
  	   "\"$v[CTL_TYPE]\"",
  	   "\"$v[CTL_CNAME]\"",
  	   "\"$v[CTL_DEFAULT]\"",
  	   ("\$","\@","\%","\&")[$v[CTL_DEST] || 0],
  	   $v[CTL_AMIN] || '',
  	   $v[CTL_AMAX] || '',
  #	   $v[CTL_RANGE] || '',
  #	   $v[CTL_REPEAT] || '',
  	  ). "]";
  }
  
  # Parse an option specification and fill the tables.
  sub ParseOptionSpec ($$) {
      my ($opt, $opctl) = @_;
  
      # Match option spec.
      if ( $opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Alias names, or "?"
  		     (?: \| (?: \? | \w[-\w]* ) )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x ) {
  	return (undef, "Error in option spec: \"$opt\"\n");
      }
  
      my ($names, $spec) = ($1, $2);
      $spec = '' unless defined $spec;
  
      # $orig keeps track of the primary name the user specified.
      # This name will be used for the internal or external linkage.
      # In other words, if the user specifies "FoO|BaR", it will
      # match any case combinations of 'foo' and 'bar', but if a global
      # variable needs to be set, it will be $opt_FoO in the exact case
      # as specified.
      my $orig;
  
      my @names;
      if ( defined $names ) {
  	@names =  split (/\|/, $names);
  	$orig = $names[0];
      }
      else {
  	@names = ('');
  	$orig = '';
      }
  
      # Construct the opctl entries.
      my $entry;
      if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
  	# Fields are hard-wired here.
  	$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
      }
      elsif ( $spec =~ /^:(-?\d+|\+)([@%])?$/ ) {
  	my $def = $1;
  	my $dest = $2;
  	my $type = $def eq '+' ? 'I' : 'i';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,$def eq '+' ? undef : $def,
  		  $dest,0,1];
      }
      else {
  	my ($mand, $type, $dest) =
  	  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
  	return (undef, "Cannot repeat while bundling: \"$opt\"\n")
  	  if $bundling && defined($4);
  	my ($mi, $cm, $ma) = ($5, $6, $7);
  	return (undef, "{0} is useless in option spec: \"$opt\"\n")
  	  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
  
  	$type = 'i' if $type eq 'n';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Default minargs to 1/0 depending on mand status.
  	$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
  	# Adjust mand status according to minargs.
  	$mand = $mi ? '=' : ':';
  	# Adjust maxargs.
  	$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
  	return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
  	  if defined($ma) && !$ma;
  	return (undef, "Max less than min in option spec: \"$opt\"\n")
  	  if defined($ma) && $ma < $mi;
  
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
      }
  
      # Process all names. First is canonical, the rest are aliases.
      my $dups = '';
      foreach ( @names ) {
  
  	$_ = lc ($_)
  	  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
  
  	if ( exists $opctl->{$_} ) {
  	    $dups .= "Duplicate specification \"$opt\" for option \"$_\"\n";
  	}
  
  	if ( $spec eq '!' ) {
  	    $opctl->{"no$_"} = $entry;
  	    $opctl->{"no-$_"} = $entry;
  	    $opctl->{$_} = [@$entry];
  	    $opctl->{$_}->[CTL_TYPE] = '';
  	}
  	else {
  	    $opctl->{$_} = $entry;
  	}
      }
  
      if ( $dups && $^W ) {
  	foreach ( split(/\n+/, $dups) ) {
  	    warn($_."\n");
  	}
      }
      ($names[0], $orig);
  }
  
  # Option lookup.
  sub FindOption ($$$$$) {
  
      # returns (1, $opt, $ctl, $arg, $key) if okay,
      # returns (1, undef) if option in error,
      # returns (0) otherwise.
  
      my ($argv, $prefix, $argend, $opt, $opctl) = @_;
  
      print STDERR ("=> find \"$opt\"\n") if $debug;
  
      return (0) unless $opt =~ /^$prefix(.*)$/s;
      return (0) if $opt eq "-" && !defined $opctl->{''};
  
      $opt = $+;
      my $starter = $1;
  
      print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
  
      my $optarg;			# value supplied with --opt=value
      my $rest;			# remainder from unbundling
  
      # If it is a long option, it may include the value.
      # With getopt_compat, only if not bundling.
      if ( ($starter=~/^$longprefix$/
            || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
  	  && $opt =~ /^([^=]+)=(.*)$/s ) {
  	$opt = $1;
  	$optarg = $2;
  	print STDERR ("=> option \"", $opt,
  		      "\", optarg = \"$optarg\"\n") if $debug;
      }
  
      #### Look it up ###
  
      my $tryopt = $opt;		# option to try
  
      if ( $bundling && $starter eq '-' ) {
  
  	# To try overrides, obey case ignore.
  	$tryopt = $ignorecase ? lc($opt) : $opt;
  
  	# If bundling == 2, long options can override bundles.
  	if ( $bundling == 2 && length($tryopt) > 1
  	     && defined ($opctl->{$tryopt}) ) {
  	    print STDERR ("=> $starter$tryopt overrides unbundling\n")
  	      if $debug;
  	}
  	else {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    $rest = undef unless $rest ne '';
  	}
      }
  
      # Try auto-abbreviation.
      elsif ( $autoabbrev && $opt ne "" ) {
  	# Sort the possible long option names.
  	my @names = sort(keys (%$opctl));
  	# Downcase if allowed.
  	$opt = lc ($opt) if $ignorecase;
  	$tryopt = $opt;
  	# Turn option name into pattern.
  	my $pat = quotemeta ($opt);
  	# Look up in option names.
  	my @hits = grep (/^$pat/, @names);
  	print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
  		      "out of ", scalar(@names), "\n") if $debug;
  
  	# Check for ambiguous results.
  	unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
  	    # See if all matches are for the same option.
  	    my %hit;
  	    foreach ( @hits ) {
  		my $hit = $_;
  		$hit = $opctl->{$hit}->[CTL_CNAME]
  		  if defined $opctl->{$hit}->[CTL_CNAME];
  		$hit{$hit} = 1;
  	    }
  	    # Remove auto-supplied options (version, help).
  	    if ( keys(%hit) == 2 ) {
  		if ( $auto_version && exists($hit{version}) ) {
  		    delete $hit{version};
  		}
  		elsif ( $auto_help && exists($hit{help}) ) {
  		    delete $hit{help};
  		}
  	    }
  	    # Now see if it really is ambiguous.
  	    unless ( keys(%hit) == 1 ) {
  		return (0) if $passthrough;
  		warn ("Option ", $opt, " is ambiguous (",
  		      join(", ", @hits), ")\n");
  		$error++;
  		return (1, undef);
  	    }
  	    @hits = keys(%hit);
  	}
  
  	# Complete the option name, if appropriate.
  	if ( @hits == 1 && $hits[0] ne $opt ) {
  	    $tryopt = $hits[0];
  	    $tryopt = lc ($tryopt) if $ignorecase;
  	    print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
  		if $debug;
  	}
      }
  
      # Map to all lowercase if ignoring case.
      elsif ( $ignorecase ) {
  	$tryopt = lc ($opt);
      }
  
      # Check validity by fetching the info.
      my $ctl = $opctl->{$tryopt};
      unless  ( defined $ctl ) {
  	return (0) if $passthrough;
  	# Pretend one char when bundling.
  	if ( $bundling == 1 && length($starter) == 1 ) {
  	    $opt = substr($opt,0,1);
              unshift (@$argv, $starter.$rest) if defined $rest;
  	}
  	if ( $opt eq "" ) {
  	    warn ("Missing option after ", $starter, "\n");
  	}
  	else {
  	    warn ("Unknown option: ", $opt, "\n");
  	}
  	$error++;
  	return (1, undef);
      }
      # Apparently valid.
      $opt = $tryopt;
      print STDERR ("=> found ", OptCtl($ctl),
  		  " for \"", $opt, "\"\n") if $debug;
  
      #### Determine argument status ####
  
      # If it is an option w/o argument, we're almost finished with it.
      my $type = $ctl->[CTL_TYPE];
      my $arg;
  
      if ( $type eq '' || $type eq '!' || $type eq '+' ) {
  	if ( defined $optarg ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " does not take an argument\n");
  	    $error++;
  	    undef $opt;
  	}
  	elsif ( $type eq '' || $type eq '+' ) {
  	    # Supply explicit value.
  	    $arg = 1;
  	}
  	else {
  	    $opt =~ s/^no-?//i;	# strip NO prefix
  	    $arg = 0;		# supply explicit value
  	}
  	unshift (@$argv, $starter.$rest) if defined $rest;
  	return (1, $opt, $ctl, $arg);
      }
  
      # Get mandatory status and type info.
      my $mand = $ctl->[CTL_AMIN];
  
      # Check if there is an option argument available.
      if ( $gnu_compat && defined $optarg && $optarg eq '' ) {
  	return (1, $opt, $ctl, $type eq 's' ? '' : 0) ;#unless $mand;
  	$optarg = 0 unless $type eq 's';
      }
  
      # Check if there is an option argument available.
      if ( defined $optarg
  	 ? ($optarg eq '')
  	 : !(defined $rest || @$argv > 0) ) {
  	# Complain if this option needs an argument.
  #	if ( $mand && !($type eq 's' ? defined($optarg) : 0) ) {
  	if ( $mand ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " requires an argument\n");
  	    $error++;
  	    return (1, undef);
  	}
  	if ( $type eq 'I' ) {
  	    # Fake incremental type.
  	    my @c = @$ctl;
  	    $c[CTL_TYPE] = '+';
  	    return (1, $opt, \@c, 1);
  	}
  	return (1, $opt, $ctl,
  		defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  		$type eq 's' ? '' : 0);
      }
  
      # Get (possibly optional) argument.
      $arg = (defined $rest ? $rest
  	    : (defined $optarg ? $optarg : shift (@$argv)));
  
      # Get key if this is a "name=value" pair for a hash option.
      my $key;
      if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
  	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2)
  	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  	     ($mand ? undef : ($type eq 's' ? "" : 1)));
  	if (! defined $arg) {
  	    warn ("Option $opt, key \"$key\", requires a value\n");
  	    $error++;
  	    # Push back.
  	    unshift (@$argv, $starter.$rest) if defined $rest;
  	    return (1, undef);
  	}
      }
  
      #### Check if the argument is valid for this option ####
  
      my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1, $opt, $ctl, $arg, $key) if $mand;
  
  	# Same for optional string as a hash value
  	return (1, $opt, $ctl, $arg, $key)
  	  if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  
  	# An optional string takes almost anything.
  	return (1, $opt, $ctl, $arg, $key)
  	  if defined $optarg || defined $rest;
  	return (1, $opt, $ctl, $arg, $key) if $arg eq "-"; # ??
  
  	# Check for option or option list terminator.
  	if ($arg eq $argend ||
  	    $arg =~ /^$prefix.+/) {
  	    # Push back.
  	    unshift (@$argv, $arg);
  	    # Supply empty value.
  	    $arg = '';
  	}
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  
  	if ( $bundling && defined $rest
  	     && $rest =~ /^($key_valid)($o_valid)(.*)$/si ) {
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/si ) {
  	    $arg =~ tr/_//d;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (",
  		      $type eq 'o' ? "extended " : '',
  		      "number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		if ( $type eq 'I' ) {
  		    # Fake incremental type.
  		    my @c = @$ctl;
  		    $c[CTL_TYPE] = '+';
  		    return (1, $opt, \@c, 1);
  		}
  		# Supply default value.
  		$arg = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 0;
  	    }
  	}
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	# We require at least one digit before a point or 'e',
  	# and at least one digit following the point and 'e'.
  	# [-]NN[.NN][eNN]
  	my $o_valid = PAT_FLOAT;
  	if ( $bundling && defined $rest &&
  	     $rest =~ /^($key_valid)($o_valid)(.*)$/s ) {
  	    $arg =~ tr/_//d;
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/ ) {
  	    $arg =~ tr/_//d;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (real number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		# Supply default value.
  		$arg = 0.0;
  	    }
  	}
      }
      else {
  	die("Getopt::Long internal error (Can't happen)\n");
      }
      return (1, $opt, $ctl, $arg, $key);
  }
  
  sub ValidValue ($$$$$) {
      my ($ctl, $arg, $mand, $argend, $prefix) = @_;
  
      if ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  	return 0 unless $arg =~ /[^=]+=(.*)/;
  	$arg = $1;
      }
  
      my $type = $ctl->[CTL_TYPE];
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1) if $mand;
  
  	return (1) if $arg eq "-";
  
  	# Check for option or option list terminator.
  	return 0 if $arg eq $argend || $arg =~ /^$prefix.+/;
  	return 1;
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  	return $arg =~ /^$o_valid$/si;
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	# We require at least one digit before a point or 'e',
  	# and at least one digit following the point and 'e'.
  	# [-]NN[.NN][eNN]
  	my $o_valid = PAT_FLOAT;
  	return $arg =~ /^$o_valid$/;
      }
      die("ValidValue: Cannot happen\n");
  }
  
  # Getopt::Long Configuration.
  sub Configure (@) {
      my (@options) = @_;
  
      my $prevconfig =
        [ $error, $debug, $major_version, $minor_version,
  	$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	$longprefix ];
  
      if ( ref($options[0]) eq 'ARRAY' ) {
  	( $error, $debug, $major_version, $minor_version,
  	  $autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	  $longprefix ) = @{shift(@options)};
      }
  
      my $opt;
      foreach $opt ( @options ) {
  	my $try = lc ($opt);
  	my $action = 1;
  	if ( $try =~ /^no_?(.*)$/s ) {
  	    $action = 0;
  	    $try = $+;
  	}
  	if ( ($try eq 'default' or $try eq 'defaults') && $action ) {
  	    ConfigDefaults ();
  	}
  	elsif ( ($try eq 'posix_default' or $try eq 'posix_defaults') ) {
  	    local $ENV{POSIXLY_CORRECT};
  	    $ENV{POSIXLY_CORRECT} = 1 if $action;
  	    ConfigDefaults ();
  	}
  	elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
  	    $autoabbrev = $action;
  	}
  	elsif ( $try eq 'getopt_compat' ) {
  	    $getopt_compat = $action;
              $genprefix = $action ? "(--|-|\\+)" : "(--|-)";
  	}
  	elsif ( $try eq 'gnu_getopt' ) {
  	    if ( $action ) {
  		$gnu_compat = 1;
  		$bundling = 1;
  		$getopt_compat = 0;
                  $genprefix = "(--|-)";
  		$order = $PERMUTE;
  	    }
  	}
  	elsif ( $try eq 'gnu_compat' ) {
  	    $gnu_compat = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?version$/ ) {
  	    $auto_version = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?help$/ ) {
  	    $auto_help = $action;
  	}
  	elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
  	    $ignorecase = $action;
  	}
  	elsif ( $try eq 'ignorecase_always' or $try eq 'ignore_case_always' ) {
  	    $ignorecase = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'bundling' ) {
  	    $bundling = $action;
  	}
  	elsif ( $try eq 'bundling_override' ) {
  	    $bundling = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'require_order' ) {
  	    $order = $action ? $REQUIRE_ORDER : $PERMUTE;
  	}
  	elsif ( $try eq 'permute' ) {
  	    $order = $action ? $PERMUTE : $REQUIRE_ORDER;
  	}
  	elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
  	    $passthrough = $action;
  	}
  	elsif ( $try =~ /^prefix=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Turn into regexp. Needs to be parenthesized!
  	    $genprefix = "(" . quotemeta($genprefix) . ")";
  	    eval { '' =~ /$genprefix/; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"") if $@;
  	}
  	elsif ( $try =~ /^prefix_pattern=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Parenthesize if needed.
  	    $genprefix = "(" . $genprefix . ")"
  	      unless $genprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$genprefix"; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"") if $@;
  	}
  	elsif ( $try =~ /^long_prefix_pattern=(.+)$/ && $action ) {
  	    $longprefix = $1;
  	    # Parenthesize if needed.
  	    $longprefix = "(" . $longprefix . ")"
  	      unless $longprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$longprefix"; };
  	    die("Getopt::Long: invalid long prefix pattern \"$longprefix\"") if $@;
  	}
  	elsif ( $try eq 'debug' ) {
  	    $debug = $action;
  	}
  	else {
  	    die("Getopt::Long: unknown config parameter \"$opt\"")
  	}
      }
      $prevconfig;
  }
  
  # Deprecated name.
  sub config (@) {
      Configure (@_);
  }
  
  # Issue a standard message for --version.
  #
  # The arguments are mostly the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub VersionMessage(@) {
      # Massage args.
      my $pa = setup_pa_args("version", @_);
  
      my $v = $main::VERSION;
      my $fh = $pa->{-output} ||
        ($pa->{-exitval} eq "NOEXIT" || $pa->{-exitval} < 2) ? \*STDOUT : \*STDERR;
  
      print $fh (defined($pa->{-message}) ? $pa->{-message} : (),
  	       $0, defined $v ? " version $v" : (),
  	       "\n",
  	       "(", __PACKAGE__, "::", "GetOptions",
  	       " version ",
  	       defined($Getopt::Long::VERSION_STRING)
  	         ? $Getopt::Long::VERSION_STRING : $VERSION, ";",
  	       " Perl version ",
  	       $] >= 5.006 ? sprintf("%vd", $^V) : $],
  	       ")\n");
      exit($pa->{-exitval}) unless $pa->{-exitval} eq "NOEXIT";
  }
  
  # Issue a standard message for --help.
  #
  # The arguments are the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub HelpMessage(@) {
      eval {
  	require Pod::Usage;
  	import Pod::Usage;
  	1;
      } || die("Cannot provide help: cannot load Pod::Usage\n");
  
      # Note that pod2usage will issue a warning if -exitval => NOEXIT.
      pod2usage(setup_pa_args("help", @_));
  
  }
  
  # Helper routine to set up a normalized hash ref to be used as
  # argument to pod2usage.
  sub setup_pa_args($@) {
      my $tag = shift;		# who's calling
  
      # If called by direct binding to an option, it will get the option
      # name and value as arguments. Remove these, if so.
      @_ = () if @_ == 2 && $_[0] eq $tag;
  
      my $pa;
      if ( @_ > 1 ) {
  	$pa = { @_ };
      }
      else {
  	$pa = shift || {};
      }
  
      # At this point, $pa can be a number (exit value), string
      # (message) or hash with options.
  
      if ( UNIVERSAL::isa($pa, 'HASH') ) {
  	# Get rid of -msg vs. -message ambiguity.
  	$pa->{-message} = $pa->{-msg};
  	delete($pa->{-msg});
      }
      elsif ( $pa =~ /^-?\d+$/ ) {
  	$pa = { -exitval => $pa };
      }
      else {
  	$pa = { -message => $pa };
      }
  
      # These are _our_ defaults.
      $pa->{-verbose} = 0 unless exists($pa->{-verbose});
      $pa->{-exitval} = 0 unless exists($pa->{-exitval});
      $pa;
  }
  
  # Sneak way to know what version the user requested.
  sub VERSION {
      $requested_version = $_[1];
      shift->SUPER::VERSION(@_);
  }
  
  package Getopt::Long::CallBack;
  
  sub new {
      my ($pkg, %atts) = @_;
      bless { %atts }, $pkg;
  }
  
  sub name {
      my $self = shift;
      ''.$self->{name};
  }
  
  use overload
    # Treat this object as an ordinary string for legacy API.
    '""'	   => \&name,
    fallback => 1;
  
  1;
  
  ################ Documentation ################
  
  =head1 NAME
  
  Getopt::Long - Extended processing of command line options
  
  =head1 SYNOPSIS
  
    use Getopt::Long;
    my $data   = "file.dat";
    my $length = 24;
    my $verbose;
    $result = GetOptions ("length=i" => \$length,    # numeric
                          "file=s"   => \$data,      # string
  			"verbose"  => \$verbose);  # flag
  
  =head1 DESCRIPTION
  
  The Getopt::Long module implements an extended getopt function called
  GetOptions(). This function adheres to the POSIX syntax for command
  line options, with GNU extensions. In general, this means that options
  have long names instead of single letters, and are introduced with a
  double dash "--". Support for bundling of command line options, as was
  the case with the more traditional single-letter approach, is provided
  but not enabled by default.
  
  =head1 Command Line Options, an Introduction
  
  Command line operated programs traditionally take their arguments from
  the command line, for example filenames or other information that the
  program needs to know. Besides arguments, these programs often take
  command line I<options> as well. Options are not necessary for the
  program to work, hence the name 'option', but are used to modify its
  default behaviour. For example, a program could do its job quietly,
  but with a suitable option it could provide verbose information about
  what it did.
  
  Command line options come in several flavours. Historically, they are
  preceded by a single dash C<->, and consist of a single letter.
  
      -l -a -c
  
  Usually, these single-character options can be bundled:
  
      -lac
  
  Options can have values, the value is placed after the option
  character. Sometimes with whitespace in between, sometimes not:
  
      -s 24 -s24
  
  Due to the very cryptic nature of these options, another style was
  developed that used long names. So instead of a cryptic C<-l> one
  could use the more descriptive C<--long>. To distinguish between a
  bundle of single-character options and a long one, two dashes are used
  to precede the option name. Early implementations of long options used
  a plus C<+> instead. Also, option values could be specified either
  like
  
      --size=24
  
  or
  
      --size 24
  
  The C<+> form is now obsolete and strongly deprecated.
  
  =head1 Getting Started with Getopt::Long
  
  Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was the
  first Perl module that provided support for handling the new style of
  command line options, hence the name Getopt::Long. This module also
  supports single-character options and bundling. Single character
  options may be any alphabetic character, a question mark, and a dash.
  Long options may consist of a series of letters, digits, and dashes.
  Although this is currently not enforced by Getopt::Long, multiple
  consecutive dashes are not allowed, and the option name must not end
  with a dash.
  
  To use Getopt::Long from a Perl program, you must include the
  following line in your Perl program:
  
      use Getopt::Long;
  
  This will load the core of the Getopt::Long module and prepare your
  program for using it. Most of the actual Getopt::Long code is not
  loaded until you really call one of its functions.
  
  In the default configuration, options names may be abbreviated to
  uniqueness, case does not matter, and a single dash is sufficient,
  even for long option names. Also, options may be placed between
  non-option arguments. See L<Configuring Getopt::Long> for more
  details on how to configure Getopt::Long.
  
  =head2 Simple options
  
  The most simple options are the ones that take no values. Their mere
  presence on the command line enables the option. Popular examples are:
  
      --all --verbose --quiet --debug
  
  Handling simple options is straightforward:
  
      my $verbose = '';	# option variable with default value (false)
      my $all = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose, 'all' => \$all);
  
  The call to GetOptions() parses the command line arguments that are
  present in C<@ARGV> and sets the option variable to the value C<1> if
  the option did occur on the command line. Otherwise, the option
  variable is not touched. Setting the option value to true is often
  called I<enabling> the option.
  
  The option name as specified to the GetOptions() function is called
  the option I<specification>. Later we'll see that this specification
  can contain more than just the option name. The reference to the
  variable is called the option I<destination>.
  
  GetOptions() will return a true value if the command line could be
  processed successfully. Otherwise, it will write error messages to
  STDERR, and return a false result.
  
  =head2 A little bit less simple options
  
  Getopt::Long supports two useful variants of simple options:
  I<negatable> options and I<incremental> options.
  
  A negatable option is specified with an exclamation mark C<!> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose!' => \$verbose);
  
  Now, using C<--verbose> on the command line will enable C<$verbose>,
  as expected. But it is also allowed to use C<--noverbose>, which will
  disable C<$verbose> by setting its value to C<0>. Using a suitable
  default value, the program can find out whether C<$verbose> is false
  by default, or disabled by using C<--noverbose>.
  
  An incremental option is specified with a plus C<+> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose+' => \$verbose);
  
  Using C<--verbose> on the command line will increment the value of
  C<$verbose>. This way the program can keep track of how many times the
  option occurred on the command line. For example, each occurrence of
  C<--verbose> could increase the verbosity level of the program.
  
  =head2 Mixing command line option with other arguments
  
  Usually programs take command line options as well as other arguments,
  for example, file names. It is good practice to always specify the
  options first, and the other arguments last. Getopt::Long will,
  however, allow the options and arguments to be mixed and 'filter out'
  all the options before passing the rest of the arguments to the
  program. To stop Getopt::Long from processing further arguments,
  insert a double dash C<--> on the command line:
  
      --size 24 -- --all
  
  In this example, C<--all> will I<not> be treated as an option, but
  passed to the program unharmed, in C<@ARGV>.
  
  =head2 Options with values
  
  For options that take values it must be specified whether the option
  value is required or not, and what kind of value the option expects.
  
  Three kinds of values are supported: integer numbers, floating point
  numbers, and strings.
  
  If the option value is required, Getopt::Long will take the
  command line argument that follows the option and assign this to the
  option variable. If, however, the option value is specified as
  optional, this will only be done if that value does not look like a
  valid command line option itself.
  
      my $tag = '';	# option variable with default value
      GetOptions ('tag=s' => \$tag);
  
  In the option specification, the option name is followed by an equals
  sign C<=> and the letter C<s>. The equals sign indicates that this
  option requires a value. The letter C<s> indicates that this value is
  an arbitrary string. Other possible value types are C<i> for integer
  values, and C<f> for floating point values. Using a colon C<:> instead
  of the equals sign indicates that the option value is optional. In
  this case, if no suitable value is supplied, string valued options get
  an empty string C<''> assigned, while numeric options are set to C<0>.
  
  =head2 Options with multiple values
  
  Options sometimes take several values. For example, a program could
  use multiple directories to search for library files:
  
      --library lib/stdlib --library lib/extlib
  
  To accomplish this behaviour, simply specify an array reference as the
  destination for the option:
  
      GetOptions ("library=s" => \@libfiles);
  
  Alternatively, you can specify that the option can have multiple
  values by adding a "@", and pass a scalar reference as the
  destination:
  
      GetOptions ("library=s@" => \$libfiles);
  
  Used with the example above, C<@libfiles> (or C<@$libfiles>) would
  contain two strings upon completion: C<"lib/srdlib"> and
  C<"lib/extlib">, in that order. It is also possible to specify that
  only integer or floating point numbers are acceptable values.
  
  Often it is useful to allow comma-separated lists of values as well as
  multiple occurrences of the options. This is easy using Perl's split()
  and join() operators:
  
      GetOptions ("library=s" => \@libfiles);
      @libfiles = split(/,/,join(',',@libfiles));
  
  Of course, it is important to choose the right separator string for
  each purpose.
  
  Warning: What follows is an experimental feature.
  
  Options can take multiple values at once, for example
  
      --coordinates 52.2 16.4 --rgbcolor 255 255 149
  
  This can be accomplished by adding a repeat specifier to the option
  specification. Repeat specifiers are very similar to the C<{...}>
  repeat specifiers that can be used with regular expression patterns.
  For example, the above command line would be handled as follows:
  
      GetOptions('coordinates=f{2}' => \@coor, 'rgbcolor=i{3}' => \@color);
  
  The destination for the option must be an array or array reference.
  
  It is also possible to specify the minimal and maximal number of
  arguments an option takes. C<foo=s{2,4}> indicates an option that
  takes at least two and at most 4 arguments. C<foo=s{,}> indicates one
  or more values; C<foo:s{,}> indicates zero or more option values.
  
  =head2 Options with hash values
  
  If the option destination is a reference to a hash, the option will
  take, as value, strings of the form I<key>C<=>I<value>. The value will
  be stored with the specified key in the hash.
  
      GetOptions ("define=s" => \%defines);
  
  Alternatively you can use:
  
      GetOptions ("define=s%" => \$defines);
  
  When used with command line options:
  
      --define os=linux --define vendor=redhat
  
  the hash C<%defines> (or C<%$defines>) will contain two keys, C<"os">
  with value C<"linux"> and C<"vendor"> with value C<"redhat">. It is
  also possible to specify that only integer or floating point numbers
  are acceptable values. The keys are always taken to be strings.
  
  =head2 User-defined subroutines to handle options
  
  Ultimate control over what should be done when (actually: each time)
  an option is encountered on the command line can be achieved by
  designating a reference to a subroutine (or an anonymous subroutine)
  as the option destination. When GetOptions() encounters the option, it
  will call the subroutine with two or three arguments. The first
  argument is the name of the option. (Actually, it is an object that
  stringifies to the name of the option.) For a scalar or array destination,
  the second argument is the value to be stored. For a hash destination,
  the second arguments is the key to the hash, and the third argument
  the value to be stored. It is up to the subroutine to store the value,
  or do whatever it thinks is appropriate.
  
  A trivial application of this mechanism is to implement options that
  are related to each other. For example:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose,
  	        'quiet'   => sub { $verbose = 0 });
  
  Here C<--verbose> and C<--quiet> control the same variable
  C<$verbose>, but with opposite values.
  
  If the subroutine needs to signal an error, it should call die() with
  the desired error message as its argument. GetOptions() will catch the
  die(), issue the error message, and record that an error result must
  be returned upon completion.
  
  If the text of the error message starts with an exclamation mark C<!>
  it is interpreted specially by GetOptions(). There is currently one
  special command implemented: C<die("!FINISH")> will cause GetOptions()
  to stop processing options, as if it encountered a double dash C<-->.
  
  In version 2.37 the first argument to the callback function was
  changed from string to object. This was done to make room for
  extensions and more detailed control. The object stringifies to the
  option name so this change should not introduce compatibility
  problems.
  
  =head2 Options with multiple names
  
  Often it is user friendly to supply alternate mnemonic names for
  options. For example C<--height> could be an alternate name for
  C<--length>. Alternate names can be included in the option
  specification, separated by vertical bar C<|> characters. To implement
  the above example:
  
      GetOptions ('length|height=f' => \$length);
  
  The first name is called the I<primary> name, the other names are
  called I<aliases>. When using a hash to store options, the key will
  always be the primary name.
  
  Multiple alternate names are possible.
  
  =head2 Case and abbreviations
  
  Without additional configuration, GetOptions() will ignore the case of
  option names, and allow the options to be abbreviated to uniqueness.
  
      GetOptions ('length|height=f' => \$length, "head" => \$head);
  
  This call will allow C<--l> and C<--L> for the length option, but
  requires a least C<--hea> and C<--hei> for the head and height options.
  
  =head2 Summary of Option Specifications
  
  Each option specifier consists of two parts: the name specification
  and the argument specification.
  
  The name specification contains the name of the option, optionally
  followed by a list of alternative names separated by vertical bar
  characters.
  
      length	      option name is "length"
      length|size|l     name is "length", aliases are "size" and "l"
  
  The argument specification is optional. If omitted, the option is
  considered boolean, a value of 1 will be assigned when the option is
  used on the command line.
  
  The argument specification can be
  
  =over 4
  
  =item !
  
  The option does not take an argument and may be negated by prefixing
  it with "no" or "no-". E.g. C<"foo!"> will allow C<--foo> (a value of
  1 will be assigned) as well as C<--nofoo> and C<--no-foo> (a value of
  0 will be assigned). If the option has aliases, this applies to the
  aliases as well.
  
  Using negation on a single letter option when bundling is in effect is
  pointless and will result in a warning.
  
  =item +
  
  The option does not take an argument and will be incremented by 1
  every time it appears on the command line. E.g. C<"more+">, when used
  with C<--more --more --more>, will increment the value three times,
  resulting in a value of 3 (provided it was 0 or undefined at first).
  
  The C<+> specifier is ignored if the option destination is not a scalar.
  
  =item = I<type> [ I<desttype> ] [ I<repeat> ]
  
  The option requires an argument of the given type. Supported types
  are:
  
  =over 4
  
  =item s
  
  String. An arbitrary sequence of characters. It is valid for the
  argument to start with C<-> or C<-->.
  
  =item i
  
  Integer. An optional leading plus or minus sign, followed by a
  sequence of digits.
  
  =item o
  
  Extended integer, Perl style. This can be either an optional leading
  plus or minus sign, followed by a sequence of digits, or an octal
  string (a zero, optionally followed by '0', '1', .. '7'), or a
  hexadecimal string (C<0x> followed by '0' .. '9', 'a' .. 'f', case
  insensitive), or a binary string (C<0b> followed by a series of '0'
  and '1').
  
  =item f
  
  Real number. For example C<3.14>, C<-6.23E24> and so on.
  
  =back
  
  The I<desttype> can be C<@> or C<%> to specify that the option is
  list or a hash valued. This is only needed when the destination for
  the option value is not otherwise specified. It should be omitted when
  not needed.
  
  The I<repeat> specifies the number of values this option takes per
  occurrence on the command line. It has the format C<{> [ I<min> ] [ C<,> [ I<max> ] ] C<}>.
  
  I<min> denotes the minimal number of arguments. It defaults to 1 for
  options with C<=> and to 0 for options with C<:>, see below. Note that
  I<min> overrules the C<=> / C<:> semantics.
  
  I<max> denotes the maximum number of arguments. It must be at least
  I<min>. If I<max> is omitted, I<but the comma is not>, there is no
  upper bound to the number of argument values taken.
  
  =item : I<type> [ I<desttype> ]
  
  Like C<=>, but designates the argument as optional.
  If omitted, an empty string will be assigned to string values options,
  and the value zero to numeric options.
  
  Note that if a string argument starts with C<-> or C<-->, it will be
  considered an option on itself.
  
  =item : I<number> [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the I<number> will be assigned.
  
  =item : + [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the current value for the
  option will be incremented.
  
  =back
  
  =head1 Advanced Possibilities
  
  =head2 Object oriented interface
  
  Getopt::Long can be used in an object oriented way as well:
  
      use Getopt::Long;
      $p = new Getopt::Long::Parser;
      $p->configure(...configuration options...);
      if ($p->getoptions(...options descriptions...)) ...
  
  Configuration options can be passed to the constructor:
  
      $p = new Getopt::Long::Parser
               config => [...configuration options...];
  
  =head2 Thread Safety
  
  Getopt::Long is thread safe when using ithreads as of Perl 5.8.  It is
  I<not> thread safe when using the older (experimental and now
  obsolete) threads implementation that was added to Perl 5.005.
  
  =head2 Documentation and help texts
  
  Getopt::Long encourages the use of Pod::Usage to produce help
  messages. For example:
  
      use Getopt::Long;
      use Pod::Usage;
  
      my $man = 0;
      my $help = 0;
  
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-exitstatus => 0, -verbose => 2) if $man;
  
      __END__
  
      =head1 NAME
  
      sample - Using Getopt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 8
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  See L<Pod::Usage> for details.
  
  =head2 Parsing options from an arbitrary array
  
  By default, GetOptions parses the options that are present in the
  global array C<@ARGV>. A special entry C<GetOptionsFromArray> can be
  used to parse options from an arbitrary array.
  
      use Getopt::Long qw(GetOptionsFromArray);
      $ret = GetOptionsFromArray(\@myopts, ...);
  
  When used like this, the global C<@ARGV> is not touched at all.
  
  The following two calls behave identically:
  
      $ret = GetOptions( ... );
      $ret = GetOptionsFromArray(\@ARGV, ... );
  
  =head2 Parsing options from an arbitrary string
  
  A special entry C<GetOptionsFromString> can be used to parse options
  from an arbitrary string.
  
      use Getopt::Long qw(GetOptionsFromString);
      $ret = GetOptionsFromString($string, ...);
  
  The contents of the string are split into arguments using a call to
  C<Text::ParseWords::shellwords>. As with C<GetOptionsFromArray>, the
  global C<@ARGV> is not touched.
  
  It is possible that, upon completion, not all arguments in the string
  have been processed. C<GetOptionsFromString> will, when called in list
  context, return both the return status and an array reference to any
  remaining arguments:
  
      ($ret, $args) = GetOptionsFromString($string, ... );
  
  If any arguments remain, and C<GetOptionsFromString> was not called in
  list context, a message will be given and C<GetOptionsFromString> will
  return failure.
  
  =head2 Storing options values in a hash
  
  Sometimes, for example when there are a lot of options, having a
  separate variable for each of them can be cumbersome. GetOptions()
  supports, as an alternative mechanism, storing options values in a
  hash.
  
  To obtain this, a reference to a hash must be passed I<as the first
  argument> to GetOptions(). For each option that is specified on the
  command line, the option value will be stored in the hash with the
  option name as key. Options that are not actually used on the command
  line will not be put in the hash, on other words,
  C<exists($h{option})> (or defined()) can be used to test if an option
  was used. The drawback is that warnings will be issued if the program
  runs under C<use strict> and uses C<$h{option}> without testing with
  exists() or defined() first.
  
      my %h = ();
      GetOptions (\%h, 'length=i');	# will store in $h{length}
  
  For options that take list or hash values, it is necessary to indicate
  this by appending an C<@> or C<%> sign after the type:
  
      GetOptions (\%h, 'colours=s@');	# will push to @{$h{colours}}
  
  To make things more complicated, the hash may contain references to
  the actual destinations, for example:
  
      my $len = 0;
      my %h = ('length' => \$len);
      GetOptions (\%h, 'length=i');	# will store in $len
  
  This example is fully equivalent with:
  
      my $len = 0;
      GetOptions ('length=i' => \$len);	# will store in $len
  
  Any mixture is possible. For example, the most frequently used options
  could be stored in variables while all other options get stored in the
  hash:
  
      my $verbose = 0;			# frequently referred
      my $debug = 0;			# frequently referred
      my %h = ('verbose' => \$verbose, 'debug' => \$debug);
      GetOptions (\%h, 'verbose', 'debug', 'filter', 'size=i');
      if ( $verbose ) { ... }
      if ( exists $h{filter} ) { ... option 'filter' was specified ... }
  
  =head2 Bundling
  
  With bundling it is possible to set several single-character options
  at once. For example if C<a>, C<v> and C<x> are all valid options,
  
      -vax
  
  would set all three.
  
  Getopt::Long supports two levels of bundling. To enable bundling, a
  call to Getopt::Long::Configure is required.
  
  The first level of bundling can be enabled with:
  
      Getopt::Long::Configure ("bundling");
  
  Configured this way, single-character options can be bundled but long
  options B<must> always start with a double dash C<--> to avoid
  ambiguity. For example, when C<vax>, C<a>, C<v> and C<x> are all valid
  options,
  
      -vax
  
  would set C<a>, C<v> and C<x>, but
  
      --vax
  
  would set C<vax>.
  
  The second level of bundling lifts this restriction. It can be enabled
  with:
  
      Getopt::Long::Configure ("bundling_override");
  
  Now, C<-vax> would set the option C<vax>.
  
  When any level of bundling is enabled, option values may be inserted
  in the bundle. For example:
  
      -h24w80
  
  is equivalent to
  
      -h 24 -w 80
  
  When configured for bundling, single-character options are matched
  case sensitive while long options are matched case insensitive. To
  have the single-character options matched case insensitive as well,
  use:
  
      Getopt::Long::Configure ("bundling", "ignorecase_always");
  
  It goes without saying that bundling can be quite confusing.
  
  =head2 The lonesome dash
  
  Normally, a lone dash C<-> on the command line will not be considered
  an option. Option processing will terminate (unless "permute" is
  configured) and the dash will be left in C<@ARGV>.
  
  It is possible to get special treatment for a lone dash. This can be
  achieved by adding an option specification with an empty name, for
  example:
  
      GetOptions ('' => \$stdio);
  
  A lone dash on the command line will now be a legal option, and using
  it will set variable C<$stdio>.
  
  =head2 Argument callback
  
  A special option 'name' C<< <> >> can be used to designate a subroutine
  to handle non-option arguments. When GetOptions() encounters an
  argument that does not look like an option, it will immediately call this
  subroutine and passes it one parameter: the argument name. Well, actually
  it is an object that stringifies to the argument name.
  
  For example:
  
      my $width = 80;
      sub process { ... }
      GetOptions ('width=i' => \$width, '<>' => \&process);
  
  When applied to the following command line:
  
      arg1 --width=72 arg2 --width=60 arg3
  
  This will call
  C<process("arg1")> while C<$width> is C<80>,
  C<process("arg2")> while C<$width> is C<72>, and
  C<process("arg3")> while C<$width> is C<60>.
  
  This feature requires configuration option B<permute>, see section
  L<Configuring Getopt::Long>.
  
  =head1 Configuring Getopt::Long
  
  Getopt::Long can be configured by calling subroutine
  Getopt::Long::Configure(). This subroutine takes a list of quoted
  strings, each specifying a configuration option to be enabled, e.g.
  C<ignore_case>, or disabled, e.g. C<no_ignore_case>. Case does not
  matter. Multiple calls to Configure() are possible.
  
  Alternatively, as of version 2.24, the configuration options may be
  passed together with the C<use> statement:
  
      use Getopt::Long qw(:config no_ignore_case bundling);
  
  The following options are available:
  
  =over 12
  
  =item default
  
  This option causes all configuration options to be reset to their
  default values.
  
  =item posix_default
  
  This option causes all configuration options to be reset to their
  default values as if the environment variable POSIXLY_CORRECT had
  been set.
  
  =item auto_abbrev
  
  Allow option names to be abbreviated to uniqueness.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is disabled.
  
  =item getopt_compat
  
  Allow C<+> to start options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<getopt_compat> is disabled.
  
  =item gnu_compat
  
  C<gnu_compat> controls whether C<--opt=> is allowed, and what it should
  do. Without C<gnu_compat>, C<--opt=> gives an error. With C<gnu_compat>,
  C<--opt=> will give option C<opt> and empty value.
  This is the way GNU getopt_long() does it.
  
  =item gnu_getopt
  
  This is a short way of setting C<gnu_compat> C<bundling> C<permute>
  C<no_getopt_compat>. With C<gnu_getopt>, command line handling should be
  fully compatible with GNU getopt_long().
  
  =item require_order
  
  Whether command line arguments are allowed to be mixed with options.
  Default is disabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<require_order> is enabled.
  
  See also C<permute>, which is the opposite of C<require_order>.
  
  =item permute
  
  Whether command line arguments are allowed to be mixed with options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<permute> is disabled.
  Note that C<permute> is the opposite of C<require_order>.
  
  If C<permute> is enabled, this means that
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo --bar arg1 arg2 arg3
  
  If an argument callback routine is specified, C<@ARGV> will always be
  empty upon successful return of GetOptions() since all options have been
  processed. The only exception is when C<--> is used:
  
      --foo arg1 --bar arg2 -- arg3
  
  This will call the callback routine for arg1 and arg2, and then
  terminate GetOptions() leaving C<"arg3"> in C<@ARGV>.
  
  If C<require_order> is enabled, options processing
  terminates when the first non-option is encountered.
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo -- arg1 --bar arg2 arg3
  
  If C<pass_through> is also enabled, options processing will terminate
  at the first unrecognized option, or non-option, whichever comes
  first.
  
  =item bundling (default: disabled)
  
  Enabling this option will allow single-character options to be
  bundled. To distinguish bundles from long option names, long options
  I<must> be introduced with C<--> and bundles with C<->.
  
  Note that, if you have options C<a>, C<l> and C<all>, and
  auto_abbrev enabled, possible arguments and option settings are:
  
      using argument               sets option(s)
      ------------------------------------------
      -a, --a                      a
      -l, --l                      l
      -al, -la, -ala, -all,...     a, l
      --al, --all                  all
  
  The surprising part is that C<--a> sets option C<a> (due to auto
  completion), not C<all>.
  
  Note: disabling C<bundling> also disables C<bundling_override>.
  
  =item bundling_override (default: disabled)
  
  If C<bundling_override> is enabled, bundling is enabled as with
  C<bundling> but now long option names override option bundles.
  
  Note: disabling C<bundling_override> also disables C<bundling>.
  
  B<Note:> Using option bundling can easily lead to unexpected results,
  especially when mixing long options and bundles. Caveat emptor.
  
  =item ignore_case  (default: enabled)
  
  If enabled, case is ignored when matching long option names. If,
  however, bundling is enabled as well, single character options will be
  treated case-sensitive.
  
  With C<ignore_case>, option specifications for options that only
  differ in case, e.g., C<"foo"> and C<"Foo">, will be flagged as
  duplicates.
  
  Note: disabling C<ignore_case> also disables C<ignore_case_always>.
  
  =item ignore_case_always (default: disabled)
  
  When bundling is in effect, case is ignored on single-character
  options also.
  
  Note: disabling C<ignore_case_always> also disables C<ignore_case>.
  
  =item auto_version (default:disabled)
  
  Automatically provide support for the B<--version> option if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a standard version message that includes the
  program name, its version (if $main::VERSION is defined), and the
  versions of Getopt::Long and Perl. The message will be written to
  standard output and processing will terminate.
  
  C<auto_version> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item auto_help (default:disabled)
  
  Automatically provide support for the B<--help> and B<-?> options if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a help message using module L<Pod::Usage>. The
  message, derived from the SYNOPSIS POD section, will be written to
  standard output and processing will terminate.
  
  C<auto_help> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item pass_through (default: disabled)
  
  Options that are unknown, ambiguous or supplied with an invalid option
  value are passed through in C<@ARGV> instead of being flagged as
  errors. This makes it possible to write wrapper scripts that process
  only part of the user supplied command line arguments, and pass the
  remaining options to some other program.
  
  If C<require_order> is enabled, options processing will terminate at
  the first unrecognized option, or non-option, whichever comes first.
  However, if C<permute> is enabled instead, results can become confusing.
  
  Note that the options terminator (default C<-->), if present, will
  also be passed through in C<@ARGV>.
  
  =item prefix
  
  The string that starts options. If a constant string is not
  sufficient, see C<prefix_pattern>.
  
  =item prefix_pattern
  
  A Perl pattern that identifies the strings that introduce options.
  Default is C<--|-|\+> unless environment variable
  POSIXLY_CORRECT has been set, in which case it is C<--|->.
  
  =item long_prefix_pattern
  
  A Perl pattern that allows the disambiguation of long and short
  prefixes. Default is C<-->.
  
  Typically you only need to set this if you are using nonstandard
  prefixes and want some or all of them to have the same semantics as
  '--' does under normal circumstances.
  
  For example, setting prefix_pattern to C<--|-|\+|\/> and
  long_prefix_pattern to C<--|\/> would add Win32 style argument
  handling.
  
  =item debug (default: disabled)
  
  Enable debugging output.
  
  =back
  
  =head1 Exportable Methods
  
  =over
  
  =item VersionMessage
  
  This subroutine provides a standard version message. Its argument can be:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the standard message.
  
  =item *
  
  A numeric value corresponding to the desired exit status.
  
  =item *
  
  A reference to a hash.
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message>
  
  =item C<-msg>
  
  The text of a message to print immediately prior to printing the
  program's usage message.
  
  =item C<-exitval>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string "NOEXIT" to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-output>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =back
  
  You cannot tie this routine directly to an option, e.g.:
  
      GetOptions("version" => \&VersionMessage);
  
  Use this instead:
  
      GetOptions("version" => sub { VersionMessage() });
  
  =item HelpMessage
  
  This subroutine produces a standard help message, derived from the
  program's POD section SYNOPSIS using L<Pod::Usage>. It takes the same
  arguments as VersionMessage(). In particular, you cannot tie it
  directly to an option, e.g.:
  
      GetOptions("help" => \&HelpMessage);
  
  Use this instead:
  
      GetOptions("help" => sub { HelpMessage() });
  
  =back
  
  =head1 Return values and Errors
  
  Configuration errors and errors in the option definitions are
  signalled using die() and will terminate the calling program unless
  the call to Getopt::Long::GetOptions() was embedded in C<eval { ...
  }>, or die() was trapped using C<$SIG{__DIE__}>.
  
  GetOptions returns true to indicate success.
  It returns false when the function detected one or more errors during
  option parsing. These errors are signalled using warn() and can be
  trapped with C<$SIG{__WARN__}>.
  
  =head1 Legacy
  
  The earliest development of C<newgetopt.pl> started in 1990, with Perl
  version 4. As a result, its development, and the development of
  Getopt::Long, has gone through several stages. Since backward
  compatibility has always been extremely important, the current version
  of Getopt::Long still supports a lot of constructs that nowadays are
  no longer necessary or otherwise unwanted. This section describes
  briefly some of these 'features'.
  
  =head2 Default destinations
  
  When no destination is specified for an option, GetOptions will store
  the resultant value in a global variable named C<opt_>I<XXX>, where
  I<XXX> is the primary name of this option. When a progam executes
  under C<use strict> (recommended), these variables must be
  pre-declared with our() or C<use vars>.
  
      our $opt_length = 0;
      GetOptions ('length=i');	# will store in $opt_length
  
  To yield a usable Perl variable, characters that are not part of the
  syntax for variables are translated to underscores. For example,
  C<--fpp-struct-return> will set the variable
  C<$opt_fpp_struct_return>. Note that this variable resides in the
  namespace of the calling program, not necessarily C<main>. For
  example:
  
      GetOptions ("size=i", "sizes=i@");
  
  with command line "-size 10 -sizes 24 -sizes 48" will perform the
  equivalent of the assignments
  
      $opt_size = 10;
      @opt_sizes = (24, 48);
  
  =head2 Alternative option starters
  
  A string of alternative option starter characters may be passed as the
  first argument (or the first argument after a leading hash reference
  argument).
  
      my $len = 0;
      GetOptions ('/', 'length=i' => $len);
  
  Now the command line may look like:
  
      /length 24 -- arg
  
  Note that to terminate options processing still requires a double dash
  C<-->.
  
  GetOptions() will not interpret a leading C<< "<>" >> as option starters
  if the next argument is a reference. To force C<< "<" >> and C<< ">" >> as
  option starters, use C<< "><" >>. Confusing? Well, B<using a starter
  argument is strongly deprecated> anyway.
  
  =head2 Configuration variables
  
  Previous versions of Getopt::Long used variables for the purpose of
  configuring. Although manipulating these variables still work, it is
  strongly encouraged to use the C<Configure> routine that was introduced
  in version 2.17. Besides, it is much easier.
  
  =head1 Tips and Techniques
  
  =head2 Pushing multiple values in a hash option
  
  Sometimes you want to combine the best of hashes and arrays. For
  example, the command line:
  
    --list add=first --list add=second --list add=third
  
  where each successive 'list add' option will push the value of add
  into array ref $list->{'add'}. The result would be like
  
    $list->{add} = [qw(first second third)];
  
  This can be accomplished with a destination routine:
  
    GetOptions('list=s%' =>
                 sub { push(@{$list{$_[1]}}, $_[2]) });
  
  =head1 Troubleshooting
  
  =head2 GetOptions does not return a false result when an option is not supplied
  
  That's why they're called 'options'.
  
  =head2 GetOptions does not split the command line correctly
  
  The command line is not split by GetOptions, but by the command line
  interpreter (CLI). On Unix, this is the shell. On Windows, it is
  COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.
  
  It is important to know that these CLIs may behave different when the
  command line contains special characters, in particular quotes or
  backslashes. For example, with Unix shells you can use single quotes
  (C<'>) and double quotes (C<">) to group words together. The following
  alternatives are equivalent on Unix:
  
      "two words"
      'two words'
      two\ words
  
  In case of doubt, insert the following statement in front of your Perl
  program:
  
      print STDERR (join("|",@ARGV),"\n");
  
  to verify how your CLI passes the arguments to the program.
  
  =head2 Undefined subroutine &main::GetOptions called
  
  Are you running Windows, and did you write
  
      use GetOpt::Long;
  
  (note the capital 'O')?
  
  =head2 How do I put a "-?" option into a Getopt::Long?
  
  You can only obtain this using an alias, and Getopt::Long of at least
  version 2.13.
  
      use Getopt::Long;
      GetOptions ("help|?");    # -help and -? will both set $opt_help
  
  =head1 AUTHOR
  
  Johan Vromans <jvromans@squirrel.nl>
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  This program is Copyright 1990,2009 by Johan Vromans.
  This program is free software; you can redistribute it and/or
  modify it under the terms of the Perl Artistic License or the
  GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any
  later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  If you do not have a copy of the GNU General Public License write to
  the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
  MA 02139, USA.
  
  =cut
  
GETOPT_LONG

$fatpacked{"Pod/Checker.pm"} = <<'POD_CHECKER';
  #############################################################################
  # Pod/Checker.pm -- check pod documents for syntax errors
  #
  # Copyright (C) 1994-2000 by Bradford Appleton. All rights reserved.
  # This file is part of "PodParser". PodParser is free software;
  # you can redistribute it and/or modify it under the same terms
  # as Perl itself.
  #############################################################################
  
  package Pod::Checker;
  use strict;
  
  use vars qw($VERSION @ISA @EXPORT %VALID_COMMANDS %VALID_SEQUENCES);
  $VERSION = '1.51';  ## Current version of this package
  require  5.005;    ## requires this Perl version or later
  
  use Pod::ParseUtils; ## for hyperlinks and lists
  
  =head1 NAME
  
  Pod::Checker, podchecker() - check pod documents for syntax errors
  
  =head1 SYNOPSIS
  
    use Pod::Checker;
  
    $syntax_okay = podchecker($filepath, $outputpath, %options);
  
    my $checker = new Pod::Checker %options;
    $checker->parse_from_file($filepath, \*STDERR);
  
  =head1 OPTIONS/ARGUMENTS
  
  C<$filepath> is the input POD to read and C<$outputpath> is
  where to write POD syntax error messages. Either argument may be a scalar
  indicating a file-path, or else a reference to an open filehandle.
  If unspecified, the input-file it defaults to C<\*STDIN>, and
  the output-file defaults to C<\*STDERR>.
  
  =head2 podchecker()
  
  This function can take a hash of options:
  
  =over 4
  
  =item B<-warnings> =E<gt> I<val>
  
  Turn warnings on/off. I<val> is usually 1 for on, but higher values
  trigger additional warnings. See L<"Warnings">.
  
  =back
  
  =head1 DESCRIPTION
  
  B<podchecker> will perform syntax checking of Perl5 POD format documentation.
  
  Curious/ambitious users are welcome to propose additional features they wish
  to see in B<Pod::Checker> and B<podchecker> and verify that the checks are
  consistent with L<perlpod>.
  
  The following checks are currently performed:
  
  =over 4
  
  =item *
  
  Unknown '=xxxx' commands, unknown 'XE<lt>...E<gt>' interior-sequences,
  and unterminated interior sequences.
  
  =item *
  
  Check for proper balancing of C<=begin> and C<=end>. The contents of such
  a block are generally ignored, i.e. no syntax checks are performed.
  
  =item *
  
  Check for proper nesting and balancing of C<=over>, C<=item> and C<=back>.
  
  =item *
  
  Check for same nested interior-sequences (e.g.
  C<LE<lt>...LE<lt>...E<gt>...E<gt>>).
  
  =item *
  
  Check for malformed or non-existing entities C<EE<lt>...E<gt>>.
  
  =item *
  
  Check for correct syntax of hyperlinks C<LE<lt>...E<gt>>. See L<perlpod>
  for details.
  
  =item *
  
  Check for unresolved document-internal links. This check may also reveal
  misspelled links that seem to be internal links but should be links
  to something else.
  
  =back
  
  =head1 DIAGNOSTICS
  
  =head2 Errors
  
  =over 4
  
  =item * empty =headn
  
  A heading (C<=head1> or C<=head2>) without any text? That ain't no
  heading!
  
  =item * =over on line I<N> without closing =back
  
  The C<=over> command does not have a corresponding C<=back> before the
  next heading (C<=head1> or C<=head2>) or the end of the file.
  
  =item * =item without previous =over
  
  =item * =back without previous =over
  
  An C<=item> or C<=back> command has been found outside a
  C<=over>/C<=back> block.
  
  =item * No argument for =begin
  
  A C<=begin> command was found that is not followed by the formatter
  specification.
  
  =item * =end without =begin
  
  A standalone C<=end> command was found.
  
  =item * Nested =begin's
  
  There were at least two consecutive C<=begin> commands without
  the corresponding C<=end>. Only one C<=begin> may be active at
  a time.
  
  =item * =for without formatter specification
  
  There is no specification of the formatter after the C<=for> command.
  
  =item * Apparent command =foo not preceded by blank line
  
  A command which has ended up in the middle of a paragraph or other command,
  such as
  
    =item one
    =item two <-- bad
  
  =item * unresolved internal link I<NAME>
  
  The given link to I<NAME> does not have a matching node in the current
  POD. This also happened when a single word node name is not enclosed in
  C<"">.
  
  =item * Unknown command "I<CMD>"
  
  An invalid POD command has been found. Valid are C<=head1>, C<=head2>,
  C<=head3>, C<=head4>, C<=over>, C<=item>, C<=back>, C<=begin>, C<=end>,
  C<=for>, C<=pod>, C<=cut>
  
  =item * Unknown interior-sequence "I<SEQ>"
  
  An invalid markup command has been encountered. Valid are:
  C<BE<lt>E<gt>>, C<CE<lt>E<gt>>, C<EE<lt>E<gt>>, C<FE<lt>E<gt>>,
  C<IE<lt>E<gt>>, C<LE<lt>E<gt>>, C<SE<lt>E<gt>>, C<XE<lt>E<gt>>,
  C<ZE<lt>E<gt>>
  
  =item * nested commands I<CMD>E<lt>...I<CMD>E<lt>...E<gt>...E<gt>
  
  Two nested identical markup commands have been found. Generally this
  does not make sense.
  
  =item * garbled entity I<STRING>
  
  The I<STRING> found cannot be interpreted as a character entity.
  
  =item * Entity number out of range
  
  An entity specified by number (dec, hex, oct) is out of range (1-255).
  
  =item * malformed link LE<lt>E<gt>
  
  The link found cannot be parsed because it does not conform to the
  syntax described in L<perlpod>.
  
  =item * nonempty ZE<lt>E<gt>
  
  The C<ZE<lt>E<gt>> sequence is supposed to be empty.
  
  =item * empty XE<lt>E<gt>
  
  The index entry specified contains nothing but whitespace.
  
  =item * Spurious text after =pod / =cut
  
  The commands C<=pod> and C<=cut> do not take any arguments.
  
  =item * Spurious =cut command
  
  A C<=cut> command was found without a preceding POD paragraph.
  
  =item * Spurious =pod command
  
  A C<=pod> command was found after a preceding POD paragraph.
  
  =item * Spurious character(s) after =back
  
  The C<=back> command does not take any arguments.
  
  =back
  
  =head2 Warnings
  
  These may not necessarily cause trouble, but indicate mediocre style.
  
  =over 4
  
  =item * multiple occurrence of link target I<name>
  
  The POD file has some C<=item> and/or C<=head> commands that have
  the same text. Potential hyperlinks to such a text cannot be unique then.
  This warning is printed only with warning level greater than one.
  
  =item * line containing nothing but whitespace in paragraph
  
  There is some whitespace on a seemingly empty line. POD is very sensitive
  to such things, so this is flagged. B<vi> users switch on the B<list>
  option to avoid this problem.
  
  =begin _disabled_
  
  =item * file does not start with =head
  
  The file starts with a different POD directive than head.
  This is most probably something you do not want.
  
  =end _disabled_
  
  =item * previous =item has no contents
  
  There is a list C<=item> right above the flagged line that has no
  text contents. You probably want to delete empty items.
  
  =item * preceding non-item paragraph(s)
  
  A list introduced by C<=over> starts with a text or verbatim paragraph,
  but continues with C<=item>s. Move the non-item paragraph out of the
  C<=over>/C<=back> block.
  
  =item * =item type mismatch (I<one> vs. I<two>)
  
  A list started with e.g. a bullet-like C<=item> and continued with a
  numbered one. This is obviously inconsistent. For most translators the
  type of the I<first> C<=item> determines the type of the list.
  
  =item * I<N> unescaped C<E<lt>E<gt>> in paragraph
  
  Angle brackets not written as C<E<lt>ltE<gt>> and C<E<lt>gtE<gt>>
  can potentially cause errors as they could be misinterpreted as
  markup commands. This is only printed when the -warnings level is
  greater than 1.
  
  =item * Unknown entity
  
  A character entity was found that does not belong to the standard
  ISO set or the POD specials C<verbar> and C<sol>.
  
  =item * No items in =over
  
  The list opened with C<=over> does not contain any items.
  
  =item * No argument for =item
  
  C<=item> without any parameters is deprecated. It should either be followed
  by C<*> to indicate an unordered list, by a number (optionally followed
  by a dot) to indicate an ordered (numbered) list or simple text for a
  definition list.
  
  =item * empty section in previous paragraph
  
  The previous section (introduced by a C<=head> command) does not contain
  any text. This usually indicates that something is missing. Note: A
  C<=head1> followed immediately by C<=head2> does not trigger this warning.
  
  =item * Verbatim paragraph in NAME section
  
  The NAME section (C<=head1 NAME>) should consist of a single paragraph
  with the script/module name, followed by a dash `-' and a very short
  description of what the thing is good for.
  
  =item * =headI<n> without preceding higher level
  
  For example if there is a C<=head2> in the POD file prior to a
  C<=head1>.
  
  =back
  
  =head2 Hyperlinks
  
  There are some warnings with respect to malformed hyperlinks:
  
  =over 4
  
  =item * ignoring leading/trailing whitespace in link
  
  There is whitespace at the beginning or the end of the contents of
  LE<lt>...E<gt>.
  
  =item * (section) in '$page' deprecated
  
  There is a section detected in the page name of LE<lt>...E<gt>, e.g.
  C<LE<lt>passwd(2)E<gt>>. POD hyperlinks may point to POD documents only.
  Please write C<CE<lt>passwd(2)E<gt>> instead. Some formatters are able
  to expand this to appropriate code. For links to (builtin) functions,
  please say C<LE<lt>perlfunc/mkdirE<gt>>, without ().
  
  =item * alternative text/node '%s' contains non-escaped | or /
  
  The characters C<|> and C</> are special in the LE<lt>...E<gt> context.
  Although the hyperlink parser does its best to determine which "/" is
  text and which is a delimiter in case of doubt, one ought to escape
  these literal characters like this:
  
    /     E<sol>
    |     E<verbar>
  
  =back
  
  =head1 RETURN VALUE
  
  B<podchecker> returns the number of POD syntax errors found or -1 if
  there were no POD commands at all found in the file.
  
  =head1 EXAMPLES
  
  See L</SYNOPSIS>
  
  =head1 INTERFACE
  
  While checking, this module collects document properties, e.g. the nodes
  for hyperlinks (C<=headX>, C<=item>) and index entries (C<XE<lt>E<gt>>).
  POD translators can use this feature to syntax-check and get the nodes in
  a first pass before actually starting to convert. This is expensive in terms
  of execution time, but allows for very robust conversions.
  
  Since PodParser-1.24 the B<Pod::Checker> module uses only the B<poderror>
  method to print errors and warnings. The summary output (e.g.
  "Pod syntax OK") has been dropped from the module and has been included in
  B<podchecker> (the script). This allows users of B<Pod::Checker> to
  control completely the output behavior. Users of B<podchecker> (the script)
  get the well-known behavior.
  
  =cut
  
  #############################################################################
  
  #use diagnostics;
  use Carp qw(croak);
  use Exporter;
  use Pod::Parser;
  
  @ISA = qw(Pod::Parser);
  @EXPORT = qw(&podchecker);
  
  my %VALID_COMMANDS = (
      'pod'    =>  1,
      'cut'    =>  1,
      'head1'  =>  1,
      'head2'  =>  1,
      'head3'  =>  1,
      'head4'  =>  1,
      'over'   =>  1,
      'back'   =>  1,
      'item'   =>  1,
      'for'    =>  1,
      'begin'  =>  1,
      'end'    =>  1,
      'encoding' =>  1,
  );
  
  my %VALID_SEQUENCES = (
      'I'  =>  1,
      'B'  =>  1,
      'S'  =>  1,
      'C'  =>  1,
      'L'  =>  1,
      'F'  =>  1,
      'X'  =>  1,
      'Z'  =>  1,
      'E'  =>  1,
  );
  
  # stolen from HTML::Entities
  my %ENTITIES = (
   # Some normal chars that have special meaning in SGML context
   amp    => '&',  # ampersand
  'gt'    => '>',  # greater than
  'lt'    => '<',  # less than
   quot   => '"',  # double quote
  
   # PUBLIC ISO 8879-1986//ENTITIES Added Latin 1//EN//HTML
   AElig  => '',  # capital AE diphthong (ligature)
   Aacute => '',  # capital A, acute accent
   Acirc  => '',  # capital A, circumflex accent
   Agrave => '',  # capital A, grave accent
   Aring  => '',  # capital A, ring
   Atilde => '',  # capital A, tilde
   Auml   => '',  # capital A, dieresis or umlaut mark
   Ccedil => '',  # capital C, cedilla
   ETH    => '',  # capital Eth, Icelandic
   Eacute => '',  # capital E, acute accent
   Ecirc  => '',  # capital E, circumflex accent
   Egrave => '',  # capital E, grave accent
   Euml   => '',  # capital E, dieresis or umlaut mark
   Iacute => '',  # capital I, acute accent
   Icirc  => '',  # capital I, circumflex accent
   Igrave => '',  # capital I, grave accent
   Iuml   => '',  # capital I, dieresis or umlaut mark
   Ntilde => '',  # capital N, tilde
   Oacute => '',  # capital O, acute accent
   Ocirc  => '',  # capital O, circumflex accent
   Ograve => '',  # capital O, grave accent
   Oslash => '',  # capital O, slash
   Otilde => '',  # capital O, tilde
   Ouml   => '',  # capital O, dieresis or umlaut mark
   THORN  => '',  # capital THORN, Icelandic
   Uacute => '',  # capital U, acute accent
   Ucirc  => '',  # capital U, circumflex accent
   Ugrave => '',  # capital U, grave accent
   Uuml   => '',  # capital U, dieresis or umlaut mark
   Yacute => '',  # capital Y, acute accent
   aacute => '',  # small a, acute accent
   acirc  => '',  # small a, circumflex accent
   aelig  => '',  # small ae diphthong (ligature)
   agrave => '',  # small a, grave accent
   aring  => '',  # small a, ring
   atilde => '',  # small a, tilde
   auml   => '',  # small a, dieresis or umlaut mark
   ccedil => '',  # small c, cedilla
   eacute => '',  # small e, acute accent
   ecirc  => '',  # small e, circumflex accent
   egrave => '',  # small e, grave accent
   eth    => '',  # small eth, Icelandic
   euml   => '',  # small e, dieresis or umlaut mark
   iacute => '',  # small i, acute accent
   icirc  => '',  # small i, circumflex accent
   igrave => '',  # small i, grave accent
   iuml   => '',  # small i, dieresis or umlaut mark
   ntilde => '',  # small n, tilde
   oacute => '',  # small o, acute accent
   ocirc  => '',  # small o, circumflex accent
   ograve => '',  # small o, grave accent
   oslash => '',  # small o, slash
   otilde => '',  # small o, tilde
   ouml   => '',  # small o, dieresis or umlaut mark
   szlig  => '',  # small sharp s, German (sz ligature)
   thorn  => '',  # small thorn, Icelandic
   uacute => '',  # small u, acute accent
   ucirc  => '',  # small u, circumflex accent
   ugrave => '',  # small u, grave accent
   uuml   => '',  # small u, dieresis or umlaut mark
   yacute => '',  # small y, acute accent
   yuml   => '',  # small y, dieresis or umlaut mark
  
   # Some extra Latin 1 chars that are listed in the HTML3.2 draft (21-May-96)
   copy   => '',  # copyright sign
   reg    => '',  # registered sign
   nbsp   => "\240", # non breaking space
  
   # Additional ISO-8859/1 entities listed in rfc1866 (section 14)
   iexcl  => '',
   cent   => '',
   pound  => '',
   curren => '',
   yen    => '',
   brvbar => '',
   sect   => '',
   uml    => '',
   ordf   => '',
   laquo  => '',
  'not'   => '',    # not is a keyword in perl
   shy    => '',
   macr   => '',
   deg    => '',
   plusmn => '',
   sup1   => '',
   sup2   => '',
   sup3   => '',
   acute  => '',
   micro  => '',
   para   => '',
   middot => '',
   cedil  => '',
   ordm   => '',
   raquo  => '',
   frac14 => '',
   frac12 => '',
   frac34 => '',
   iquest => '',
  'times' => '',    # times is a keyword in perl
   divide => '',
  
  # some POD special entities
   verbar => '|',
   sol => '/'
  );
  
  ##---------------------------------------------------------------------------
  
  ##---------------------------------
  ## Function definitions begin here
  ##---------------------------------
  
  sub podchecker {
      my ($infile, $outfile, %options) = @_;
      local $_;
  
      ## Set defaults
      $infile  ||= \*STDIN;
      $outfile ||= \*STDERR;
  
      ## Now create a pod checker
      my $checker = new Pod::Checker(%options);
  
      ## Now check the pod document for errors
      $checker->parse_from_file($infile, $outfile);
  
      ## Return the number of errors found
      return $checker->num_errors();
  }
  
  ##---------------------------------------------------------------------------
  
  ##-------------------------------
  ## Method definitions begin here
  ##-------------------------------
  
  ##################################
  
  =over 4
  
  =item C<Pod::Checker-E<gt>new( %options )>
  
  Return a reference to a new Pod::Checker object that inherits from
  Pod::Parser and is used for calling the required methods later. The
  following options are recognized:
  
  C<-warnings =E<gt> num>
    Print warnings if C<num> is true. The higher the value of C<num>,
  the more warnings are printed. Currently there are only levels 1 and 2.
  
  C<-quiet =E<gt> num>
    If C<num> is true, do not print any errors/warnings. This is useful
  when Pod::Checker is used to munge POD code into plain text from within
  POD formatters.
  
  =cut
  
  ## sub new {
  ##     my $this = shift;
  ##     my $class = ref($this) || $this;
  ##     my %params = @_;
  ##     my $self = {%params};
  ##     bless $self, $class;
  ##     $self->initialize();
  ##     return $self;
  ## }
  
  sub initialize {
      my $self = shift;
      ## Initialize number of errors, and setup an error function to
      ## increment this number and then print to the designated output.
      $self->{_NUM_ERRORS} = 0;
      $self->{_NUM_WARNINGS} = 0;
      $self->{-quiet} ||= 0;
      # set the error handling subroutine
      $self->errorsub($self->{-quiet} ? sub { 1; } : 'poderror');
      $self->{_commands} = 0; # total number of POD commands encountered
      $self->{_list_stack} = []; # stack for nested lists
      $self->{_have_begin} = ''; # stores =begin
      $self->{_links} = []; # stack for internal hyperlinks
      $self->{_nodes} = []; # stack for =head/=item nodes
      $self->{_index} = []; # text in X<>
      # print warnings?
      $self->{-warnings} = 1 unless(defined $self->{-warnings});
      $self->{_current_head1} = ''; # the current =head1 block
      $self->parseopts(-process_cut_cmd => 1, -warnings => $self->{-warnings});
  }
  
  ##################################
  
  =item C<$checker-E<gt>poderror( @args )>
  
  =item C<$checker-E<gt>poderror( {%opts}, @args )>
  
  Internal method for printing errors and warnings. If no options are
  given, simply prints "@_". The following options are recognized and used
  to form the output:
  
    -msg
  
  A message to print prior to C<@args>.
  
    -line
  
  The line number the error occurred in.
  
    -file
  
  The file (name) the error occurred in.
  
    -severity
  
  The error level, should be 'WARNING' or 'ERROR'.
  
  =cut
  
  # Invoked as $self->poderror( @args ), or $self->poderror( {%opts}, @args )
  sub poderror {
      my $self = shift;
      my %opts = (ref $_[0]) ? %{shift()} : ();
  
      ## Retrieve options
      chomp( my $msg  = ($opts{-msg} || '')."@_" );
      my $line = (exists $opts{-line}) ? " at line $opts{-line}" : '';
      my $file = (exists $opts{-file}) ? " in file $opts{-file}" : '';
      unless (exists $opts{-severity}) {
         ## See if can find severity in message prefix
         $opts{-severity} = $1  if ( $msg =~ s/^\**\s*([A-Z]{3,}):\s+// );
      }
      my $severity = (exists $opts{-severity}) ? "*** $opts{-severity}: " : '';
  
      ## Increment error count and print message "
      ++($self->{_NUM_ERRORS})
          if(!%opts || ($opts{-severity} && $opts{-severity} eq 'ERROR'));
      ++($self->{_NUM_WARNINGS})
          if(!%opts || ($opts{-severity} && $opts{-severity} eq 'WARNING'));
      unless($self->{-quiet}) {
        my $out_fh = $self->output_handle() || \*STDERR;
        print $out_fh ($severity, $msg, $line, $file, "\n")
          if($self->{-warnings} || !%opts || $opts{-severity} ne 'WARNING');
      }
  }
  
  ##################################
  
  =item C<$checker-E<gt>num_errors()>
  
  Set (if argument specified) and retrieve the number of errors found.
  
  =cut
  
  sub num_errors {
     return (@_ > 1) ? ($_[0]->{_NUM_ERRORS} = $_[1]) : $_[0]->{_NUM_ERRORS};
  }
  
  ##################################
  
  =item C<$checker-E<gt>num_warnings()>
  
  Set (if argument specified) and retrieve the number of warnings found.
  
  =cut
  
  sub num_warnings {
     return (@_ > 1) ? ($_[0]->{_NUM_WARNINGS} = $_[1]) : $_[0]->{_NUM_WARNINGS};
  }
  
  ##################################
  
  =item C<$checker-E<gt>name()>
  
  Set (if argument specified) and retrieve the canonical name of POD as
  found in the C<=head1 NAME> section.
  
  =cut
  
  sub name {
      return (@_ > 1 && $_[1]) ?
          ($_[0]->{-name} = $_[1]) : $_[0]->{-name};
  }
  
  ##################################
  
  =item C<$checker-E<gt>node()>
  
  Add (if argument specified) and retrieve the nodes (as defined by C<=headX>
  and C<=item>) of the current POD. The nodes are returned in the order of
  their occurrence. They consist of plain text, each piece of whitespace is
  collapsed to a single blank.
  
  =cut
  
  sub node {
      my ($self,$text) = @_;
      if(defined $text) {
          $text =~ s/\s+$//s; # strip trailing whitespace
          $text =~ s/\s+/ /gs; # collapse whitespace
          # add node, order important!
          push(@{$self->{_nodes}}, $text);
          # keep also a uniqueness counter
          $self->{_unique_nodes}->{$text}++ if($text !~ /^\s*$/s);
          return $text;
      }
      @{$self->{_nodes}};
  }
  
  ##################################
  
  =item C<$checker-E<gt>idx()>
  
  Add (if argument specified) and retrieve the index entries (as defined by
  C<XE<lt>E<gt>>) of the current POD. They consist of plain text, each piece
  of whitespace is collapsed to a single blank.
  
  =cut
  
  # set/return index entries of current POD
  sub idx {
      my ($self,$text) = @_;
      if(defined $text) {
          $text =~ s/\s+$//s; # strip trailing whitespace
          $text =~ s/\s+/ /gs; # collapse whitespace
          # add node, order important!
          push(@{$self->{_index}}, $text);
          # keep also a uniqueness counter
          $self->{_unique_nodes}->{$text}++ if($text !~ /^\s*$/s);
          return $text;
      }
      @{$self->{_index}};
  }
  
  ##################################
  
  =item C<$checker-E<gt>hyperlink()>
  
  Add (if argument specified) and retrieve the hyperlinks (as defined by
  C<LE<lt>E<gt>>) of the current POD. They consist of a 2-item array: line
  number and C<Pod::Hyperlink> object.
  
  =back
  
  =cut
  
  # set/return hyperlinks of the current POD
  sub hyperlink {
      my $self = shift;
      if($_[0]) {
          push(@{$self->{_links}}, $_[0]);
          return $_[0];
      }
      @{$self->{_links}};
  }
  
  ## overrides for Pod::Parser
  
  sub end_pod {
      ## Do some final checks and
      ## print the number of errors found
      my $self   = shift;
      my $infile = $self->input_file();
  
      if(@{$self->{_list_stack}}) {
          my $list;
          while(($list = $self->_close_list('EOF',$infile)) &&
            $list->indent() ne 'auto') {
              $self->poderror({ -line => 'EOF', -file => $infile,
                  -severity => 'ERROR', -msg => '=over on line ' .
                  $list->start() . ' without closing =back' });
          }
      }
  
      # check validity of document internal hyperlinks
      # first build the node names from the paragraph text
      my %nodes;
      foreach($self->node()) {
          $nodes{$_} = 1;
          if(/^(\S+)\s+\S/) {
              # we have more than one word. Use the first as a node, too.
              # This is used heavily in perlfunc.pod
              $nodes{$1} ||= 2; # derived node
          }
      }
      foreach($self->idx()) {
          $nodes{$_} = 3; # index node
      }
      foreach($self->hyperlink()) {
          my ($line,$link) = @$_;
          # _TODO_ what if there is a link to the page itself by the name,
          # e.g. in Tk::Pod : L<Tk::Pod/"DESCRIPTION">
          if($link->node() && !$link->page() && $link->type() ne 'hyperlink') {
              my $node = $self->_check_ptree($self->parse_text($link->node(),
                  $line), $line, $infile, 'L');
              if($node && !$nodes{$node}) {
                  $self->poderror({ -line => $line || '', -file => $infile,
                      -severity => 'ERROR',
                      -msg => "unresolved internal link '$node'"});
              }
          }
      }
  
      # check the internal nodes for uniqueness. This pertains to
      # =headX, =item and X<...>
      if($self->{-warnings} && $self->{-warnings}>1) {
        foreach(grep($self->{_unique_nodes}->{$_} > 1,
          keys %{$self->{_unique_nodes}})) {
            $self->poderror({ -line => '-', -file => $infile,
              -severity => 'WARNING',
              -msg => "multiple occurrence of link target '$_'"});
        }
      }
  
      # no POD found here
      $self->num_errors(-1) if($self->{_commands} == 0);
  }
  
  # check a POD command directive
  sub command {
      my ($self, $cmd, $paragraph, $line_num, $pod_para) = @_;
      my ($file, $line) = $pod_para->file_line;
      ## Check the command syntax
      my $arg; # this will hold the command argument
      if (! $VALID_COMMANDS{$cmd}) {
         $self->poderror({ -line => $line, -file => $file, -severity => 'ERROR',
                           -msg => "Unknown command '$cmd'" });
      }
      else { # found a valid command
          $self->{_commands}++; # delete this line if below is enabled again
  
  	$self->_commands_in_paragraphs($paragraph, $pod_para);
  
          ##### following check disabled due to strong request
          #if(!$self->{_commands}++ && $cmd !~ /^head/) {
          #    $self->poderror({ -line => $line, -file => $file,
          #         -severity => 'WARNING',
          #         -msg => "file does not start with =head" });
          #}
  
          # check syntax of particular command
          if($cmd eq 'over') {
              # check for argument
              $arg = $self->interpolate_and_check($paragraph, $line,$file);
              my $indent = 4; # default
              if($arg && $arg =~ /^\s*(\d+)\s*$/) {
                  $indent = $1;
              }
              # start a new list
              $self->_open_list($indent,$line,$file);
          }
          elsif($cmd eq 'item') {
              # are we in a list?
              unless(@{$self->{_list_stack}}) {
                  $self->poderror({ -line => $line, -file => $file,
                       -severity => 'ERROR',
                       -msg => '=item without previous =over' });
                  # auto-open in case we encounter many more
                  $self->_open_list('auto',$line,$file);
              }
              my $list = $self->{_list_stack}->[0];
              # check whether the previous item had some contents
              if(defined $self->{_list_item_contents} &&
                $self->{_list_item_contents} == 0) {
                  $self->poderror({ -line => $line, -file => $file,
                       -severity => 'WARNING',
                       -msg => 'previous =item has no contents' });
              }
              if($list->{_has_par}) {
                  $self->poderror({ -line => $line, -file => $file,
                       -severity => 'WARNING',
                       -msg => 'preceding non-item paragraph(s)' });
                  delete $list->{_has_par};
              }
              # check for argument
              $arg = $self->interpolate_and_check($paragraph, $line, $file);
              if($arg && $arg =~ /(\S+)/) {
                  $arg =~ s/[\s\n]+$//;
                  my $type;
                  if($arg =~ /^[*]\s*(\S*.*)/) {
                    $type = 'bullet';
                    $self->{_list_item_contents} = $1 ? 1 : 0;
                    $arg = $1;
                  }
                  elsif($arg =~ /^\d+\.?\s+(\S*)/) {
                    $type = 'number';
                    $self->{_list_item_contents} = $1 ? 1 : 0;
                    $arg = $1;
                  }
                  else {
                    $type = 'definition';
                    $self->{_list_item_contents} = 1;
                  }
                  my $first = $list->type();
                  if($first && $first ne $type) {
                      $self->poderror({ -line => $line, -file => $file,
                         -severity => 'WARNING',
                         -msg => "=item type mismatch ('$first' vs. '$type')"});
                  }
                  else { # first item
                      $list->type($type);
                  }
              }
              else {
                  $self->poderror({ -line => $line, -file => $file,
                       -severity => 'WARNING',
                       -msg => 'No argument for =item' });
                  $arg = ' '; # empty
                  $self->{_list_item_contents} = 0;
              }
              # add this item
              $list->item($arg);
              # remember this node
              $self->node($arg);
          }
          elsif($cmd eq 'back') {
              # check if we have an open list
              unless(@{$self->{_list_stack}}) {
                  $self->poderror({ -line => $line, -file => $file,
                           -severity => 'ERROR',
                           -msg => '=back without previous =over' });
              }
              else {
                  # check for spurious characters
                  $arg = $self->interpolate_and_check($paragraph, $line,$file);
                  if($arg && $arg =~ /\S/) {
                      $self->poderror({ -line => $line, -file => $file,
                           -severity => 'ERROR',
                           -msg => 'Spurious character(s) after =back' });
                  }
                  # close list
                  my $list = $self->_close_list($line,$file);
                  # check for empty lists
                  if(!$list->item() && $self->{-warnings}) {
                      $self->poderror({ -line => $line, -file => $file,
                           -severity => 'WARNING',
                           -msg => 'No items in =over (at line ' .
                           $list->start() . ') / =back list'});
                  }
              }
          }
          elsif($cmd =~ /^head(\d+)/) {
              my $hnum = $1;
              $self->{"_have_head_$hnum"}++; # count head types
              if($hnum > 1 && !$self->{'_have_head_'.($hnum -1)}) {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'WARNING',
                     -msg => "=head$hnum without preceding higher level"});
              }
              # check whether the previous =head section had some contents
              if(defined $self->{_commands_in_head} &&
                $self->{_commands_in_head} == 0 &&
                defined $self->{_last_head} &&
                $self->{_last_head} >= $hnum) {
                  $self->poderror({ -line => $line, -file => $file,
                       -severity => 'WARNING',
                       -msg => 'empty section in previous paragraph'});
              }
              $self->{_commands_in_head} = -1;
              $self->{_last_head} = $hnum;
              # check if there is an open list
              if(@{$self->{_list_stack}}) {
                  my $list;
                  while(($list = $self->_close_list($line,$file)) &&
                    $list->indent() ne 'auto') {
                      $self->poderror({ -line => $line, -file => $file,
                           -severity => 'ERROR',
                           -msg => '=over on line '. $list->start() .
                           " without closing =back (at $cmd)" });
                  }
              }
              # remember this node
              $arg = $self->interpolate_and_check($paragraph, $line,$file);
              $arg =~ s/[\s\n]+$//s;
              $self->node($arg);
              unless(length($arg)) {
                  $self->poderror({ -line => $line, -file => $file,
                       -severity => 'ERROR',
                       -msg => "empty =$cmd"});
              }
              if($cmd eq 'head1') {
                  $self->{_current_head1} = $arg;
              } else {
                  $self->{_current_head1} = '';
              }
          }
          elsif($cmd eq 'begin') {
              if($self->{_have_begin}) {
                  # already have a begin
                  $self->poderror({ -line => $line, -file => $file,
                       -severity => 'ERROR',
                       -msg => q{Nested =begin's (first at line } .
                       $self->{_have_begin} . ')'});
              }
              else {
                  # check for argument
                  $arg = $self->interpolate_and_check($paragraph, $line,$file);
                  unless($arg && $arg =~ /(\S+)/) {
                      $self->poderror({ -line => $line, -file => $file,
                           -severity => 'ERROR',
                           -msg => 'No argument for =begin'});
                  }
                  # remember the =begin
                  $self->{_have_begin} = "$line:$1";
              }
          }
          elsif($cmd eq 'end') {
              if($self->{_have_begin}) {
                  # close the existing =begin
                  $self->{_have_begin} = '';
                  # check for spurious characters
                  $arg = $self->interpolate_and_check($paragraph, $line,$file);
                  # the closing argument is optional
                  #if($arg && $arg =~ /\S/) {
                  #    $self->poderror({ -line => $line, -file => $file,
                  #         -severity => 'WARNING',
                  #         -msg => "Spurious character(s) after =end" });
                  #}
              }
              else {
                  # don't have a matching =begin
                  $self->poderror({ -line => $line, -file => $file,
                       -severity => 'ERROR',
                       -msg => '=end without =begin' });
              }
          }
          elsif($cmd eq 'for') {
              unless($paragraph =~ /\s*(\S+)\s*/) {
                  $self->poderror({ -line => $line, -file => $file,
                       -severity => 'ERROR',
                       -msg => '=for without formatter specification' });
              }
              $arg = ''; # do not expand paragraph below
          }
          elsif($cmd =~ /^(pod|cut)$/) {
              # check for argument
              $arg = $self->interpolate_and_check($paragraph, $line,$file);
              if($arg && $arg =~ /(\S+)/) {
                  $self->poderror({ -line => $line, -file => $file,
                        -severity => 'ERROR',
                        -msg => "Spurious text after =$cmd"});
              }
  	    if($cmd eq 'cut' && (!$self->{_PREVIOUS} || $self->{_PREVIOUS} eq 'cut')) {
                  $self->poderror({ -line => $line, -file => $file,
                        -severity => 'ERROR',
                        -msg => "Spurious =cut command"});
  	    }
  	    if($cmd eq 'pod' && $self->{_PREVIOUS} && $self->{_PREVIOUS} ne 'cut') {
                  $self->poderror({ -line => $line, -file => $file,
                        -severity => 'ERROR',
                        -msg => "Spurious =pod command"});
  	    }
          }
      $self->{_commands_in_head}++;
      ## Check the interior sequences in the command-text
      $self->interpolate_and_check($paragraph, $line,$file)
          unless(defined $arg);
      }
  }
  
  sub _open_list
  {
      my ($self,$indent,$line,$file) = @_;
      my $list = Pod::List->new(
             -indent => $indent,
             -start => $line,
             -file => $file);
      unshift(@{$self->{_list_stack}}, $list);
      undef $self->{_list_item_contents};
      $list;
  }
  
  sub _close_list
  {
      my ($self,$line,$file) = @_;
      my $list = shift(@{$self->{_list_stack}});
      if(defined $self->{_list_item_contents} &&
        $self->{_list_item_contents} == 0) {
          $self->poderror({ -line => $line, -file => $file,
              -severity => 'WARNING',
              -msg => 'previous =item has no contents' });
      }
      undef $self->{_list_item_contents};
      $list;
  }
  
  # process a block of some text
  sub interpolate_and_check {
      my ($self, $paragraph, $line, $file) = @_;
      ## Check the interior sequences in the command-text
      # and return the text
      $self->_check_ptree(
          $self->parse_text($paragraph,$line), $line, $file, '');
  }
  
  sub _check_ptree {
      my ($self,$ptree,$line,$file,$nestlist) = @_;
      local($_);
      my $text = '';
      # process each node in the parse tree
      foreach(@$ptree) {
          # regular text chunk
          unless(ref) {
              # count the unescaped angle brackets
              # complain only when warning level is greater than 1
              if($self->{-warnings} && $self->{-warnings}>1) {
                my $count;
                if($count = tr/<>/<>/) {
                  $self->poderror({ -line => $line, -file => $file,
                       -severity => 'WARNING',
                       -msg => "$count unescaped <> in paragraph" });
                  }
              }
              $text .= $_;
              next;
          }
          # have an interior sequence
          my $cmd = $_->cmd_name();
          my $contents = $_->parse_tree();
          ($file,$line) = $_->file_line();
          # check for valid tag
          if (! $VALID_SEQUENCES{$cmd}) {
              $self->poderror({ -line => $line, -file => $file,
                   -severity => 'ERROR',
                   -msg => qq(Unknown interior-sequence '$cmd')});
              # expand it anyway
              $text .= $self->_check_ptree($contents, $line, $file, "$nestlist$cmd");
              next;
          }
          if(index($nestlist, $cmd) != -1) {
              $self->poderror({ -line => $line, -file => $file,
                   -severity => 'WARNING',
                   -msg => "nested commands $cmd<...$cmd<...>...>"});
              # _TODO_ should we add the contents anyway?
              # expand it anyway, see below
          }
          if($cmd eq 'E') {
              # preserve entities
              if(@$contents > 1 || ref $$contents[0] || $$contents[0] !~ /^\w+$/) {
                  $self->poderror({ -line => $line, -file => $file,
                      -severity => 'ERROR',
                      -msg => 'garbled entity ' . $_->raw_text()});
                  next;
              }
              my $ent = $$contents[0];
              my $val;
              if($ent =~ /^0x[0-9a-f]+$/i) {
                  # hexadec entity
                  $val = hex($ent);
              }
              elsif($ent =~ /^0\d+$/) {
                  # octal
                  $val = oct($ent);
              }
              elsif($ent =~ /^\d+$/) {
                  # numeric entity
                  $val = $ent;
              }
              if(defined $val) {
                  if($val>0 && $val<256) {
                      $text .= chr($val);
                  }
                  else {
                      $self->poderror({ -line => $line, -file => $file,
                          -severity => 'ERROR',
                          -msg => 'Entity number out of range ' . $_->raw_text()});
                  }
              }
              elsif($ENTITIES{$ent}) {
                  # known ISO entity
                  $text .= $ENTITIES{$ent};
              }
              else {
                  $self->poderror({ -line => $line, -file => $file,
                      -severity => 'WARNING',
                      -msg => 'Unknown entity ' . $_->raw_text()});
                  $text .= "E<$ent>";
              }
          }
          elsif($cmd eq 'L') {
              # try to parse the hyperlink
              my $link = Pod::Hyperlink->new($contents->raw_text());
              unless(defined $link) {
                  $self->poderror({ -line => $line, -file => $file,
                      -severity => 'ERROR',
                      -msg => 'malformed link ' . $_->raw_text() ." : $@"});
                  next;
              }
              $link->line($line); # remember line
              if($self->{-warnings}) {
                  foreach my $w ($link->warning()) {
                      $self->poderror({ -line => $line, -file => $file,
                          -severity => 'WARNING',
                          -msg => $w });
                  }
              }
              # check the link text
              $text .= $self->_check_ptree($self->parse_text($link->text(),
                  $line), $line, $file, "$nestlist$cmd");
              # remember link
              $self->hyperlink([$line,$link]);
          }
          elsif($cmd =~ /[BCFIS]/) {
              # add the guts
              $text .= $self->_check_ptree($contents, $line, $file, "$nestlist$cmd");
          }
          elsif($cmd eq 'Z') {
              if(length($contents->raw_text())) {
                  $self->poderror({ -line => $line, -file => $file,
                      -severity => 'ERROR',
                      -msg => 'Nonempty Z<>'});
              }
          }
          elsif($cmd eq 'X') {
              my $idx = $self->_check_ptree($contents, $line, $file, "$nestlist$cmd");
              if($idx =~ /^\s*$/s) {
                  $self->poderror({ -line => $line, -file => $file,
                      -severity => 'ERROR',
                      -msg => 'Empty X<>'});
              }
              else {
                  # remember this node
                  $self->idx($idx);
              }
          }
          else {
              # not reached
              croak 'internal error';
          }
      }
      $text;
  }
  
  # process a block of verbatim text
  sub verbatim {
      ## Nothing particular to check
      my ($self, $paragraph, $line_num, $pod_para) = @_;
  
      $self->_preproc_par($paragraph);
      $self->_commands_in_paragraphs($paragraph, $pod_para);
  
      if($self->{_current_head1} eq 'NAME') {
          my ($file, $line) = $pod_para->file_line;
          $self->poderror({ -line => $line, -file => $file,
              -severity => 'WARNING',
              -msg => 'Verbatim paragraph in NAME section' });
      }
  }
  
  # process a block of regular text
  sub textblock {
      my ($self, $paragraph, $line_num, $pod_para) = @_;
      my ($file, $line) = $pod_para->file_line;
  
      $self->_preproc_par($paragraph);
      $self->_commands_in_paragraphs($paragraph, $pod_para);
  
      # skip this paragraph if in a =begin block
      unless($self->{_have_begin}) {
          my $block = $self->interpolate_and_check($paragraph, $line,$file);
          if($self->{_current_head1} eq 'NAME') {
              if($block =~ /^\s*(\S+?)\s*[,-]/) {
                  # this is the canonical name
                  $self->{-name} = $1 unless(defined $self->{-name});
              }
          }
      }
  }
  
  sub _preproc_par
  {
      my $self = shift;
      $_[0] =~ s/[\s\n]+$//;
      if($_[0]) {
          $self->{_commands_in_head}++;
          $self->{_list_item_contents}++ if(defined $self->{_list_item_contents});
          if(@{$self->{_list_stack}} && !$self->{_list_stack}->[0]->item()) {
              $self->{_list_stack}->[0]->{_has_par} = 1;
          }
      }
  }
  
  # look for =foo commands at the start of a line within a paragraph, as for
  # instance the following which prints as "* one =item two".
  #
  #     =item one
  #     =item two
  #
  # Examples of =foo written in docs are expected to be indented in a verbatim
  # or marked up C<=foo> so won't be caught.  A double-angle C<< =foo >> could
  # have the =foo at the start of a line, but that should be unlikely and is
  # easily enough dealt with by not putting a newline after the C<<.
  #
  sub _commands_in_paragraphs {
    my ($self, $str, $pod_para) = @_;
    while ($str =~ /[^\n]\n=([a-z][a-z0-9]+)/sg) {
      my $cmd = $1;
      my $pos = pos($str);
      if ($VALID_COMMANDS{$cmd}) {
        my ($file, $line) = $pod_para->file_line;
        my $part = substr($str, 0, $pos);
        $line += ($part =~ tr/\n//);  # count of newlines
  
        $self->poderror
          ({ -line => $line, -file => $file,
             -severity => 'ERROR',
             -msg => "Apparent command =$cmd not preceded by blank line"});
      }
    }
  }
  
  1;
  
  __END__
  
  =head1 AUTHOR
  
  Please report bugs using L<http://rt.cpan.org>.
  
  Brad Appleton E<lt>bradapp@enteract.comE<gt> (initial version),
  Marek Rouchal E<lt>marekr@cpan.orgE<gt>
  
  Based on code for B<Pod::Text::pod2text()> written by
  Tom Christiansen E<lt>tchrist@mox.perl.comE<gt>
  
  B<Pod::Checker> is part of the L<Pod::Parser> distribution.
  
  =cut
  
POD_CHECKER

$fatpacked{"Pod/Find.pm"} = <<'POD_FIND';
  #############################################################################  
  # Pod/Find.pm -- finds files containing POD documentation
  #
  # Author: Marek Rouchal <marekr@cpan.org>
  # 
  # Copyright (C) 1999-2000 by Marek Rouchal (and borrowing code
  # from Nick Ing-Simmon's PodToHtml). All rights reserved.
  # This file is part of "PodParser". Pod::Find is free software;
  # you can redistribute it and/or modify it under the same terms
  # as Perl itself.
  #############################################################################
  
  package Pod::Find;
  use strict;
  
  use vars qw($VERSION);
  $VERSION = '1.51';   ## Current version of this package
  require  5.005;   ## requires this Perl version or later
  use Carp;
  
  BEGIN {
     if ($] < 5.006) {
        require Symbol;
        import Symbol;
     }
  }
  
  #############################################################################
  
  =head1 NAME
  
  Pod::Find - find POD documents in directory trees
  
  =head1 SYNOPSIS
  
    use Pod::Find qw(pod_find simplify_name);
    my %pods = pod_find({ -verbose => 1, -inc => 1 });
    foreach(keys %pods) {
       print "found library POD `$pods{$_}' in $_\n";
    }
  
    print "podname=",simplify_name('a/b/c/mymodule.pod'),"\n";
  
    $location = pod_where( { -inc => 1 }, "Pod::Find" );
  
  =head1 DESCRIPTION
  
  B<Pod::Find> provides a set of functions to locate POD files.  Note that
  no function is exported by default to avoid pollution of your namespace,
  so be sure to specify them in the B<use> statement if you need them:
  
    use Pod::Find qw(pod_find);
  
  From this version on the typical SCM (software configuration management)
  files/directories like RCS, CVS, SCCS, .svn are ignored.
  
  =cut
  
  #use diagnostics;
  use Exporter;
  use File::Spec;
  use File::Find;
  use Cwd qw(abs_path cwd);
  
  use vars qw(@ISA @EXPORT_OK $VERSION);
  @ISA = qw(Exporter);
  @EXPORT_OK = qw(&pod_find &simplify_name &pod_where &contains_pod);
  
  # package global variables
  my $SIMPLIFY_RX;
  
  =head2 C<pod_find( { %opts } , @directories )>
  
  The function B<pod_find> searches for POD documents in a given set of
  files and/or directories. It returns a hash with the file names as keys
  and the POD name as value. The POD name is derived from the file name
  and its position in the directory tree.
  
  E.g. when searching in F<$HOME/perl5lib>, the file
  F<$HOME/perl5lib/MyModule.pm> would get the POD name I<MyModule>,
  whereas F<$HOME/perl5lib/Myclass/Subclass.pm> would be
  I<Myclass::Subclass>. The name information can be used for POD
  translators.
  
  Only text files containing at least one valid POD command are found.
  
  A warning is printed if more than one POD file with the same POD name
  is found, e.g. F<CPAN.pm> in different directories. This usually
  indicates duplicate occurrences of modules in the I<@INC> search path.
  
  B<OPTIONS> The first argument for B<pod_find> may be a hash reference
  with options. The rest are either directories that are searched
  recursively or files.  The POD names of files are the plain basenames
  with any Perl-like extension (.pm, .pl, .pod) stripped.
  
  =over 4
  
  =item C<-verbose =E<gt> 1>
  
  Print progress information while scanning.
  
  =item C<-perl =E<gt> 1>
  
  Apply Perl-specific heuristics to find the correct PODs. This includes
  stripping Perl-like extensions, omitting subdirectories that are numeric
  but do I<not> match the current Perl interpreter's version id, suppressing
  F<site_perl> as a module hierarchy name etc.
  
  =item C<-script =E<gt> 1>
  
  Search for PODs in the current Perl interpreter's installation 
  B<scriptdir>. This is taken from the local L<Config|Config> module.
  
  =item C<-inc =E<gt> 1>
  
  Search for PODs in the current Perl interpreter's I<@INC> paths. This
  automatically considers paths specified in the C<PERL5LIB> environment
  as this is included in I<@INC> by the Perl interpreter itself.
  
  =back
  
  =cut
  
  # return a hash of the POD files found
  # first argument may be a hashref (options),
  # rest is a list of directories to search recursively
  sub pod_find
  {
      my %opts;
      if(ref $_[0]) {
          %opts = %{shift()};
      }
  
      $opts{-verbose} ||= 0;
      $opts{-perl}    ||= 0;
  
      my (@search) = @_;
  
      if($opts{-script}) {
          require Config;
          push(@search, $Config::Config{scriptdir})
              if -d $Config::Config{scriptdir};
          $opts{-perl} = 1;
      }
  
      if($opts{-inc}) {
          if ($^O eq 'MacOS') {
              # tolerate '.', './some_dir' and '(../)+some_dir' on Mac OS
              my @new_INC = @INC;
              for (@new_INC) {
                  if ( $_ eq '.' ) {
                      $_ = ':';
                  } elsif ( $_ =~ s{^((?:\.\./)+)}{':' x (length($1)/3)}e ) {
                      $_ = ':'. $_;
                  } else {
                      $_ =~ s{^\./}{:};
                  }
              }
              push(@search, grep($_ ne File::Spec->curdir, @new_INC));
          } else {
              my %seen;
              my $curdir = File::Spec->curdir;
  	    foreach(@INC) {
                  next if $_ eq $curdir;
  		my $path = abs_path($_);
                  push(@search, $path) unless $seen{$path}++;
              }
          }
  
          $opts{-perl} = 1;
      }
  
      if($opts{-perl}) {
          require Config;
          # this code simplifies the POD name for Perl modules:
          # * remove "site_perl"
          # * remove e.g. "i586-linux" (from 'archname')
          # * remove e.g. 5.00503
          # * remove pod/ if followed by *.pod (e.g. in pod/perlfunc.pod)
  
          # Mac OS:
          # * remove ":?site_perl:"
          # * remove :?pod: if followed by *.pod (e.g. in :pod:perlfunc.pod)
  
          if ($^O eq 'MacOS') {
              $SIMPLIFY_RX =
                qq!^(?i:\:?site_perl\:|\:?pod\:(?=.*?\\.pod\\z))*!;
          } else {
              $SIMPLIFY_RX =
                qq!^(?i:site(_perl)?/|\Q$Config::Config{archname}\E/|\\d+\\.\\d+([_.]?\\d+)?/|pod/(?=.*?\\.pod\\z))*!;
          }
      }
  
      my %dirs_visited;
      my %pods;
      my %names;
      my $pwd = cwd();
  
      foreach my $try (@search) {
          unless(File::Spec->file_name_is_absolute($try)) {
              # make path absolute
              $try = File::Spec->catfile($pwd,$try);
          }
          # simplify path
          # on VMS canonpath will vmsify:[the.path], but File::Find::find
          # wants /unixy/paths
          if ($^O eq 'VMS') {
              $try = VMS::Filespec::unixify($try);
          }
          else {
              $try = File::Spec->canonpath($try);
          }
          my $name;
          if(-f $try) {
              if($name = _check_and_extract_name($try, $opts{-verbose})) {
                  _check_for_duplicates($try, $name, \%names, \%pods);
              }
              next;
          }
          my $root_rx = $^O eq 'MacOS' ? qq!^\Q$try\E! : qq!^\Q$try\E/!;
          $root_rx=~ s|//$|/|;  # remove trailing double slash
          File::Find::find( sub {
              my $item = $File::Find::name;
              if(-d) {
                  if($item =~ m{/(?:RCS|CVS|SCCS|\.svn)$}) {
                      $File::Find::prune = 1;
                      return;
                  }
                  elsif($dirs_visited{$item}) {
                      warn "Directory '$item' already seen, skipping.\n"
                          if($opts{-verbose});
                      $File::Find::prune = 1;
                      return;
                  }
                  else {
                      $dirs_visited{$item} = 1;
                  }
                  if($opts{-perl} && /^(\d+\.[\d_]+)\z/s && eval "$1" != $]) {
                      $File::Find::prune = 1;
                      warn "Perl $] version mismatch on $_, skipping.\n"
                          if($opts{-verbose});
                  }
                  return;
              }
              if($name = _check_and_extract_name($item, $opts{-verbose}, $root_rx)) {
                  _check_for_duplicates($item, $name, \%names, \%pods);
              }
          }, $try); # end of File::Find::find
      }
      chdir $pwd;
      return %pods;
  }
  
  sub _check_for_duplicates {
      my ($file, $name, $names_ref, $pods_ref) = @_;
      if($$names_ref{$name}) {
          warn "Duplicate POD found (shadowing?): $name ($file)\n";
          warn '    Already seen in ',
              join(' ', grep($$pods_ref{$_} eq $name, keys %$pods_ref)),"\n";
      }
      else {
          $$names_ref{$name} = 1;
      }
      return $$pods_ref{$file} = $name;
  }
  
  sub _check_and_extract_name {
      my ($file, $verbose, $root_rx) = @_;
  
      # check extension or executable flag
      # this involves testing the .bat extension on Win32!
      unless(-f $file && -T $file && ($file =~ /\.(pod|pm|plx?)\z/i || -x $file )) {
        return;
      }
  
      return unless contains_pod($file,$verbose);
  
      # strip non-significant path components
      # TODO what happens on e.g. Win32?
      my $name = $file;
      if(defined $root_rx) {
          $name =~ s/$root_rx//is;
          $name =~ s/$SIMPLIFY_RX//is if(defined $SIMPLIFY_RX);
      }
      else {
          if ($^O eq 'MacOS') {
              $name =~ s/^.*://s;
          } else {
              $name =~ s{^.*/}{}s;
          }
      }
      _simplify($name);
      $name =~ s{/+}{::}g;
      if ($^O eq 'MacOS') {
          $name =~ s{:+}{::}g; # : -> ::
      } else {
          $name =~ s{/+}{::}g; # / -> ::
      }
      return $name;
  }
  
  =head2 C<simplify_name( $str )>
  
  The function B<simplify_name> is equivalent to B<basename>, but also
  strips Perl-like extensions (.pm, .pl, .pod) and extensions like
  F<.bat>, F<.cmd> on Win32 and OS/2, or F<.com> on VMS, respectively.
  
  =cut
  
  # basic simplification of the POD name:
  # basename & strip extension
  sub simplify_name {
      my ($str) = @_;
      # remove all path components
      if ($^O eq 'MacOS') {
          $str =~ s/^.*://s;
      } else {
          $str =~ s{^.*/}{}s;
      }
      _simplify($str);
      return $str;
  }
  
  # internal sub only
  sub _simplify {
      # strip Perl's own extensions
      $_[0] =~ s/\.(pod|pm|plx?)\z//i;
      # strip meaningless extensions on Win32 and OS/2
      $_[0] =~ s/\.(bat|exe|cmd)\z//i if($^O =~ /mswin|os2/i);
      # strip meaningless extensions on VMS
      $_[0] =~ s/\.(com)\z//i if($^O eq 'VMS');
  }
  
  # contribution from Tim Jenness <t.jenness@jach.hawaii.edu>
  
  =head2 C<pod_where( { %opts }, $pod )>
  
  Returns the location of a pod document given a search directory
  and a module (e.g. C<File::Find>) or script (e.g. C<perldoc>) name.
  
  Options:
  
  =over 4
  
  =item C<-inc =E<gt> 1>
  
  Search @INC for the pod and also the C<scriptdir> defined in the
  L<Config|Config> module.
  
  =item C<-dirs =E<gt> [ $dir1, $dir2, ... ]>
  
  Reference to an array of search directories. These are searched in order
  before looking in C<@INC> (if B<-inc>). Current directory is used if
  none are specified.
  
  =item C<-verbose =E<gt> 1>
  
  List directories as they are searched
  
  =back
  
  Returns the full path of the first occurrence to the file.
  Package names (eg 'A::B') are automatically converted to directory
  names in the selected directory. (eg on unix 'A::B' is converted to
  'A/B'). Additionally, '.pm', '.pl' and '.pod' are appended to the
  search automatically if required.
  
  A subdirectory F<pod/> is also checked if it exists in any of the given
  search directories. This ensures that e.g. L<perlfunc|perlfunc> is
  found.
  
  It is assumed that if a module name is supplied, that that name
  matches the file name. Pods are not opened to check for the 'NAME'
  entry.
  
  A check is made to make sure that the file that is found does 
  contain some pod documentation.
  
  =cut
  
  sub pod_where {
  
    # default options
    my %options = (
           '-inc' => 0,
           '-verbose' => 0,
           '-dirs' => [ File::Spec->curdir ],
          );
  
    # Check for an options hash as first argument
    if (defined $_[0] && ref($_[0]) eq 'HASH') {
      my $opt = shift;
  
      # Merge default options with supplied options
      %options = (%options, %$opt);
    }
  
    # Check usage
    carp 'Usage: pod_where({options}, $pod)' unless (scalar(@_));
  
    # Read argument
    my $pod = shift;
  
    # Split on :: and then join the name together using File::Spec
    my @parts = split (/::/, $pod);
  
    # Get full directory list
    my @search_dirs = @{ $options{'-dirs'} };
  
    if ($options{'-inc'}) {
  
      require Config;
  
      # Add @INC
      if ($^O eq 'MacOS' && $options{'-inc'}) {
          # tolerate '.', './some_dir' and '(../)+some_dir' on Mac OS
          my @new_INC = @INC;
          for (@new_INC) {
              if ( $_ eq '.' ) {
                  $_ = ':';
              } elsif ( $_ =~ s{^((?:\.\./)+)}{':' x (length($1)/3)}e ) {
                  $_ = ':'. $_;
              } else {
                  $_ =~ s{^\./}{:};
              }
          }
          push (@search_dirs, @new_INC);
      } elsif ($options{'-inc'}) {
          push (@search_dirs, @INC);
      }
  
      # Add location of pod documentation for perl man pages (eg perlfunc)
      # This is a pod directory in the private install tree
      #my $perlpoddir = File::Spec->catdir($Config::Config{'installprivlib'},
      #					'pod');
      #push (@search_dirs, $perlpoddir)
      #  if -d $perlpoddir;
  
      # Add location of binaries such as pod2text
      push (@search_dirs, $Config::Config{'scriptdir'})
        if -d $Config::Config{'scriptdir'};
    }
  
    warn 'Search path is: '.join(' ', @search_dirs)."\n"
          if $options{'-verbose'};
  
    # Loop over directories
    Dir: foreach my $dir ( @search_dirs ) {
  
      # Don't bother if can't find the directory
      if (-d $dir) {
        warn "Looking in directory $dir\n"
          if $options{'-verbose'};
  
        # Now concatenate this directory with the pod we are searching for
        my $fullname = File::Spec->catfile($dir, @parts);
        $fullname = VMS::Filespec::unixify($fullname) if $^O eq 'VMS';
        warn "Filename is now $fullname\n"
          if $options{'-verbose'};
  
        # Loop over possible extensions
        foreach my $ext ('', '.pod', '.pm', '.pl') {
          my $fullext = $fullname . $ext;
          if (-f $fullext &&
           contains_pod($fullext, $options{'-verbose'}) ) {
            warn "FOUND: $fullext\n" if $options{'-verbose'};
            return $fullext;
          }
        }
      } else {
        warn "Directory $dir does not exist\n"
          if $options{'-verbose'};
        next Dir;
      }
      # for some strange reason the path on MacOS/darwin/cygwin is
      # 'pods' not 'pod'
      # this could be the case also for other systems that
      # have a case-tolerant file system, but File::Spec
      # does not recognize 'darwin' yet. And cygwin also has "pods",
      # but is not case tolerant. Oh well...
      if((File::Spec->case_tolerant || $^O =~ /macos|darwin|cygwin/i)
       && -d File::Spec->catdir($dir,'pods')) {
        $dir = File::Spec->catdir($dir,'pods');
        redo Dir;
      }
      if(-d File::Spec->catdir($dir,'pod')) {
        $dir = File::Spec->catdir($dir,'pod');
        redo Dir;
      }
    }
    # No match;
    return;
  }
  
  =head2 C<contains_pod( $file , $verbose )>
  
  Returns true if the supplied filename (not POD module) contains some pod
  information.
  
  =cut
  
  sub contains_pod {
    my $file = shift;
    my $verbose = 0;
    $verbose = shift if @_;
  
    # check for one line of POD
    my $podfh;
    if ($] < 5.006) {
      $podfh = gensym();
    }
  
    unless(open($podfh,"<$file")) {
      warn "Error: $file is unreadable: $!\n";
      return;
    }
    
    local $/ = undef;
    my $pod = <$podfh>;
    close($podfh) || die "Error closing $file: $!\n";
    unless($pod =~ /^=(head\d|pod|over|item|cut)\b/m) {
      warn "No POD in $file, skipping.\n"
        if($verbose);
      return 0;
    }
  
    return 1;
  }
  
  =head1 AUTHOR
  
  Please report bugs using L<http://rt.cpan.org>.
  
  Marek Rouchal E<lt>marekr@cpan.orgE<gt>,
  heavily borrowing code from Nick Ing-Simmons' PodToHtml.
  
  Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt> provided
  C<pod_where> and C<contains_pod>.
  
  B<Pod::Find> is part of the L<Pod::Parser> distribution.
  
  =head1 SEE ALSO
  
  L<Pod::Parser>, L<Pod::Checker>, L<perldoc>
  
  =cut
  
  1;
  
POD_FIND

$fatpacked{"Pod/InputObjects.pm"} = <<'POD_INPUTOBJECTS';
  #############################################################################
  # Pod/InputObjects.pm -- package which defines objects for input streams
  # and paragraphs and commands when parsing POD docs.
  #
  # Copyright (C) 1996-2000 by Bradford Appleton. All rights reserved.
  # This file is part of "PodParser". PodParser is free software;
  # you can redistribute it and/or modify it under the same terms
  # as Perl itself.
  #############################################################################
  
  package Pod::InputObjects;
  use strict;
  
  use vars qw($VERSION);
  $VERSION = '1.51';  ## Current version of this package
  require  5.005;    ## requires this Perl version or later
  
  #############################################################################
  
  =head1 NAME
  
  Pod::InputObjects - objects representing POD input paragraphs, commands, etc.
  
  =head1 SYNOPSIS
  
      use Pod::InputObjects;
  
  =head1 REQUIRES
  
  perl5.004, Carp
  
  =head1 EXPORTS
  
  Nothing.
  
  =head1 DESCRIPTION
  
  This module defines some basic input objects used by B<Pod::Parser> when
  reading and parsing POD text from an input source. The following objects
  are defined:
  
  =begin __PRIVATE__
  
  =over 4
  
  =item package B<Pod::InputSource>
  
  An object corresponding to a source of POD input text. It is mostly a
  wrapper around a filehandle or C<IO::Handle>-type object (or anything
  that implements the C<getline()> method) which keeps track of some
  additional information relevant to the parsing of PODs.
  
  =back
  
  =end __PRIVATE__
  
  =over 4
  
  =item package B<Pod::Paragraph>
  
  An object corresponding to a paragraph of POD input text. It may be a
  plain paragraph, a verbatim paragraph, or a command paragraph (see
  L<perlpod>).
  
  =item package B<Pod::InteriorSequence>
  
  An object corresponding to an interior sequence command from the POD
  input text (see L<perlpod>).
  
  =item package B<Pod::ParseTree>
  
  An object corresponding to a tree of parsed POD text. Each "node" in
  a parse-tree (or I<ptree>) is either a text-string or a reference to
  a B<Pod::InteriorSequence> object. The nodes appear in the parse-tree
  in the order in which they were parsed from left-to-right.
  
  =back
  
  Each of these input objects are described in further detail in the
  sections which follow.
  
  =cut
  
  #############################################################################
  
  package Pod::InputSource;
  
  ##---------------------------------------------------------------------------
  
  =begin __PRIVATE__
  
  =head1 B<Pod::InputSource>
  
  This object corresponds to an input source or stream of POD
  documentation. When parsing PODs, it is necessary to associate and store
  certain context information with each input source. All of this
  information is kept together with the stream itself in one of these
  C<Pod::InputSource> objects. Each such object is merely a wrapper around
  an C<IO::Handle> object of some kind (or at least something that
  implements the C<getline()> method). They have the following
  methods/attributes:
  
  =end __PRIVATE__
  
  =cut
  
  ##---------------------------------------------------------------------------
  
  =begin __PRIVATE__
  
  =head2 B<new()>
  
          my $pod_input1 = Pod::InputSource->new(-handle => $filehandle);
          my $pod_input2 = new Pod::InputSource(-handle => $filehandle,
                                                -name   => $name);
          my $pod_input3 = new Pod::InputSource(-handle => \*STDIN);
          my $pod_input4 = Pod::InputSource->new(-handle => \*STDIN,
                                                 -name => "(STDIN)");
  
  This is a class method that constructs a C<Pod::InputSource> object and
  returns a reference to the new input source object. It takes one or more
  keyword arguments in the form of a hash. The keyword C<-handle> is
  required and designates the corresponding input handle. The keyword
  C<-name> is optional and specifies the name associated with the input
  handle (typically a file name).
  
  =end __PRIVATE__
  
  =cut
  
  sub new {
      ## Determine if we were called via an object-ref or a classname
      my $this = shift;
      my $class = ref($this) || $this;
  
      ## Any remaining arguments are treated as initial values for the
      ## hash that is used to represent this object. Note that we default
      ## certain values by specifying them *before* the arguments passed.
      ## If they are in the argument list, they will override the defaults.
      my $self = { -name        => '(unknown)',
                   -handle      => undef,
                   -was_cutting => 0,
                   @_ };
  
      ## Bless ourselves into the desired class and perform any initialization
      bless $self, $class;
      return $self;
  }
  
  ##---------------------------------------------------------------------------
  
  =begin __PRIVATE__
  
  =head2 B<name()>
  
          my $filename = $pod_input->name();
          $pod_input->name($new_filename_to_use);
  
  This method gets/sets the name of the input source (usually a filename).
  If no argument is given, it returns a string containing the name of
  the input source; otherwise it sets the name of the input source to the
  contents of the given argument.
  
  =end __PRIVATE__
  
  =cut
  
  sub name {
     (@_ > 1)  and  $_[0]->{'-name'} = $_[1];
     return $_[0]->{'-name'};
  }
  
  ## allow 'filename' as an alias for 'name'
  *filename = \&name;
  
  ##---------------------------------------------------------------------------
  
  =begin __PRIVATE__
  
  =head2 B<handle()>
  
          my $handle = $pod_input->handle();
  
  Returns a reference to the handle object from which input is read (the
  one used to contructed this input source object).
  
  =end __PRIVATE__
  
  =cut
  
  sub handle {
     return $_[0]->{'-handle'};
  }
  
  ##---------------------------------------------------------------------------
  
  =begin __PRIVATE__
  
  =head2 B<was_cutting()>
  
          print "Yes.\n" if ($pod_input->was_cutting());
  
  The value of the C<cutting> state (that the B<cutting()> method would
  have returned) immediately before any input was read from this input
  stream. After all input from this stream has been read, the C<cutting>
  state is restored to this value.
  
  =end __PRIVATE__
  
  =cut
  
  sub was_cutting {
     (@_ > 1)  and  $_[0]->{-was_cutting} = $_[1];
     return $_[0]->{-was_cutting};
  }
  
  ##---------------------------------------------------------------------------
  
  #############################################################################
  
  package Pod::Paragraph;
  
  ##---------------------------------------------------------------------------
  
  =head1 B<Pod::Paragraph>
  
  An object representing a paragraph of POD input text.
  It has the following methods/attributes:
  
  =cut
  
  ##---------------------------------------------------------------------------
  
  =head2 Pod::Paragraph-E<gt>B<new()>
  
          my $pod_para1 = Pod::Paragraph->new(-text => $text);
          my $pod_para2 = Pod::Paragraph->new(-name => $cmd,
                                              -text => $text);
          my $pod_para3 = new Pod::Paragraph(-text => $text);
          my $pod_para4 = new Pod::Paragraph(-name => $cmd,
                                             -text => $text);
          my $pod_para5 = Pod::Paragraph->new(-name => $cmd,
                                              -text => $text,
                                              -file => $filename,
                                              -line => $line_number);
  
  This is a class method that constructs a C<Pod::Paragraph> object and
  returns a reference to the new paragraph object. It may be given one or
  two keyword arguments. The C<-text> keyword indicates the corresponding
  text of the POD paragraph. The C<-name> keyword indicates the name of
  the corresponding POD command, such as C<head1> or C<item> (it should
  I<not> contain the C<=> prefix); this is needed only if the POD
  paragraph corresponds to a command paragraph. The C<-file> and C<-line>
  keywords indicate the filename and line number corresponding to the
  beginning of the paragraph 
  
  =cut
  
  sub new {
      ## Determine if we were called via an object-ref or a classname
      my $this = shift;
      my $class = ref($this) || $this;
  
      ## Any remaining arguments are treated as initial values for the
      ## hash that is used to represent this object. Note that we default
      ## certain values by specifying them *before* the arguments passed.
      ## If they are in the argument list, they will override the defaults.
      my $self = {
            -name       => undef,
            -text       => (@_ == 1) ? shift : undef,
            -file       => '<unknown-file>',
            -line       => 0,
            -prefix     => '=',
            -separator  => ' ',
            -ptree => [],
            @_
      };
  
      ## Bless ourselves into the desired class and perform any initialization
      bless $self, $class;
      return $self;
  }
  
  ##---------------------------------------------------------------------------
  
  =head2 $pod_para-E<gt>B<cmd_name()>
  
          my $para_cmd = $pod_para->cmd_name();
  
  If this paragraph is a command paragraph, then this method will return 
  the name of the command (I<without> any leading C<=> prefix).
  
  =cut
  
  sub cmd_name {
     (@_ > 1)  and  $_[0]->{'-name'} = $_[1];
     return $_[0]->{'-name'};
  }
  
  ## let name() be an alias for cmd_name()
  *name = \&cmd_name;
  
  ##---------------------------------------------------------------------------
  
  =head2 $pod_para-E<gt>B<text()>
  
          my $para_text = $pod_para->text();
  
  This method will return the corresponding text of the paragraph.
  
  =cut
  
  sub text {
     (@_ > 1)  and  $_[0]->{'-text'} = $_[1];
     return $_[0]->{'-text'};
  }
  
  ##---------------------------------------------------------------------------
  
  =head2 $pod_para-E<gt>B<raw_text()>
  
          my $raw_pod_para = $pod_para->raw_text();
  
  This method will return the I<raw> text of the POD paragraph, exactly
  as it appeared in the input.
  
  =cut
  
  sub raw_text {
     return $_[0]->{'-text'}  unless (defined $_[0]->{'-name'});
     return $_[0]->{'-prefix'} . $_[0]->{'-name'} .
            $_[0]->{'-separator'} . $_[0]->{'-text'};
  }
  
  ##---------------------------------------------------------------------------
  
  =head2 $pod_para-E<gt>B<cmd_prefix()>
  
          my $prefix = $pod_para->cmd_prefix();
  
  If this paragraph is a command paragraph, then this method will return 
  the prefix used to denote the command (which should be the string "="
  or "==").
  
  =cut
  
  sub cmd_prefix {
     return $_[0]->{'-prefix'};
  }
  
  ##---------------------------------------------------------------------------
  
  =head2 $pod_para-E<gt>B<cmd_separator()>
  
          my $separator = $pod_para->cmd_separator();
  
  If this paragraph is a command paragraph, then this method will return
  the text used to separate the command name from the rest of the
  paragraph (if any).
  
  =cut
  
  sub cmd_separator {
     return $_[0]->{'-separator'};
  }
  
  ##---------------------------------------------------------------------------
  
  =head2 $pod_para-E<gt>B<parse_tree()>
  
          my $ptree = $pod_parser->parse_text( $pod_para->text() );
          $pod_para->parse_tree( $ptree );
          $ptree = $pod_para->parse_tree();
  
  This method will get/set the corresponding parse-tree of the paragraph's text.
  
  =cut
  
  sub parse_tree {
     (@_ > 1)  and  $_[0]->{'-ptree'} = $_[1];
     return $_[0]->{'-ptree'};
  }
  
  ## let ptree() be an alias for parse_tree()
  *ptree = \&parse_tree;
  
  ##---------------------------------------------------------------------------
  
  =head2 $pod_para-E<gt>B<file_line()>
  
          my ($filename, $line_number) = $pod_para->file_line();
          my $position = $pod_para->file_line();
  
  Returns the current filename and line number for the paragraph
  object.  If called in a list context, it returns a list of two
  elements: first the filename, then the line number. If called in
  a scalar context, it returns a string containing the filename, followed
  by a colon (':'), followed by the line number.
  
  =cut
  
  sub file_line {
     my @loc = ($_[0]->{'-file'} || '<unknown-file>',
                $_[0]->{'-line'} || 0);
     return (wantarray) ? @loc : join(':', @loc);
  }
  
  ##---------------------------------------------------------------------------
  
  #############################################################################
  
  package Pod::InteriorSequence;
  
  ##---------------------------------------------------------------------------
  
  =head1 B<Pod::InteriorSequence>
  
  An object representing a POD interior sequence command.
  It has the following methods/attributes:
  
  =cut
  
  ##---------------------------------------------------------------------------
  
  =head2 Pod::InteriorSequence-E<gt>B<new()>
  
          my $pod_seq1 = Pod::InteriorSequence->new(-name => $cmd
                                                    -ldelim => $delimiter);
          my $pod_seq2 = new Pod::InteriorSequence(-name => $cmd,
                                                   -ldelim => $delimiter);
          my $pod_seq3 = new Pod::InteriorSequence(-name => $cmd,
                                                   -ldelim => $delimiter,
                                                   -file => $filename,
                                                   -line => $line_number);
  
          my $pod_seq4 = new Pod::InteriorSequence(-name => $cmd, $ptree);
          my $pod_seq5 = new Pod::InteriorSequence($cmd, $ptree);
  
  This is a class method that constructs a C<Pod::InteriorSequence> object
  and returns a reference to the new interior sequence object. It should
  be given two keyword arguments.  The C<-ldelim> keyword indicates the
  corresponding left-delimiter of the interior sequence (e.g. 'E<lt>').
  The C<-name> keyword indicates the name of the corresponding interior
  sequence command, such as C<I> or C<B> or C<C>. The C<-file> and
  C<-line> keywords indicate the filename and line number corresponding
  to the beginning of the interior sequence. If the C<$ptree> argument is
  given, it must be the last argument, and it must be either string, or
  else an array-ref suitable for passing to B<Pod::ParseTree::new> (or
  it may be a reference to a Pod::ParseTree object).
  
  =cut
  
  sub new {
      ## Determine if we were called via an object-ref or a classname
      my $this = shift;
      my $class = ref($this) || $this;
  
      ## See if first argument has no keyword
      if (((@_ <= 2) or (@_ % 2)) and $_[0] !~ /^-\w/) {
         ## Yup - need an implicit '-name' before first parameter
         unshift @_, '-name';
      }
  
      ## See if odd number of args
      if ((@_ % 2) != 0) {
         ## Yup - need an implicit '-ptree' before the last parameter
         splice @_, $#_, 0, '-ptree';
      }
  
      ## Any remaining arguments are treated as initial values for the
      ## hash that is used to represent this object. Note that we default
      ## certain values by specifying them *before* the arguments passed.
      ## If they are in the argument list, they will override the defaults.
      my $self = {
            -name       => (@_ == 1) ? $_[0] : undef,
            -file       => '<unknown-file>',
            -line       => 0,
            -ldelim     => '<',
            -rdelim     => '>',
            @_
      };
  
      ## Initialize contents if they havent been already
      my $ptree = $self->{'-ptree'} || new Pod::ParseTree();
      if ( ref $ptree =~ /^(ARRAY)?$/ ) {
          ## We have an array-ref, or a normal scalar. Pass it as an
          ## an argument to the ptree-constructor
          $ptree = new Pod::ParseTree($1 ? [$ptree] : $ptree);
      }
      $self->{'-ptree'} = $ptree;
  
      ## Bless ourselves into the desired class and perform any initialization
      bless $self, $class;
      return $self;
  }
  
  ##---------------------------------------------------------------------------
  
  =head2 $pod_seq-E<gt>B<cmd_name()>
  
          my $seq_cmd = $pod_seq->cmd_name();
  
  The name of the interior sequence command.
  
  =cut
  
  sub cmd_name {
     (@_ > 1)  and  $_[0]->{'-name'} = $_[1];
     return $_[0]->{'-name'};
  }
  
  ## let name() be an alias for cmd_name()
  *name = \&cmd_name;
  
  ##---------------------------------------------------------------------------
  
  ## Private subroutine to set the parent pointer of all the given
  ## children that are interior-sequences to be $self
  
  sub _set_child2parent_links {
     my ($self, @children) = @_;
     ## Make sure any sequences know who their parent is
     for (@children) {
        next  unless (length  and  ref  and  ref ne 'SCALAR');
        if (UNIVERSAL::isa($_, 'Pod::InteriorSequence') or
            UNIVERSAL::can($_, 'nested'))
        {
            $_->nested($self);
        }
     }
  }
  
  ## Private subroutine to unset child->parent links
  
  sub _unset_child2parent_links {
     my $self = shift;
     $self->{'-parent_sequence'} = undef;
     my $ptree = $self->{'-ptree'};
     for (@$ptree) {
        next  unless (length  and  ref  and  ref ne 'SCALAR');
        $_->_unset_child2parent_links()
            if UNIVERSAL::isa($_, 'Pod::InteriorSequence');
     }
  }
  
  ##---------------------------------------------------------------------------
  
  =head2 $pod_seq-E<gt>B<prepend()>
  
          $pod_seq->prepend($text);
          $pod_seq1->prepend($pod_seq2);
  
  Prepends the given string or parse-tree or sequence object to the parse-tree
  of this interior sequence.
  
  =cut
  
  sub prepend {
     my $self  = shift;
     $self->{'-ptree'}->prepend(@_);
     _set_child2parent_links($self, @_);
     return $self;
  }
  
  ##---------------------------------------------------------------------------
  
  =head2 $pod_seq-E<gt>B<append()>
  
          $pod_seq->append($text);
          $pod_seq1->append($pod_seq2);
  
  Appends the given string or parse-tree or sequence object to the parse-tree
  of this interior sequence.
  
  =cut
  
  sub append {
     my $self = shift;
     $self->{'-ptree'}->append(@_);
     _set_child2parent_links($self, @_);
     return $self;
  }
  
  ##---------------------------------------------------------------------------
  
  =head2 $pod_seq-E<gt>B<nested()>
  
          $outer_seq = $pod_seq->nested || print "not nested";
  
  If this interior sequence is nested inside of another interior
  sequence, then the outer/parent sequence that contains it is
  returned. Otherwise C<undef> is returned.
  
  =cut
  
  sub nested {
     my $self = shift;
    (@_ == 1)  and  $self->{'-parent_sequence'} = shift;
     return  $self->{'-parent_sequence'} || undef;
  }
  
  ##---------------------------------------------------------------------------
  
  =head2 $pod_seq-E<gt>B<raw_text()>
  
          my $seq_raw_text = $pod_seq->raw_text();
  
  This method will return the I<raw> text of the POD interior sequence,
  exactly as it appeared in the input.
  
  =cut
  
  sub raw_text {
     my $self = shift;
     my $text = $self->{'-name'} . $self->{'-ldelim'};
     for ( $self->{'-ptree'}->children ) {
        $text .= (ref $_) ? $_->raw_text : $_;
     }
     $text .= $self->{'-rdelim'};
     return $text;
  }
  
  ##---------------------------------------------------------------------------
  
  =head2 $pod_seq-E<gt>B<left_delimiter()>
  
          my $ldelim = $pod_seq->left_delimiter();
  
  The leftmost delimiter beginning the argument text to the interior
  sequence (should be "<").
  
  =cut
  
  sub left_delimiter {
     (@_ > 1)  and  $_[0]->{'-ldelim'} = $_[1];
     return $_[0]->{'-ldelim'};
  }
  
  ## let ldelim() be an alias for left_delimiter()
  *ldelim = \&left_delimiter;
  
  ##---------------------------------------------------------------------------
  
  =head2 $pod_seq-E<gt>B<right_delimiter()>
  
  The rightmost delimiter beginning the argument text to the interior
  sequence (should be ">").
  
  =cut
  
  sub right_delimiter {
     (@_ > 1)  and  $_[0]->{'-rdelim'} = $_[1];
     return $_[0]->{'-rdelim'};
  }
  
  ## let rdelim() be an alias for right_delimiter()
  *rdelim = \&right_delimiter;
  
  ##---------------------------------------------------------------------------
  
  =head2 $pod_seq-E<gt>B<parse_tree()>
  
          my $ptree = $pod_parser->parse_text($paragraph_text);
          $pod_seq->parse_tree( $ptree );
          $ptree = $pod_seq->parse_tree();
  
  This method will get/set the corresponding parse-tree of the interior
  sequence's text.
  
  =cut
  
  sub parse_tree {
     (@_ > 1)  and  $_[0]->{'-ptree'} = $_[1];
     return $_[0]->{'-ptree'};
  }
  
  ## let ptree() be an alias for parse_tree()
  *ptree = \&parse_tree;
  
  ##---------------------------------------------------------------------------
  
  =head2 $pod_seq-E<gt>B<file_line()>
  
          my ($filename, $line_number) = $pod_seq->file_line();
          my $position = $pod_seq->file_line();
  
  Returns the current filename and line number for the interior sequence
  object.  If called in a list context, it returns a list of two
  elements: first the filename, then the line number. If called in
  a scalar context, it returns a string containing the filename, followed
  by a colon (':'), followed by the line number.
  
  =cut
  
  sub file_line {
     my @loc = ($_[0]->{'-file'}  || '<unknown-file>',
                $_[0]->{'-line'}  || 0);
     return (wantarray) ? @loc : join(':', @loc);
  }
  
  ##---------------------------------------------------------------------------
  
  =head2 Pod::InteriorSequence::B<DESTROY()>
  
  This method performs any necessary cleanup for the interior-sequence.
  If you override this method then it is B<imperative> that you invoke
  the parent method from within your own method, otherwise
  I<interior-sequence storage will not be reclaimed upon destruction!>
  
  =cut
  
  sub DESTROY {
     ## We need to get rid of all child->parent pointers throughout the
     ## tree so their reference counts will go to zero and they can be
     ## garbage-collected
     _unset_child2parent_links(@_);
  }
  
  ##---------------------------------------------------------------------------
  
  #############################################################################
  
  package Pod::ParseTree;
  
  ##---------------------------------------------------------------------------
  
  =head1 B<Pod::ParseTree>
  
  This object corresponds to a tree of parsed POD text. As POD text is
  scanned from left to right, it is parsed into an ordered list of
  text-strings and B<Pod::InteriorSequence> objects (in order of
  appearance). A B<Pod::ParseTree> object corresponds to this list of
  strings and sequences. Each interior sequence in the parse-tree may
  itself contain a parse-tree (since interior sequences may be nested).
  
  =cut
  
  ##---------------------------------------------------------------------------
  
  =head2 Pod::ParseTree-E<gt>B<new()>
  
          my $ptree1 = Pod::ParseTree->new;
          my $ptree2 = new Pod::ParseTree;
          my $ptree4 = Pod::ParseTree->new($array_ref);
          my $ptree3 = new Pod::ParseTree($array_ref);
  
  This is a class method that constructs a C<Pod::Parse_tree> object and
  returns a reference to the new parse-tree. If a single-argument is given,
  it must be a reference to an array, and is used to initialize the root
  (top) of the parse tree.
  
  =cut
  
  sub new {
      ## Determine if we were called via an object-ref or a classname
      my $this = shift;
      my $class = ref($this) || $this;
  
      my $self = (@_ == 1  and  ref $_[0]) ? $_[0] : [];
  
      ## Bless ourselves into the desired class and perform any initialization
      bless $self, $class;
      return $self;
  }
  
  ##---------------------------------------------------------------------------
  
  =head2 $ptree-E<gt>B<top()>
  
          my $top_node = $ptree->top();
          $ptree->top( $top_node );
          $ptree->top( @children );
  
  This method gets/sets the top node of the parse-tree. If no arguments are
  given, it returns the topmost node in the tree (the root), which is also
  a B<Pod::ParseTree>. If it is given a single argument that is a reference,
  then the reference is assumed to a parse-tree and becomes the new top node.
  Otherwise, if arguments are given, they are treated as the new list of
  children for the top node.
  
  =cut
  
  sub top {
     my $self = shift;
     if (@_ > 0) {
        @{ $self } = (@_ == 1  and  ref $_[0]) ? ${ @_ } : @_;
     }
     return $self;
  }
  
  ## let parse_tree() & ptree() be aliases for the 'top' method
  *parse_tree = *ptree = \&top;
  
  ##---------------------------------------------------------------------------
  
  =head2 $ptree-E<gt>B<children()>
  
  This method gets/sets the children of the top node in the parse-tree.
  If no arguments are given, it returns the list (array) of children
  (each of which should be either a string or a B<Pod::InteriorSequence>.
  Otherwise, if arguments are given, they are treated as the new list of
  children for the top node.
  
  =cut
  
  sub children {
     my $self = shift;
     if (@_ > 0) {
        @{ $self } = (@_ == 1  and  ref $_[0]) ? ${ @_ } : @_;
     }
     return @{ $self };
  }
  
  ##---------------------------------------------------------------------------
  
  =head2 $ptree-E<gt>B<prepend()>
  
  This method prepends the given text or parse-tree to the current parse-tree.
  If the first item on the parse-tree is text and the argument is also text,
  then the text is prepended to the first item (not added as a separate string).
  Otherwise the argument is added as a new string or parse-tree I<before>
  the current one.
  
  =cut
  
  use vars qw(@ptree);  ## an alias used for performance reasons
  
  sub prepend {
     my $self = shift;
     local *ptree = $self;
     for (@_) {
        next  unless length;
        if (@ptree && !(ref $ptree[0]) && !(ref $_)) {
           $ptree[0] = $_ . $ptree[0];
        }
        else {
           unshift @ptree, $_;
        }
     }
  }
  
  ##---------------------------------------------------------------------------
  
  =head2 $ptree-E<gt>B<append()>
  
  This method appends the given text or parse-tree to the current parse-tree.
  If the last item on the parse-tree is text and the argument is also text,
  then the text is appended to the last item (not added as a separate string).
  Otherwise the argument is added as a new string or parse-tree I<after>
  the current one.
  
  =cut
  
  sub append {
     my $self = shift;
     local *ptree = $self;
     my $can_append = @ptree && !(ref $ptree[-1]);
     for (@_) {
        if (ref) {
           push @ptree, $_;
        }
        elsif(!length) {
           next;
        }
        elsif ($can_append) {
           $ptree[-1] .= $_;
        }
        else {
           push @ptree, $_;
        }
     }
  }
  
  =head2 $ptree-E<gt>B<raw_text()>
  
          my $ptree_raw_text = $ptree->raw_text();
  
  This method will return the I<raw> text of the POD parse-tree
  exactly as it appeared in the input.
  
  =cut
  
  sub raw_text {
     my $self = shift;
     my $text = '';
     for ( @$self ) {
        $text .= (ref $_) ? $_->raw_text : $_;
     }
     return $text;
  }
  
  ##---------------------------------------------------------------------------
  
  ## Private routines to set/unset child->parent links
  
  sub _unset_child2parent_links {
     my $self = shift;
     local *ptree = $self;
     for (@ptree) {
         next  unless (defined and length  and  ref  and  ref ne 'SCALAR');
         $_->_unset_child2parent_links()
             if UNIVERSAL::isa($_, 'Pod::InteriorSequence');
     }
  }
  
  sub _set_child2parent_links {
      ## nothing to do, Pod::ParseTrees cant have parent pointers
  }
  
  =head2 Pod::ParseTree::B<DESTROY()>
  
  This method performs any necessary cleanup for the parse-tree.
  If you override this method then it is B<imperative>
  that you invoke the parent method from within your own method,
  otherwise I<parse-tree storage will not be reclaimed upon destruction!>
  
  =cut
  
  sub DESTROY {
     ## We need to get rid of all child->parent pointers throughout the
     ## tree so their reference counts will go to zero and they can be
     ## garbage-collected
     _unset_child2parent_links(@_);
  }
  
  #############################################################################
  
  =head1 SEE ALSO
  
  B<Pod::InputObjects> is part of the L<Pod::Parser> distribution.
  
  See L<Pod::Parser>, L<Pod::Select>
  
  =head1 AUTHOR
  
  Please report bugs using L<http://rt.cpan.org>.
  
  Brad Appleton E<lt>bradapp@enteract.comE<gt>
  
  =cut
  
  1;
POD_INPUTOBJECTS

$fatpacked{"Pod/ParseUtils.pm"} = <<'POD_PARSEUTILS';
  #############################################################################
  # Pod/ParseUtils.pm -- helpers for POD parsing and conversion
  #
  # Copyright (C) 1999-2000 by Marek Rouchal. All rights reserved.
  # This file is part of "PodParser". PodParser is free software;
  # you can redistribute it and/or modify it under the same terms
  # as Perl itself.
  #############################################################################
  
  package Pod::ParseUtils;
  use strict;
  
  use vars qw($VERSION);
  $VERSION = '1.51'; ## Current version of this package
  require  5.005;    ## requires this Perl version or later
  
  =head1 NAME
  
  Pod::ParseUtils - helpers for POD parsing and conversion
  
  =head1 SYNOPSIS
  
    use Pod::ParseUtils;
  
    my $list = new Pod::List;
    my $link = Pod::Hyperlink->new('Pod::Parser');
  
  =head1 DESCRIPTION
  
  B<Pod::ParseUtils> contains a few object-oriented helper packages for
  POD parsing and processing (i.e. in POD formatters and translators).
  
  =cut
  
  #-----------------------------------------------------------------------------
  # Pod::List
  #
  # class to hold POD list info (=over, =item, =back)
  #-----------------------------------------------------------------------------
  
  package Pod::List;
  
  use Carp;
  
  =head2 Pod::List
  
  B<Pod::List> can be used to hold information about POD lists
  (written as =over ... =item ... =back) for further processing.
  The following methods are available:
  
  =over 4
  
  =item Pod::List-E<gt>new()
  
  Create a new list object. Properties may be specified through a hash
  reference like this:
  
    my $list = Pod::List->new({ -start => $., -indent => 4 });
  
  See the individual methods/properties for details.
  
  =cut
  
  sub new {
      my $this = shift;
      my $class = ref($this) || $this;
      my %params = @_;
      my $self = {%params};
      bless $self, $class;
      $self->initialize();
      return $self;
  }
  
  sub initialize {
      my $self = shift;
      $self->{-file} ||= 'unknown';
      $self->{-start} ||= 'unknown';
      $self->{-indent} ||= 4; # perlpod: "should be the default"
      $self->{_items} = [];
      $self->{-type} ||= '';
  }
  
  =item $list-E<gt>file()
  
  Without argument, retrieves the file name the list is in. This must
  have been set before by either specifying B<-file> in the B<new()>
  method or by calling the B<file()> method with a scalar argument.
  
  =cut
  
  # The POD file name the list appears in
  sub file {
     return (@_ > 1) ? ($_[0]->{-file} = $_[1]) : $_[0]->{-file};
  }
  
  =item $list-E<gt>start()
  
  Without argument, retrieves the line number where the list started.
  This must have been set before by either specifying B<-start> in the
  B<new()> method or by calling the B<start()> method with a scalar
  argument.
  
  =cut
  
  # The line in the file the node appears
  sub start {
     return (@_ > 1) ? ($_[0]->{-start} = $_[1]) : $_[0]->{-start};
  }
  
  =item $list-E<gt>indent()
  
  Without argument, retrieves the indent level of the list as specified
  in C<=over n>. This must have been set before by either specifying
  B<-indent> in the B<new()> method or by calling the B<indent()> method
  with a scalar argument.
  
  =cut
  
  # indent level
  sub indent {
     return (@_ > 1) ? ($_[0]->{-indent} = $_[1]) : $_[0]->{-indent};
  }
  
  =item $list-E<gt>type()
  
  Without argument, retrieves the list type, which can be an arbitrary value,
  e.g. C<OL>, C<UL>, ... when thinking the HTML way.
  This must have been set before by either specifying
  B<-type> in the B<new()> method or by calling the B<type()> method
  with a scalar argument.
  
  =cut
  
  # The type of the list (UL, OL, ...)
  sub type {
     return (@_ > 1) ? ($_[0]->{-type} = $_[1]) : $_[0]->{-type};
  }
  
  =item $list-E<gt>rx()
  
  Without argument, retrieves a regular expression for simplifying the 
  individual item strings once the list type has been determined. Usage:
  E.g. when converting to HTML, one might strip the leading number in
  an ordered list as C<E<lt>OLE<gt>> already prints numbers itself.
  This must have been set before by either specifying
  B<-rx> in the B<new()> method or by calling the B<rx()> method
  with a scalar argument.
  
  =cut
  
  # The regular expression to simplify the items
  sub rx {
     return (@_ > 1) ? ($_[0]->{-rx} = $_[1]) : $_[0]->{-rx};
  }
  
  =item $list-E<gt>item()
  
  Without argument, retrieves the array of the items in this list.
  The items may be represented by any scalar.
  If an argument has been given, it is pushed on the list of items.
  
  =cut
  
  # The individual =items of this list
  sub item {
      my ($self,$item) = @_;
      if(defined $item) {
          push(@{$self->{_items}}, $item);
          return $item;
      }
      else {
          return @{$self->{_items}};
      }
  }
  
  =item $list-E<gt>parent()
  
  Without argument, retrieves information about the parent holding this
  list, which is represented as an arbitrary scalar.
  This must have been set before by either specifying
  B<-parent> in the B<new()> method or by calling the B<parent()> method
  with a scalar argument.
  
  =cut
  
  # possibility for parsers/translators to store information about the
  # lists's parent object
  sub parent {
     return (@_ > 1) ? ($_[0]->{-parent} = $_[1]) : $_[0]->{-parent};
  }
  
  =item $list-E<gt>tag()
  
  Without argument, retrieves information about the list tag, which can be
  any scalar.
  This must have been set before by either specifying
  B<-tag> in the B<new()> method or by calling the B<tag()> method
  with a scalar argument.
  
  =back
  
  =cut
  
  # possibility for parsers/translators to store information about the
  # list's object
  sub tag {
     return (@_ > 1) ? ($_[0]->{-tag} = $_[1]) : $_[0]->{-tag};
  }
  
  #-----------------------------------------------------------------------------
  # Pod::Hyperlink
  #
  # class to manipulate POD hyperlinks (L<>)
  #-----------------------------------------------------------------------------
  
  package Pod::Hyperlink;
  
  =head2 Pod::Hyperlink
  
  B<Pod::Hyperlink> is a class for manipulation of POD hyperlinks. Usage:
  
    my $link = Pod::Hyperlink->new('alternative text|page/"section in page"');
  
  The B<Pod::Hyperlink> class is mainly designed to parse the contents of the
  C<LE<lt>...E<gt>> sequence, providing a simple interface for accessing the
  different parts of a POD hyperlink for further processing. It can also be
  used to construct hyperlinks.
  
  =over 4
  
  =item Pod::Hyperlink-E<gt>new()
  
  The B<new()> method can either be passed a set of key/value pairs or a single
  scalar value, namely the contents of a C<LE<lt>...E<gt>> sequence. An object
  of the class C<Pod::Hyperlink> is returned. The value C<undef> indicates a
  failure, the error message is stored in C<$@>.
  
  =cut
  
  use Carp;
  
  sub new {
      my $this = shift;
      my $class = ref($this) || $this;
      my $self = +{};
      bless $self, $class;
      $self->initialize();
      if(defined $_[0]) {
          if(ref($_[0])) {
              # called with a list of parameters
              %$self = %{$_[0]};
              $self->_construct_text();
          }
          else {
              # called with L<> contents
              return unless($self->parse($_[0]));
          }
      }
      return $self;
  }
  
  sub initialize {
      my $self = shift;
      $self->{-line} ||= 'undef';
      $self->{-file} ||= 'undef';
      $self->{-page} ||= '';
      $self->{-node} ||= '';
      $self->{-alttext} ||= '';
      $self->{-type} ||= 'undef';
      $self->{_warnings} = [];
  }
  
  =item $link-E<gt>parse($string)
  
  This method can be used to (re)parse a (new) hyperlink, i.e. the contents
  of a C<LE<lt>...E<gt>> sequence. The result is stored in the current object.
  Warnings are stored in the B<warnings> property.
  E.g. sections like C<LE<lt>open(2)E<gt>> are deprecated, as they do not point
  to Perl documents. C<LE<lt>DBI::foo(3p)E<gt>> is wrong as well, the manpage
  section can simply be dropped.
  
  =cut
  
  sub parse {
      my $self = shift;
      local($_) = $_[0];
      # syntax check the link and extract destination
      my ($alttext,$page,$node,$type,$quoted) = (undef,'','','',0);
  
      $self->{_warnings} = [];
  
      # collapse newlines with whitespace
      s/\s*\n+\s*/ /g;
  
      # strip leading/trailing whitespace
      if(s/^[\s\n]+//) {
          $self->warning('ignoring leading whitespace in link');
      }
      if(s/[\s\n]+$//) {
          $self->warning('ignoring trailing whitespace in link');
      }
      unless(length($_)) {
          _invalid_link('empty link');
          return;
      }
  
      ## Check for different possibilities. This is tedious and error-prone
      # we match all possibilities (alttext, page, section/item)
      #warn "DEBUG: link=$_\n";
  
      # only page
      # problem: a lot of people use (), or (1) or the like to indicate
      # man page sections. But this collides with L<func()> that is supposed
      # to point to an internal funtion...
      my $page_rx = '[\w.-]+(?:::[\w.-]+)*(?:[(](?:\d\w*|)[)]|)';
      # page name only
      if(/^($page_rx)$/o) {
          $page = $1;
          $type = 'page';
      }
      # alttext, page and "section"
      elsif(m{^(.*?)\s*[|]\s*($page_rx)\s*/\s*"(.+)"$}o) {
          ($alttext, $page, $node) = ($1, $2, $3);
          $type = 'section';
          $quoted = 1; #... therefore | and / are allowed
      }
      # alttext and page
      elsif(/^(.*?)\s*[|]\s*($page_rx)$/o) {
          ($alttext, $page) = ($1, $2);
          $type = 'page';
      }
      # alttext and "section"
      elsif(m{^(.*?)\s*[|]\s*(?:/\s*|)"(.+)"$}) {
          ($alttext, $node) = ($1,$2);
          $type = 'section';
          $quoted = 1;
      }
      # page and "section"
      elsif(m{^($page_rx)\s*/\s*"(.+)"$}o) {
          ($page, $node) = ($1, $2);
          $type = 'section';
          $quoted = 1;
      }
      # page and item
      elsif(m{^($page_rx)\s*/\s*(.+)$}o) {
          ($page, $node) = ($1, $2);
          $type = 'item';
      }
      # only "section"
      elsif(m{^/?"(.+)"$}) {
          $node = $1;
          $type = 'section';
          $quoted = 1;
      }
      # only item
      elsif(m{^\s*/(.+)$}) {
          $node = $1;
          $type = 'item';
      }
  
      # non-standard: Hyperlink with alt-text - doesn't remove protocol prefix, maybe it should?
      elsif(/^ \s* (.*?) \s* [|] \s* (\w+:[^:\s] [^\s|]*?) \s* $/ix) {
        ($alttext,$node) = ($1,$2);
        $type = 'hyperlink';
      }
  
      # non-standard: Hyperlink
      elsif(/^(\w+:[^:\s]\S*)$/i) {
          $node = $1;
          $type = 'hyperlink';
      }
      # alttext, page and item
      elsif(m{^(.*?)\s*[|]\s*($page_rx)\s*/\s*(.+)$}o) {
          ($alttext, $page, $node) = ($1, $2, $3);
          $type = 'item';
      }
      # alttext and item
      elsif(m{^(.*?)\s*[|]\s*/(.+)$}) {
          ($alttext, $node) = ($1,$2);
      }
      # must be an item or a "malformed" section (without "")
      else {
          $node = $_;
          $type = 'item';
      }
      # collapse whitespace in nodes
      $node =~ s/\s+/ /gs;
  
      # empty alternative text expands to node name
      if(defined $alttext) {
          if(!length($alttext)) {
            $alttext = $node || $page;
          }
      }
      else {
          $alttext = '';
      }
  
      if($page =~ /[(]\w*[)]$/) {
          $self->warning("(section) in '$page' deprecated");
      }
      if(!$quoted && $node =~ m{[|/]} && $type ne 'hyperlink') {
          $self->warning("node '$node' contains non-escaped | or /");
      }
      if($alttext =~ m{[|/]}) {
          $self->warning("alternative text '$node' contains non-escaped | or /");
      }
      $self->{-page} = $page;
      $self->{-node} = $node;
      $self->{-alttext} = $alttext;
      #warn "DEBUG: page=$page section=$section item=$item alttext=$alttext\n";
      $self->{-type} = $type;
      $self->_construct_text();
      1;
  }
  
  sub _construct_text {
      my $self = shift;
      my $alttext = $self->alttext();
      my $type = $self->type();
      my $section = $self->node();
      my $page = $self->page();
      my $page_ext = '';
      $page =~ s/([(]\w*[)])$// && ($page_ext = $1);
      if($alttext) {
          $self->{_text} = $alttext;
      }
      elsif($type eq 'hyperlink') {
          $self->{_text} = $section;
      }
      else {
          $self->{_text} = ($section || '') .
              (($page && $section) ? ' in ' : '') .
              "$page$page_ext";
      }
      # for being marked up later
      # use the non-standard markers P<> and Q<>, so that the resulting
      # text can be parsed by the translators. It's their job to put
      # the correct hypertext around the linktext
      if($alttext) {
          $self->{_markup} = "Q<$alttext>";
      }
      elsif($type eq 'hyperlink') {
          $self->{_markup} = "Q<$section>";
      }
      else {
          $self->{_markup} = (!$section ? '' : "Q<$section>") .
              ($page ? ($section ? ' in ':'') . "P<$page>$page_ext" : '');
      }
  }
  
  =item $link-E<gt>markup($string)
  
  Set/retrieve the textual value of the link. This string contains special
  markers C<PE<lt>E<gt>> and C<QE<lt>E<gt>> that should be expanded by the
  translator's interior sequence expansion engine to the
  formatter-specific code to highlight/activate the hyperlink. The details
  have to be implemented in the translator.
  
  =cut
  
  #' retrieve/set markuped text
  sub markup {
      return (@_ > 1) ? ($_[0]->{_markup} = $_[1]) : $_[0]->{_markup};
  }
  
  =item $link-E<gt>text()
  
  This method returns the textual representation of the hyperlink as above,
  but without markers (read only). Depending on the link type this is one of
  the following alternatives (the + and * denote the portions of the text
  that are marked up):
  
    +perl+                    L<perl>
    *$|* in +perlvar+         L<perlvar/$|>
    *OPTIONS* in +perldoc+    L<perldoc/"OPTIONS">
    *DESCRIPTION*             L<"DESCRIPTION">
  
  =cut
  
  # The complete link's text
  sub text {
      return $_[0]->{_text};
  }
  
  =item $link-E<gt>warning()
  
  After parsing, this method returns any warnings encountered during the
  parsing process.
  
  =cut
  
  # Set/retrieve warnings
  sub warning {
      my $self = shift;
      if(@_) {
          push(@{$self->{_warnings}}, @_);
          return @_;
      }
      return @{$self->{_warnings}};
  }
  
  =item $link-E<gt>file()
  
  =item $link-E<gt>line()
  
  Just simple slots for storing information about the line and the file
  the link was encountered in. Has to be filled in manually.
  
  =cut
  
  # The line in the file the link appears
  sub line {
      return (@_ > 1) ? ($_[0]->{-line} = $_[1]) : $_[0]->{-line};
  }
  
  # The POD file name the link appears in
  sub file {
      return (@_ > 1) ? ($_[0]->{-file} = $_[1]) : $_[0]->{-file};
  }
  
  =item $link-E<gt>page()
  
  This method sets or returns the POD page this link points to.
  
  =cut
  
  # The POD page the link appears on
  sub page {
      if (@_ > 1) {
          $_[0]->{-page} = $_[1];
          $_[0]->_construct_text();
      }
      return $_[0]->{-page};
  }
  
  =item $link-E<gt>node()
  
  As above, but the destination node text of the link.
  
  =cut
  
  # The link destination
  sub node {
      if (@_ > 1) {
          $_[0]->{-node} = $_[1];
          $_[0]->_construct_text();
      }
      return $_[0]->{-node};
  }
  
  =item $link-E<gt>alttext()
  
  Sets or returns an alternative text specified in the link.
  
  =cut
  
  # Potential alternative text
  sub alttext {
      if (@_ > 1) {
          $_[0]->{-alttext} = $_[1];
          $_[0]->_construct_text();
      }
      return $_[0]->{-alttext};
  }
  
  =item $link-E<gt>type()
  
  The node type, either C<section> or C<item>. As an unofficial type,
  there is also C<hyperlink>, derived from e.g. C<LE<lt>http://perl.comE<gt>>
  
  =cut
  
  # The type: item or headn
  sub type {
      return (@_ > 1) ? ($_[0]->{-type} = $_[1]) : $_[0]->{-type};
  }
  
  =item $link-E<gt>link()
  
  Returns the link as contents of C<LE<lt>E<gt>>. Reciprocal to B<parse()>.
  
  =back
  
  =cut
  
  # The link itself
  sub link {
      my $self = shift;
      my $link = $self->page() || '';
      if($self->node()) {
          my $node = $self->node();
          $node =~ s/\|/E<verbar>/g;
          $node =~ s{/}{E<sol>}g;
          if($self->type() eq 'section') {
              $link .= ($link ? '/' : '') . '"' . $node . '"';
          }
          elsif($self->type() eq 'hyperlink') {
              $link = $self->node();
          }
          else { # item
              $link .= '/' . $node;
          }
      }
      if($self->alttext()) {
          my $text = $self->alttext();
          $text =~ s/\|/E<verbar>/g;
          $text =~ s{/}{E<sol>}g;
          $link = "$text|$link";
      }
      return $link;
  }
  
  sub _invalid_link {
      my ($msg) = @_;
      # this sets @_
      #eval { die "$msg\n" };
      #chomp $@;
      $@ = $msg; # this seems to work, too!
      return;
  }
  
  #-----------------------------------------------------------------------------
  # Pod::Cache
  #
  # class to hold POD page details
  #-----------------------------------------------------------------------------
  
  package Pod::Cache;
  
  =head2 Pod::Cache
  
  B<Pod::Cache> holds information about a set of POD documents,
  especially the nodes for hyperlinks.
  The following methods are available:
  
  =over 4
  
  =item Pod::Cache-E<gt>new()
  
  Create a new cache object. This object can hold an arbitrary number of
  POD documents of class Pod::Cache::Item.
  
  =cut
  
  sub new {
      my $this = shift;
      my $class = ref($this) || $this;
      my $self = [];
      bless $self, $class;
      return $self;
  }
  
  =item $cache-E<gt>item()
  
  Add a new item to the cache. Without arguments, this method returns a
  list of all cache elements.
  
  =cut
  
  sub item {
      my ($self,%param) = @_;
      if(%param) {
          my $item = Pod::Cache::Item->new(%param);
          push(@$self, $item);
          return $item;
      }
      else {
          return @{$self};
      }
  }
  
  =item $cache-E<gt>find_page($name)
  
  Look for a POD document named C<$name> in the cache. Returns the
  reference to the corresponding Pod::Cache::Item object or undef if
  not found.
  
  =back
  
  =cut
  
  sub find_page {
      my ($self,$page) = @_;
      foreach(@$self) {
          if($_->page() eq $page) {
              return $_;
          }
      }
      return;
  }
  
  package Pod::Cache::Item;
  
  =head2 Pod::Cache::Item
  
  B<Pod::Cache::Item> holds information about individual POD documents,
  that can be grouped in a Pod::Cache object.
  It is intended to hold information about the hyperlink nodes of POD
  documents.
  The following methods are available:
  
  =over 4
  
  =item Pod::Cache::Item-E<gt>new()
  
  Create a new object.
  
  =cut
  
  sub new {
      my $this = shift;
      my $class = ref($this) || $this;
      my %params = @_;
      my $self = {%params};
      bless $self, $class;
      $self->initialize();
      return $self;
  }
  
  sub initialize {
      my $self = shift;
      $self->{-nodes} = [] unless(defined $self->{-nodes});
  }
  
  =item $cacheitem-E<gt>page()
  
  Set/retrieve the POD document name (e.g. "Pod::Parser").
  
  =cut
  
  # The POD page
  sub page {
     return (@_ > 1) ? ($_[0]->{-page} = $_[1]) : $_[0]->{-page};
  }
  
  =item $cacheitem-E<gt>description()
  
  Set/retrieve the POD short description as found in the C<=head1 NAME>
  section.
  
  =cut
  
  # The POD description, taken out of NAME if present
  sub description {
     return (@_ > 1) ? ($_[0]->{-description} = $_[1]) : $_[0]->{-description};
  }
  
  =item $cacheitem-E<gt>path()
  
  Set/retrieve the POD file storage path.
  
  =cut
  
  # The file path
  sub path {
     return (@_ > 1) ? ($_[0]->{-path} = $_[1]) : $_[0]->{-path};
  }
  
  =item $cacheitem-E<gt>file()
  
  Set/retrieve the POD file name.
  
  =cut
  
  # The POD file name
  sub file {
     return (@_ > 1) ? ($_[0]->{-file} = $_[1]) : $_[0]->{-file};
  }
  
  =item $cacheitem-E<gt>nodes()
  
  Add a node (or a list of nodes) to the document's node list. Note that
  the order is kept, i.e. start with the first node and end with the last.
  If no argument is given, the current list of nodes is returned in the
  same order the nodes have been added.
  A node can be any scalar, but usually is a pair of node string and
  unique id for the C<find_node> method to work correctly.
  
  =cut
  
  # The POD nodes
  sub nodes {
      my ($self,@nodes) = @_;
      if(@nodes) {
          push(@{$self->{-nodes}}, @nodes);
          return @nodes;
      }
      else {
          return @{$self->{-nodes}};
      }
  }
  
  =item $cacheitem-E<gt>find_node($name)
  
  Look for a node or index entry named C<$name> in the object.
  Returns the unique id of the node (i.e. the second element of the array
  stored in the node array) or undef if not found.
  
  =cut
  
  sub find_node {
      my ($self,$node) = @_;
      my @search;
      push(@search, @{$self->{-nodes}}) if($self->{-nodes});
      push(@search, @{$self->{-idx}}) if($self->{-idx});
      foreach(@search) {
          if($_->[0] eq $node) {
              return $_->[1]; # id
          }
      }
      return;
  }
  
  =item $cacheitem-E<gt>idx()
  
  Add an index entry (or a list of them) to the document's index list. Note that
  the order is kept, i.e. start with the first node and end with the last.
  If no argument is given, the current list of index entries is returned in the
  same order the entries have been added.
  An index entry can be any scalar, but usually is a pair of string and
  unique id.
  
  =back
  
  =cut
  
  # The POD index entries
  sub idx {
      my ($self,@idx) = @_;
      if(@idx) {
          push(@{$self->{-idx}}, @idx);
          return @idx;
      }
      else {
          return @{$self->{-idx}};
      }
  }
  
  =head1 AUTHOR
  
  Please report bugs using L<http://rt.cpan.org>.
  
  Marek Rouchal E<lt>marekr@cpan.orgE<gt>, borrowing
  a lot of things from L<pod2man> and L<pod2roff> as well as other POD
  processing tools by Tom Christiansen, Brad Appleton and Russ Allbery.
  
  B<Pod::ParseUtils> is part of the L<Pod::Parser> distribution.
  
  =head1 SEE ALSO
  
  L<pod2man>, L<pod2roff>, L<Pod::Parser>, L<Pod::Checker>,
  L<pod2html>
  
  =cut
  
  1;
POD_PARSEUTILS

$fatpacked{"Pod/Parser.pm"} = <<'POD_PARSER';
  #############################################################################
  # Pod/Parser.pm -- package which defines a base class for parsing POD docs.
  #
  # Copyright (C) 1996-2000 by Bradford Appleton. All rights reserved.
  # This file is part of "PodParser". PodParser is free software;
  # you can redistribute it and/or modify it under the same terms
  # as Perl itself.
  #############################################################################
  
  package Pod::Parser;
  use strict;
  
  ## These "variables" are used as local "glob aliases" for performance
  use vars qw($VERSION @ISA %myData %myOpts @input_stack);
  $VERSION = '1.51';  ## Current version of this package
  require  5.005;    ## requires this Perl version or later
  
  #############################################################################
  
  =head1 NAME
  
  Pod::Parser - base class for creating POD filters and translators
  
  =head1 SYNOPSIS
  
      use Pod::Parser;
  
      package MyParser;
      @ISA = qw(Pod::Parser);
  
      sub command { 
          my ($parser, $command, $paragraph, $line_num) = @_;
          ## Interpret the command and its text; sample actions might be:
          if ($command eq 'head1') { ... }
          elsif ($command eq 'head2') { ... }
          ## ... other commands and their actions
          my $out_fh = $parser->output_handle();
          my $expansion = $parser->interpolate($paragraph, $line_num);
          print $out_fh $expansion;
      }
  
      sub verbatim { 
          my ($parser, $paragraph, $line_num) = @_;
          ## Format verbatim paragraph; sample actions might be:
          my $out_fh = $parser->output_handle();
          print $out_fh $paragraph;
      }
  
      sub textblock { 
          my ($parser, $paragraph, $line_num) = @_;
          ## Translate/Format this block of text; sample actions might be:
          my $out_fh = $parser->output_handle();
          my $expansion = $parser->interpolate($paragraph, $line_num);
          print $out_fh $expansion;
      }
  
      sub interior_sequence { 
          my ($parser, $seq_command, $seq_argument) = @_;
          ## Expand an interior sequence; sample actions might be:
          return "*$seq_argument*"     if ($seq_command eq 'B');
          return "`$seq_argument'"     if ($seq_command eq 'C');
          return "_${seq_argument}_'"  if ($seq_command eq 'I');
          ## ... other sequence commands and their resulting text
      }
  
      package main;
  
      ## Create a parser object and have it parse file whose name was
      ## given on the command-line (use STDIN if no files were given).
      $parser = new MyParser();
      $parser->parse_from_filehandle(\*STDIN)  if (@ARGV == 0);
      for (@ARGV) { $parser->parse_from_file($_); }
  
  =head1 REQUIRES
  
  perl5.005, Pod::InputObjects, Exporter, Symbol, Carp
  
  =head1 EXPORTS
  
  Nothing.
  
  =head1 DESCRIPTION
  
  B<Pod::Parser> is a base class for creating POD filters and translators.
  It handles most of the effort involved with parsing the POD sections
  from an input stream, leaving subclasses free to be concerned only with
  performing the actual translation of text.
  
  B<Pod::Parser> parses PODs, and makes method calls to handle the various
  components of the POD. Subclasses of B<Pod::Parser> override these methods
  to translate the POD into whatever output format they desire.
  
  =head1 QUICK OVERVIEW
  
  To create a POD filter for translating POD documentation into some other
  format, you create a subclass of B<Pod::Parser> which typically overrides
  just the base class implementation for the following methods:
  
  =over 2
  
  =item *
  
  B<command()>
  
  =item *
  
  B<verbatim()>
  
  =item *
  
  B<textblock()>
  
  =item *
  
  B<interior_sequence()>
  
  =back
  
  You may also want to override the B<begin_input()> and B<end_input()>
  methods for your subclass (to perform any needed per-file and/or
  per-document initialization or cleanup).
  
  If you need to perform any preprocessing of input before it is parsed
  you may want to override one or more of B<preprocess_line()> and/or
  B<preprocess_paragraph()>.
  
  Sometimes it may be necessary to make more than one pass over the input
  files. If this is the case you have several options. You can make the
  first pass using B<Pod::Parser> and override your methods to store the
  intermediate results in memory somewhere for the B<end_pod()> method to
  process. You could use B<Pod::Parser> for several passes with an
  appropriate state variable to control the operation for each pass. If
  your input source can't be reset to start at the beginning, you can
  store it in some other structure as a string or an array and have that
  structure implement a B<getline()> method (which is all that
  B<parse_from_filehandle()> uses to read input).
  
  Feel free to add any member data fields you need to keep track of things
  like current font, indentation, horizontal or vertical position, or
  whatever else you like. Be sure to read L<"PRIVATE METHODS AND DATA">
  to avoid name collisions.
  
  For the most part, the B<Pod::Parser> base class should be able to
  do most of the input parsing for you and leave you free to worry about
  how to interpret the commands and translate the result.
  
  Note that all we have described here in this quick overview is the
  simplest most straightforward use of B<Pod::Parser> to do stream-based
  parsing. It is also possible to use the B<Pod::Parser::parse_text> function
  to do more sophisticated tree-based parsing. See L<"TREE-BASED PARSING">.
  
  =head1 PARSING OPTIONS
  
  A I<parse-option> is simply a named option of B<Pod::Parser> with a
  value that corresponds to a certain specified behavior. These various
  behaviors of B<Pod::Parser> may be enabled/disabled by setting
  or unsetting one or more I<parse-options> using the B<parseopts()> method.
  The set of currently accepted parse-options is as follows:
  
  =over 3
  
  =item B<-want_nonPODs> (default: unset)
  
  Normally (by default) B<Pod::Parser> will only provide access to
  the POD sections of the input. Input paragraphs that are not part
  of the POD-format documentation are not made available to the caller
  (not even using B<preprocess_paragraph()>). Setting this option to a
  non-empty, non-zero value will allow B<preprocess_paragraph()> to see
  non-POD sections of the input as well as POD sections. The B<cutting()>
  method can be used to determine if the corresponding paragraph is a POD
  paragraph, or some other input paragraph.
  
  =item B<-process_cut_cmd> (default: unset)
  
  Normally (by default) B<Pod::Parser> handles the C<=cut> POD directive
  by itself and does not pass it on to the caller for processing. Setting
  this option to a non-empty, non-zero value will cause B<Pod::Parser> to
  pass the C<=cut> directive to the caller just like any other POD command
  (and hence it may be processed by the B<command()> method).
  
  B<Pod::Parser> will still interpret the C<=cut> directive to mean that
  "cutting mode" has been (re)entered, but the caller will get a chance
  to capture the actual C<=cut> paragraph itself for whatever purpose
  it desires.
  
  =item B<-warnings> (default: unset)
  
  Normally (by default) B<Pod::Parser> recognizes a bare minimum of
  pod syntax errors and warnings and issues diagnostic messages
  for errors, but not for warnings. (Use B<Pod::Checker> to do more
  thorough checking of POD syntax.) Setting this option to a non-empty,
  non-zero value will cause B<Pod::Parser> to issue diagnostics for
  the few warnings it recognizes as well as the errors.
  
  =back
  
  Please see L<"parseopts()"> for a complete description of the interface
  for the setting and unsetting of parse-options.
  
  =cut
  
  #############################################################################
  
  #use diagnostics;
  use Pod::InputObjects;
  use Carp;
  use Exporter;
  BEGIN {
     if ($] < 5.006) {
        require Symbol;
        import Symbol;
     }
  }
  @ISA = qw(Exporter);
  
  #############################################################################
  
  =head1 RECOMMENDED SUBROUTINE/METHOD OVERRIDES
  
  B<Pod::Parser> provides several methods which most subclasses will probably
  want to override. These methods are as follows:
  
  =cut
  
  ##---------------------------------------------------------------------------
  
  =head1 B<command()>
  
              $parser->command($cmd,$text,$line_num,$pod_para);
  
  This method should be overridden by subclasses to take the appropriate
  action when a POD command paragraph (denoted by a line beginning with
  "=") is encountered. When such a POD directive is seen in the input,
  this method is called and is passed:
  
  =over 3
  
  =item C<$cmd>
  
  the name of the command for this POD paragraph
  
  =item C<$text>
  
  the paragraph text for the given POD paragraph command.
  
  =item C<$line_num>
  
  the line-number of the beginning of the paragraph
  
  =item C<$pod_para>
  
  a reference to a C<Pod::Paragraph> object which contains further
  information about the paragraph command (see L<Pod::InputObjects>
  for details).
  
  =back
  
  B<Note> that this method I<is> called for C<=pod> paragraphs.
  
  The base class implementation of this method simply treats the raw POD
  command as normal block of paragraph text (invoking the B<textblock()>
  method with the command paragraph).
  
  =cut
  
  sub command {
      my ($self, $cmd, $text, $line_num, $pod_para)  = @_;
      ## Just treat this like a textblock
      $self->textblock($pod_para->raw_text(), $line_num, $pod_para);
  }
  
  ##---------------------------------------------------------------------------
  
  =head1 B<verbatim()>
  
              $parser->verbatim($text,$line_num,$pod_para);
  
  This method may be overridden by subclasses to take the appropriate
  action when a block of verbatim text is encountered. It is passed the
  following parameters:
  
  =over 3
  
  =item C<$text>
  
  the block of text for the verbatim paragraph
  
  =item C<$line_num>
  
  the line-number of the beginning of the paragraph
  
  =item C<$pod_para>
  
  a reference to a C<Pod::Paragraph> object which contains further
  information about the paragraph (see L<Pod::InputObjects>
  for details).
  
  =back
  
  The base class implementation of this method simply prints the textblock
  (unmodified) to the output filehandle.
  
  =cut
  
  sub verbatim {
      my ($self, $text, $line_num, $pod_para) = @_;
      my $out_fh = $self->{_OUTPUT};
      print $out_fh $text;
  }
  
  ##---------------------------------------------------------------------------
  
  =head1 B<textblock()>
  
              $parser->textblock($text,$line_num,$pod_para);
  
  This method may be overridden by subclasses to take the appropriate
  action when a normal block of POD text is encountered (although the base
  class method will usually do what you want). It is passed the following
  parameters:
  
  =over 3
  
  =item C<$text>
  
  the block of text for the a POD paragraph
  
  =item C<$line_num>
  
  the line-number of the beginning of the paragraph
  
  =item C<$pod_para>
  
  a reference to a C<Pod::Paragraph> object which contains further
  information about the paragraph (see L<Pod::InputObjects>
  for details).
  
  =back
  
  In order to process interior sequences, subclasses implementations of
  this method will probably want to invoke either B<interpolate()> or
  B<parse_text()>, passing it the text block C<$text>, and the corresponding
  line number in C<$line_num>, and then perform any desired processing upon
  the returned result.
  
  The base class implementation of this method simply prints the text block
  as it occurred in the input stream).
  
  =cut
  
  sub textblock {
      my ($self, $text, $line_num, $pod_para) = @_;
      my $out_fh = $self->{_OUTPUT};
      print $out_fh $self->interpolate($text, $line_num);
  }
  
  ##---------------------------------------------------------------------------
  
  =head1 B<interior_sequence()>
  
              $parser->interior_sequence($seq_cmd,$seq_arg,$pod_seq);
  
  This method should be overridden by subclasses to take the appropriate
  action when an interior sequence is encountered. An interior sequence is
  an embedded command within a block of text which appears as a command
  name (usually a single uppercase character) followed immediately by a
  string of text which is enclosed in angle brackets. This method is
  passed the sequence command C<$seq_cmd> and the corresponding text
  C<$seq_arg>. It is invoked by the B<interpolate()> method for each interior
  sequence that occurs in the string that it is passed. It should return
  the desired text string to be used in place of the interior sequence.
  The C<$pod_seq> argument is a reference to a C<Pod::InteriorSequence>
  object which contains further information about the interior sequence.
  Please see L<Pod::InputObjects> for details if you need to access this
  additional information.
  
  Subclass implementations of this method may wish to invoke the 
  B<nested()> method of C<$pod_seq> to see if it is nested inside
  some other interior-sequence (and if so, which kind).
  
  The base class implementation of the B<interior_sequence()> method
  simply returns the raw text of the interior sequence (as it occurred
  in the input) to the caller.
  
  =cut
  
  sub interior_sequence {
      my ($self, $seq_cmd, $seq_arg, $pod_seq) = @_;
      ## Just return the raw text of the interior sequence
      return  $pod_seq->raw_text();
  }
  
  #############################################################################
  
  =head1 OPTIONAL SUBROUTINE/METHOD OVERRIDES
  
  B<Pod::Parser> provides several methods which subclasses may want to override
  to perform any special pre/post-processing. These methods do I<not> have to
  be overridden, but it may be useful for subclasses to take advantage of them.
  
  =cut
  
  ##---------------------------------------------------------------------------
  
  =head1 B<new()>
  
              my $parser = Pod::Parser->new();
  
  This is the constructor for B<Pod::Parser> and its subclasses. You
  I<do not> need to override this method! It is capable of constructing
  subclass objects as well as base class objects, provided you use
  any of the following constructor invocation styles:
  
      my $parser1 = MyParser->new();
      my $parser2 = new MyParser();
      my $parser3 = $parser2->new();
  
  where C<MyParser> is some subclass of B<Pod::Parser>.
  
  Using the syntax C<MyParser::new()> to invoke the constructor is I<not>
  recommended, but if you insist on being able to do this, then the
  subclass I<will> need to override the B<new()> constructor method. If
  you do override the constructor, you I<must> be sure to invoke the
  B<initialize()> method of the newly blessed object.
  
  Using any of the above invocations, the first argument to the
  constructor is always the corresponding package name (or object
  reference). No other arguments are required, but if desired, an
  associative array (or hash-table) my be passed to the B<new()>
  constructor, as in:
  
      my $parser1 = MyParser->new( MYDATA => $value1, MOREDATA => $value2 );
      my $parser2 = new MyParser( -myflag => 1 );
  
  All arguments passed to the B<new()> constructor will be treated as
  key/value pairs in a hash-table. The newly constructed object will be
  initialized by copying the contents of the given hash-table (which may
  have been empty). The B<new()> constructor for this class and all of its
  subclasses returns a blessed reference to the initialized object (hash-table).
  
  =cut
  
  sub new {
      ## Determine if we were called via an object-ref or a classname
      my ($this,%params) = @_;
      my $class = ref($this) || $this;
      ## Any remaining arguments are treated as initial values for the
      ## hash that is used to represent this object.
      my $self = { %params };
      ## Bless ourselves into the desired class and perform any initialization
      bless $self, $class;
      $self->initialize();
      return $self;
  }
  
  ##---------------------------------------------------------------------------
  
  =head1 B<initialize()>
  
              $parser->initialize();
  
  This method performs any necessary object initialization. It takes no
  arguments (other than the object instance of course, which is typically
  copied to a local variable named C<$self>). If subclasses override this
  method then they I<must> be sure to invoke C<$self-E<gt>SUPER::initialize()>.
  
  =cut
  
  sub initialize {
      #my $self = shift;
      #return;
  }
  
  ##---------------------------------------------------------------------------
  
  =head1 B<begin_pod()>
  
              $parser->begin_pod();
  
  This method is invoked at the beginning of processing for each POD
  document that is encountered in the input. Subclasses should override
  this method to perform any per-document initialization.
  
  =cut
  
  sub begin_pod {
      #my $self = shift;
      #return;
  }
  
  ##---------------------------------------------------------------------------
  
  =head1 B<begin_input()>
  
              $parser->begin_input();
  
  This method is invoked by B<parse_from_filehandle()> immediately I<before>
  processing input from a filehandle. The base class implementation does
  nothing, however, subclasses may override it to perform any per-file
  initializations.
  
  Note that if multiple files are parsed for a single POD document
  (perhaps the result of some future C<=include> directive) this method
  is invoked for every file that is parsed. If you wish to perform certain
  initializations once per document, then you should use B<begin_pod()>.
  
  =cut
  
  sub begin_input {
      #my $self = shift;
      #return;
  }
  
  ##---------------------------------------------------------------------------
  
  =head1 B<end_input()>
  
              $parser->end_input();
  
  This method is invoked by B<parse_from_filehandle()> immediately I<after>
  processing input from a filehandle. The base class implementation does
  nothing, however, subclasses may override it to perform any per-file
  cleanup actions.
  
  Please note that if multiple files are parsed for a single POD document
  (perhaps the result of some kind of C<=include> directive) this method
  is invoked for every file that is parsed. If you wish to perform certain
  cleanup actions once per document, then you should use B<end_pod()>.
  
  =cut
  
  sub end_input {
      #my $self = shift;
      #return;
  }
  
  ##---------------------------------------------------------------------------
  
  =head1 B<end_pod()>
  
              $parser->end_pod();
  
  This method is invoked at the end of processing for each POD document
  that is encountered in the input. Subclasses should override this method
  to perform any per-document finalization.
  
  =cut
  
  sub end_pod {
      #my $self = shift;
      #return;
  }
  
  ##---------------------------------------------------------------------------
  
  =head1 B<preprocess_line()>
  
            $textline = $parser->preprocess_line($text, $line_num);
  
  This method should be overridden by subclasses that wish to perform
  any kind of preprocessing for each I<line> of input (I<before> it has
  been determined whether or not it is part of a POD paragraph). The
  parameter C<$text> is the input line; and the parameter C<$line_num> is
  the line number of the corresponding text line.
  
  The value returned should correspond to the new text to use in its
  place.  If the empty string or an undefined value is returned then no
  further processing will be performed for this line.
  
  Please note that the B<preprocess_line()> method is invoked I<before>
  the B<preprocess_paragraph()> method. After all (possibly preprocessed)
  lines in a paragraph have been assembled together and it has been
  determined that the paragraph is part of the POD documentation from one
  of the selected sections, then B<preprocess_paragraph()> is invoked.
  
  The base class implementation of this method returns the given text.
  
  =cut
  
  sub preprocess_line {
      my ($self, $text, $line_num) = @_;
      return  $text;
  }
  
  ##---------------------------------------------------------------------------
  
  =head1 B<preprocess_paragraph()>
  
              $textblock = $parser->preprocess_paragraph($text, $line_num);
  
  This method should be overridden by subclasses that wish to perform any
  kind of preprocessing for each block (paragraph) of POD documentation
  that appears in the input stream. The parameter C<$text> is the POD
  paragraph from the input file; and the parameter C<$line_num> is the
  line number for the beginning of the corresponding paragraph.
  
  The value returned should correspond to the new text to use in its
  place If the empty string is returned or an undefined value is
  returned, then the given C<$text> is ignored (not processed).
  
  This method is invoked after gathering up all the lines in a paragraph
  and after determining the cutting state of the paragraph,
  but before trying to further parse or interpret them. After
  B<preprocess_paragraph()> returns, the current cutting state (which
  is returned by C<$self-E<gt>cutting()>) is examined. If it evaluates
  to true then input text (including the given C<$text>) is cut (not
  processed) until the next POD directive is encountered.
  
  Please note that the B<preprocess_line()> method is invoked I<before>
  the B<preprocess_paragraph()> method. After all (possibly preprocessed)
  lines in a paragraph have been assembled together and either it has been
  determined that the paragraph is part of the POD documentation from one
  of the selected sections or the C<-want_nonPODs> option is true,
  then B<preprocess_paragraph()> is invoked.
  
  The base class implementation of this method returns the given text.
  
  =cut
  
  sub preprocess_paragraph {
      my ($self, $text, $line_num) = @_;
      return  $text;
  }
  
  #############################################################################
  
  =head1 METHODS FOR PARSING AND PROCESSING
  
  B<Pod::Parser> provides several methods to process input text. These
  methods typically won't need to be overridden (and in some cases they
  can't be overridden), but subclasses may want to invoke them to exploit
  their functionality.
  
  =cut
  
  ##---------------------------------------------------------------------------
  
  =head1 B<parse_text()>
  
              $ptree1 = $parser->parse_text($text, $line_num);
              $ptree2 = $parser->parse_text({%opts}, $text, $line_num);
              $ptree3 = $parser->parse_text(\%opts, $text, $line_num);
  
  This method is useful if you need to perform your own interpolation 
  of interior sequences and can't rely upon B<interpolate> to expand
  them in simple bottom-up order.
  
  The parameter C<$text> is a string or block of text to be parsed
  for interior sequences; and the parameter C<$line_num> is the
  line number corresponding to the beginning of C<$text>.
  
  B<parse_text()> will parse the given text into a parse-tree of "nodes."
  and interior-sequences.  Each "node" in the parse tree is either a
  text-string, or a B<Pod::InteriorSequence>.  The result returned is a
  parse-tree of type B<Pod::ParseTree>. Please see L<Pod::InputObjects>
  for more information about B<Pod::InteriorSequence> and B<Pod::ParseTree>.
  
  If desired, an optional hash-ref may be specified as the first argument
  to customize certain aspects of the parse-tree that is created and
  returned. The set of recognized option keywords are:
  
  =over 3
  
  =item B<-expand_seq> =E<gt> I<code-ref>|I<method-name>
  
  Normally, the parse-tree returned by B<parse_text()> will contain an
  unexpanded C<Pod::InteriorSequence> object for each interior-sequence
  encountered. Specifying B<-expand_seq> tells B<parse_text()> to "expand"
  every interior-sequence it sees by invoking the referenced function
  (or named method of the parser object) and using the return value as the
  expanded result.
  
  If a subroutine reference was given, it is invoked as:
  
    &$code_ref( $parser, $sequence )
  
  and if a method-name was given, it is invoked as:
  
    $parser->method_name( $sequence )
  
  where C<$parser> is a reference to the parser object, and C<$sequence>
  is a reference to the interior-sequence object.
  [I<NOTE>: If the B<interior_sequence()> method is specified, then it is
  invoked according to the interface specified in L<"interior_sequence()">].
  
  =item B<-expand_text> =E<gt> I<code-ref>|I<method-name>
  
  Normally, the parse-tree returned by B<parse_text()> will contain a
  text-string for each contiguous sequence of characters outside of an
  interior-sequence. Specifying B<-expand_text> tells B<parse_text()> to
  "preprocess" every such text-string it sees by invoking the referenced
  function (or named method of the parser object) and using the return value
  as the preprocessed (or "expanded") result. [Note that if the result is
  an interior-sequence, then it will I<not> be expanded as specified by the
  B<-expand_seq> option; Any such recursive expansion needs to be handled by
  the specified callback routine.]
  
  If a subroutine reference was given, it is invoked as:
  
    &$code_ref( $parser, $text, $ptree_node )
  
  and if a method-name was given, it is invoked as:
  
    $parser->method_name( $text, $ptree_node )
  
  where C<$parser> is a reference to the parser object, C<$text> is the
  text-string encountered, and C<$ptree_node> is a reference to the current
  node in the parse-tree (usually an interior-sequence object or else the
  top-level node of the parse-tree).
  
  =item B<-expand_ptree> =E<gt> I<code-ref>|I<method-name>
  
  Rather than returning a C<Pod::ParseTree>, pass the parse-tree as an
  argument to the referenced subroutine (or named method of the parser
  object) and return the result instead of the parse-tree object.
  
  If a subroutine reference was given, it is invoked as:
  
    &$code_ref( $parser, $ptree )
  
  and if a method-name was given, it is invoked as:
  
    $parser->method_name( $ptree )
  
  where C<$parser> is a reference to the parser object, and C<$ptree>
  is a reference to the parse-tree object.
  
  =back
  
  =cut
  
  sub parse_text {
      my $self = shift;
      local $_ = '';
  
      ## Get options and set any defaults
      my %opts = (ref $_[0]) ? %{ shift() } : ();
      my $expand_seq   = $opts{'-expand_seq'}   || undef;
      my $expand_text  = $opts{'-expand_text'}  || undef;
      my $expand_ptree = $opts{'-expand_ptree'} || undef;
  
      my $text = shift;
      my $line = shift;
      my $file = $self->input_file();
      my $cmd  = "";
  
      ## Convert method calls into closures, for our convenience
      my $xseq_sub   = $expand_seq;
      my $xtext_sub  = $expand_text;
      my $xptree_sub = $expand_ptree;
      if (defined $expand_seq  and  $expand_seq eq 'interior_sequence') {
          ## If 'interior_sequence' is the method to use, we have to pass
          ## more than just the sequence object, we also need to pass the
          ## sequence name and text.
          $xseq_sub = sub {
              my ($sself, $iseq) = @_;
              my $args = join('', $iseq->parse_tree->children);
              return  $sself->interior_sequence($iseq->name, $args, $iseq);
          };
      }
      ref $xseq_sub    or  $xseq_sub   = sub { shift()->$expand_seq(@_) };
      ref $xtext_sub   or  $xtext_sub  = sub { shift()->$expand_text(@_) };
      ref $xptree_sub  or  $xptree_sub = sub { shift()->$expand_ptree(@_) };
  
      ## Keep track of the "current" interior sequence, and maintain a stack
      ## of "in progress" sequences.
      ##
      ## NOTE that we push our own "accumulator" at the very beginning of the
      ## stack. It's really a parse-tree, not a sequence; but it implements
      ## the methods we need so we can use it to gather-up all the sequences
      ## and strings we parse. Thus, by the end of our parsing, it should be
      ## the only thing left on our stack and all we have to do is return it!
      ##
      my $seq       = Pod::ParseTree->new();
      my @seq_stack = ($seq);
      my ($ldelim, $rdelim) = ('', '');
  
      ## Iterate over all sequence starts text (NOTE: split with
      ## capturing parens keeps the delimiters)
      $_ = $text;
      my @tokens = split /([A-Z]<(?:<+(?:\r?\n|[ \t]))?)/;
      while ( @tokens ) {
          $_ = shift @tokens;
          ## Look for the beginning of a sequence
          if ( /^([A-Z])(<(?:<+(?:\r?\n|[ \t]))?)$/ ) {
              ## Push a new sequence onto the stack of those "in-progress"
              my $ldelim_orig;
              ($cmd, $ldelim_orig) = ($1, $2);
              ($ldelim = $ldelim_orig) =~ s/\s+$//;
              ($rdelim = $ldelim) =~ tr/</>/;
              $seq = Pod::InteriorSequence->new(
                         -name   => $cmd,
                         -ldelim => $ldelim_orig,  -rdelim => $rdelim,
                         -file   => $file,    -line   => $line
                     );
              (@seq_stack > 1)  and  $seq->nested($seq_stack[-1]);
              push @seq_stack, $seq;
          }
          ## Look for sequence ending
          elsif ( @seq_stack > 1 ) {
              ## Make sure we match the right kind of closing delimiter
              my ($seq_end, $post_seq) = ('', '');
              if ( ($ldelim eq '<'   and  /\A(.*?)(>)/s)
                   or  /\A(.*?)(\s+$rdelim)/s )
              {
                  ## Found end-of-sequence, capture the interior and the
                  ## closing the delimiter, and put the rest back on the
                  ## token-list
                  $post_seq = substr($_, length($1) + length($2));
                  ($_, $seq_end) = ($1, $2);
                  (length $post_seq)  and  unshift @tokens, $post_seq;
              }
              if (length) {
                  ## In the middle of a sequence, append this text to it, and
                  ## dont forget to "expand" it if that's what the caller wanted
                  $seq->append($expand_text ? &$xtext_sub($self,$_,$seq) : $_);
                  $_ .= $seq_end;
              }
              if (length $seq_end) {
                  ## End of current sequence, record terminating delimiter
                  $seq->rdelim($seq_end);
                  ## Pop it off the stack of "in progress" sequences
                  pop @seq_stack;
                  ## Append result to its parent in current parse tree
                  $seq_stack[-1]->append($expand_seq ? &$xseq_sub($self,$seq)
                                                     : $seq);
                  ## Remember the current cmd-name and left-delimiter
                  if(@seq_stack > 1) {
                      $cmd = $seq_stack[-1]->name;
                      $ldelim = $seq_stack[-1]->ldelim;
                      $rdelim = $seq_stack[-1]->rdelim;
                  } else {
                      $cmd = $ldelim = $rdelim = '';
                  }
              }
          }
          elsif (length) {
              ## In the middle of a sequence, append this text to it, and
              ## dont forget to "expand" it if that's what the caller wanted
              $seq->append($expand_text ? &$xtext_sub($self,$_,$seq) : $_);
          }
          ## Keep track of line count
          $line += /\n/;
          ## Remember the "current" sequence
          $seq = $seq_stack[-1];
      }
  
      ## Handle unterminated sequences
      my $errorsub = (@seq_stack > 1) ? $self->errorsub() : undef;
      while (@seq_stack > 1) {
         ($cmd, $file, $line) = ($seq->name, $seq->file_line);
         $ldelim  = $seq->ldelim;
         ($rdelim = $ldelim) =~ tr/</>/;
         $rdelim  =~ s/^(\S+)(\s*)$/$2$1/;
         pop @seq_stack;
         my $errmsg = "*** ERROR: unterminated ${cmd}${ldelim}...${rdelim}".
                      " at line $line in file $file\n";
         (ref $errorsub) and &{$errorsub}($errmsg)
             or (defined $errorsub) and $self->$errorsub($errmsg)
                 or  carp($errmsg);
         $seq_stack[-1]->append($expand_seq ? &$xseq_sub($self,$seq) : $seq);
         $seq = $seq_stack[-1];
      }
  
      ## Return the resulting parse-tree
      my $ptree = (pop @seq_stack)->parse_tree;
      return  $expand_ptree ? &$xptree_sub($self, $ptree) : $ptree;
  }
  
  ##---------------------------------------------------------------------------
  
  =head1 B<interpolate()>
  
              $textblock = $parser->interpolate($text, $line_num);
  
  This method translates all text (including any embedded interior sequences)
  in the given text string C<$text> and returns the interpolated result. The
  parameter C<$line_num> is the line number corresponding to the beginning
  of C<$text>.
  
  B<interpolate()> merely invokes a private method to recursively expand
  nested interior sequences in bottom-up order (innermost sequences are
  expanded first). If there is a need to expand nested sequences in
  some alternate order, use B<parse_text> instead.
  
  =cut
  
  sub interpolate {
      my($self, $text, $line_num) = @_;
      my %parse_opts = ( -expand_seq => 'interior_sequence' );
      my $ptree = $self->parse_text( \%parse_opts, $text, $line_num );
      return  join '', $ptree->children();
  }
  
  ##---------------------------------------------------------------------------
  
  =begin __PRIVATE__
  
  =head1 B<parse_paragraph()>
  
              $parser->parse_paragraph($text, $line_num);
  
  This method takes the text of a POD paragraph to be processed, along
  with its corresponding line number, and invokes the appropriate method
  (one of B<command()>, B<verbatim()>, or B<textblock()>).
  
  For performance reasons, this method is invoked directly without any
  dynamic lookup; Hence subclasses may I<not> override it!
  
  =end __PRIVATE__
  
  =cut
  
  sub parse_paragraph {
      my ($self, $text, $line_num) = @_;
      local *myData = $self;  ## alias to avoid deref-ing overhead
      local *myOpts = ($myData{_PARSEOPTS} ||= {});  ## get parse-options
      local $_;
  
      ## See if we want to preprocess nonPOD paragraphs as well as POD ones.
      my $wantNonPods = $myOpts{'-want_nonPODs'};
  
      ## Update cutting status
      $myData{_CUTTING} = 0 if $text =~ /^={1,2}\S/;
  
      ## Perform any desired preprocessing if we wanted it this early
      $wantNonPods  and  $text = $self->preprocess_paragraph($text, $line_num);
  
      ## Ignore up until next POD directive if we are cutting
      return if $myData{_CUTTING};
  
      ## Now we know this is block of text in a POD section!
  
      ##-----------------------------------------------------------------
      ## This is a hook (hack ;-) for Pod::Select to do its thing without
      ## having to override methods, but also without Pod::Parser assuming
      ## $self is an instance of Pod::Select (if the _SELECTED_SECTIONS
      ## field exists then we assume there is an is_selected() method for
      ## us to invoke (calling $self->can('is_selected') could verify this
      ## but that is more overhead than I want to incur)
      ##-----------------------------------------------------------------
  
      ## Ignore this block if it isnt in one of the selected sections
      if (exists $myData{_SELECTED_SECTIONS}) {
          $self->is_selected($text)  or  return ($myData{_CUTTING} = 1);
      }
  
      ## If we havent already, perform any desired preprocessing and
      ## then re-check the "cutting" state
      unless ($wantNonPods) {
         $text = $self->preprocess_paragraph($text, $line_num);
         return 1  unless ((defined $text) and (length $text));
         return 1  if ($myData{_CUTTING});
      }
  
      ## Look for one of the three types of paragraphs
      my ($pfx, $cmd, $arg, $sep) = ('', '', '', '');
      my $pod_para = undef;
      if ($text =~ /^(={1,2})(?=\S)/) {
          ## Looks like a command paragraph. Capture the command prefix used
          ## ("=" or "=="), as well as the command-name, its paragraph text,
          ## and whatever sequence of characters was used to separate them
          $pfx = $1;
          $_ = substr($text, length $pfx);
          ($cmd, $sep, $text) = split /(\s+)/, $_, 2;
          $sep = '' unless defined $sep;
          $text = '' unless defined $text;
          ## If this is a "cut" directive then we dont need to do anything
          ## except return to "cutting" mode.
          if ($cmd eq 'cut') {
             $myData{_CUTTING} = 1;
             return  unless $myOpts{'-process_cut_cmd'};
          }
      }
      ## Save the attributes indicating how the command was specified.
      $pod_para = new Pod::Paragraph(
            -name      => $cmd,
            -text      => $text,
            -prefix    => $pfx,
            -separator => $sep,
            -file      => $myData{_INFILE},
            -line      => $line_num
      );
      # ## Invoke appropriate callbacks
      # if (exists $myData{_CALLBACKS}) {
      #    ## Look through the callback list, invoke callbacks,
      #    ## then see if we need to do the default actions
      #    ## (invoke_callbacks will return true if we do).
      #    return  1  unless $self->invoke_callbacks($cmd, $text, $line_num, $pod_para);
      # }
  
      # If the last paragraph ended in whitespace, and we're not between verbatim blocks, carp
      if ($myData{_WHITESPACE} and $myOpts{'-warnings'}
              and not ($text =~ /^\s+/ and ($myData{_PREVIOUS}||"") eq "verbatim")) {
          my $errorsub = $self->errorsub();
          my $line = $line_num - 1;
          my $errmsg = "*** WARNING: line containing nothing but whitespace".
                       " in paragraph at line $line in file $myData{_INFILE}\n";
          (ref $errorsub) and &{$errorsub}($errmsg)
              or (defined $errorsub) and $self->$errorsub($errmsg)
                  or  carp($errmsg);
      }
  
      if (length $cmd) {
          ## A command paragraph
          $self->command($cmd, $text, $line_num, $pod_para);
          $myData{_PREVIOUS} = $cmd;
      }
      elsif ($text =~ /^\s+/) {
          ## Indented text - must be a verbatim paragraph
          $self->verbatim($text, $line_num, $pod_para);
          $myData{_PREVIOUS} = "verbatim";
      }
      else {
          ## Looks like an ordinary block of text
          $self->textblock($text, $line_num, $pod_para);
          $myData{_PREVIOUS} = "textblock";
      }
  
      # Update the whitespace for the next time around
      #$myData{_WHITESPACE} = $text =~ /^[^\S\r\n]+\Z/m ? 1 : 0;
      $myData{_WHITESPACE} = $text =~ /^[^\S\r\n]+\r*\Z/m ? 1 : 0;
  
      return  1;
  }
  
  ##---------------------------------------------------------------------------
  
  =head1 B<parse_from_filehandle()>
  
              $parser->parse_from_filehandle($in_fh,$out_fh);
  
  This method takes an input filehandle (which is assumed to already be
  opened for reading) and reads the entire input stream looking for blocks
  (paragraphs) of POD documentation to be processed. If no first argument
  is given the default input filehandle C<STDIN> is used.
  
  The C<$in_fh> parameter may be any object that provides a B<getline()>
  method to retrieve a single line of input text (hence, an appropriate
  wrapper object could be used to parse PODs from a single string or an
  array of strings).
  
  Using C<$in_fh-E<gt>getline()>, input is read line-by-line and assembled
  into paragraphs or "blocks" (which are separated by lines containing
  nothing but whitespace). For each block of POD documentation
  encountered it will invoke a method to parse the given paragraph.
  
  If a second argument is given then it should correspond to a filehandle where
  output should be sent (otherwise the default output filehandle is
  C<STDOUT> if no output filehandle is currently in use).
  
  B<NOTE:> For performance reasons, this method caches the input stream at
  the top of the stack in a local variable. Any attempts by clients to
  change the stack contents during processing when in the midst executing
  of this method I<will not affect> the input stream used by the current
  invocation of this method.
  
  This method does I<not> usually need to be overridden by subclasses.
  
  =cut
  
  sub parse_from_filehandle {
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH') ? %{ shift() } : ();
      my ($in_fh, $out_fh) = @_;
      $in_fh = \*STDIN  unless ($in_fh);
      local *myData = $self;  ## alias to avoid deref-ing overhead
      local *myOpts = ($myData{_PARSEOPTS} ||= {});  ## get parse-options
      local $_;
  
      ## Put this stream at the top of the stack and do beginning-of-input
      ## processing. NOTE that $in_fh might be reset during this process.
      my $topstream = $self->_push_input_stream($in_fh, $out_fh);
      (exists $opts{-cutting})  and  $self->cutting( $opts{-cutting} );
  
      ## Initialize line/paragraph
      my ($textline, $paragraph) = ('', '');
      my ($nlines, $plines) = (0, 0);
  
      ## Use <$fh> instead of $fh->getline where possible (for speed)
      $_ = ref $in_fh;
      my $tied_fh = (/^(?:GLOB|FileHandle|IO::\w+)$/  or  tied $in_fh);
  
      ## Read paragraphs line-by-line
      while (defined ($textline = $tied_fh ? <$in_fh> : $in_fh->getline)) {
          $textline = $self->preprocess_line($textline, ++$nlines);
          next  unless ((defined $textline)  &&  (length $textline));
  
          if ((! length $paragraph) && ($textline =~ /^==/)) {
              ## '==' denotes a one-line command paragraph
              $paragraph = $textline;
              $plines    = 1;
              $textline  = '';
          } else {
              ## Append this line to the current paragraph
              $paragraph .= $textline;
              ++$plines;
          }
  
          ## See if this line is blank and ends the current paragraph.
          ## If it isnt, then keep iterating until it is.
          next unless (($textline =~ /^[^\S\r\n]*[\r\n]*$/)
                                       && (length $paragraph));
  
          ## Now process the paragraph
          parse_paragraph($self, $paragraph, ($nlines - $plines) + 1);
          $paragraph = '';
          $plines = 0;
      }
      ## Dont forget about the last paragraph in the file
      if (length $paragraph) {
         parse_paragraph($self, $paragraph, ($nlines - $plines) + 1)
      }
  
      ## Now pop the input stream off the top of the input stack.
      $self->_pop_input_stream();
  }
  
  ##---------------------------------------------------------------------------
  
  =head1 B<parse_from_file()>
  
              $parser->parse_from_file($filename,$outfile);
  
  This method takes a filename and does the following:
  
  =over 2
  
  =item *
  
  opens the input and output files for reading
  (creating the appropriate filehandles)
  
  =item *
  
  invokes the B<parse_from_filehandle()> method passing it the
  corresponding input and output filehandles.
  
  =item *
  
  closes the input and output files.
  
  =back
  
  If the special input filename "-" or "<&STDIN" is given then the STDIN
  filehandle is used for input (and no open or close is performed). If no
  input filename is specified then "-" is implied. Filehandle references,
  or objects that support the regular IO operations (like C<E<lt>$fhE<gt>>
  or C<$fh-<Egt>getline>) are also accepted; the handles must already be 
  opened.
  
  If a second argument is given then it should be the name of the desired
  output file. If the special output filename "-" or ">&STDOUT" is given
  then the STDOUT filehandle is used for output (and no open or close is
  performed). If the special output filename ">&STDERR" is given then the
  STDERR filehandle is used for output (and no open or close is
  performed). If no output filehandle is currently in use and no output
  filename is specified, then "-" is implied.
  Alternatively, filehandle references or objects that support the regular
  IO operations (like C<print>, e.g. L<IO::String>) are also accepted;
  the object must already be opened.
  
  This method does I<not> usually need to be overridden by subclasses.
  
  =cut
  
  sub parse_from_file {
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH') ? %{ shift() } : ();
      my ($infile, $outfile) = @_;
      my ($in_fh,  $out_fh);
      if ($] < 5.006) {
        ($in_fh,  $out_fh) = (gensym(), gensym());
      }
      my ($close_input, $close_output) = (0, 0);
      local *myData = $self;
      local *_;
  
      ## Is $infile a filename or a (possibly implied) filehandle
      if (defined $infile && ref $infile) {
          if (ref($infile) =~ /^(SCALAR|ARRAY|HASH|CODE|REF)$/) {
              croak "Input from $1 reference not supported!\n";
          }
          ## Must be a filehandle-ref (or else assume its a ref to an object
          ## that supports the common IO read operations).
          $myData{_INFILE} = ${$infile};
          $in_fh = $infile;
      }
      elsif (!defined($infile) || !length($infile) || ($infile eq '-')
          || ($infile =~ /^<&(?:STDIN|0)$/i))
      {
          ## Not a filename, just a string implying STDIN
          $infile ||= '-';
          $myData{_INFILE} = '<standard input>';
          $in_fh = \*STDIN;
      }
      else {
          ## We have a filename, open it for reading
          $myData{_INFILE} = $infile;
          open($in_fh, "< $infile")  or
               croak "Can't open $infile for reading: $!\n";
          $close_input = 1;
      }
  
      ## NOTE: we need to be *very* careful when "defaulting" the output
      ## file. We only want to use a default if this is the beginning of
      ## the entire document (but *not* if this is an included file). We
      ## determine this by seeing if the input stream stack has been set-up
      ## already
  
      ## Is $outfile a filename, a (possibly implied) filehandle, maybe a ref?
      if (ref $outfile) {
          ## we need to check for ref() first, as other checks involve reading
          if (ref($outfile) =~ /^(ARRAY|HASH|CODE)$/) {
              croak "Output to $1 reference not supported!\n";
          }
          elsif (ref($outfile) eq 'SCALAR') {
  #           # NOTE: IO::String isn't a part of the perl distribution,
  #           #       so probably we shouldn't support this case...
  #           require IO::String;
  #           $myData{_OUTFILE} = "$outfile";
  #           $out_fh = IO::String->new($outfile);
              croak "Output to SCALAR reference not supported!\n";
          }
          else {
              ## Must be a filehandle-ref (or else assume its a ref to an
              ## object that supports the common IO write operations).
              $myData{_OUTFILE} = ${$outfile};
              $out_fh = $outfile;
          }
      }
      elsif (!defined($outfile) || !length($outfile) || ($outfile eq '-')
          || ($outfile =~ /^>&?(?:STDOUT|1)$/i))
      {
          if (defined $myData{_TOP_STREAM}) {
              $out_fh = $myData{_OUTPUT};
          }
          else {
              ## Not a filename, just a string implying STDOUT
              $outfile ||= '-';
              $myData{_OUTFILE} = '<standard output>';
              $out_fh  = \*STDOUT;
          }
      }
      elsif ($outfile =~ /^>&(STDERR|2)$/i) {
          ## Not a filename, just a string implying STDERR
          $myData{_OUTFILE} = '<standard error>';
          $out_fh  = \*STDERR;
      }
      else {
          ## We have a filename, open it for writing
          $myData{_OUTFILE} = $outfile;
          (-d $outfile) and croak "$outfile is a directory, not POD input!\n";
          open($out_fh, "> $outfile")  or
               croak "Can't open $outfile for writing: $!\n";
          $close_output = 1;
      }
  
      ## Whew! That was a lot of work to set up reasonably/robust behavior
      ## in the case of a non-filename for reading and writing. Now we just
      ## have to parse the input and close the handles when we're finished.
      $self->parse_from_filehandle(\%opts, $in_fh, $out_fh);
  
      $close_input  and
          close($in_fh) || croak "Can't close $infile after reading: $!\n";
      $close_output  and
          close($out_fh) || croak "Can't close $outfile after writing: $!\n";
  }
  
  #############################################################################
  
  =head1 ACCESSOR METHODS
  
  Clients of B<Pod::Parser> should use the following methods to access
  instance data fields:
  
  =cut
  
  ##---------------------------------------------------------------------------
  
  =head1 B<errorsub()>
  
              $parser->errorsub("method_name");
              $parser->errorsub(\&warn_user);
              $parser->errorsub(sub { print STDERR, @_ });
  
  Specifies the method or subroutine to use when printing error messages
  about POD syntax. The supplied method/subroutine I<must> return TRUE upon
  successful printing of the message. If C<undef> is given, then the B<carp>
  builtin is used to issue error messages (this is the default behavior).
  
              my $errorsub = $parser->errorsub()
              my $errmsg = "This is an error message!\n"
              (ref $errorsub) and &{$errorsub}($errmsg)
                  or (defined $errorsub) and $parser->$errorsub($errmsg)
                      or  carp($errmsg);
  
  Returns a method name, or else a reference to the user-supplied subroutine
  used to print error messages. Returns C<undef> if the B<carp> builtin
  is used to issue error messages (this is the default behavior).
  
  =cut
  
  sub errorsub {
     return (@_ > 1) ? ($_[0]->{_ERRORSUB} = $_[1]) : $_[0]->{_ERRORSUB};
  }
  
  ##---------------------------------------------------------------------------
  
  =head1 B<cutting()>
  
              $boolean = $parser->cutting();
  
  Returns the current C<cutting> state: a boolean-valued scalar which
  evaluates to true if text from the input file is currently being "cut"
  (meaning it is I<not> considered part of the POD document).
  
              $parser->cutting($boolean);
  
  Sets the current C<cutting> state to the given value and returns the
  result.
  
  =cut
  
  sub cutting {
     return (@_ > 1) ? ($_[0]->{_CUTTING} = $_[1]) : $_[0]->{_CUTTING};
  }
  
  ##---------------------------------------------------------------------------
  
  ##---------------------------------------------------------------------------
  
  =head1 B<parseopts()>
  
  When invoked with no additional arguments, B<parseopts> returns a hashtable
  of all the current parsing options.
  
              ## See if we are parsing non-POD sections as well as POD ones
              my %opts = $parser->parseopts();
              $opts{'-want_nonPODs}' and print "-want_nonPODs\n";
  
  When invoked using a single string, B<parseopts> treats the string as the
  name of a parse-option and returns its corresponding value if it exists
  (returns C<undef> if it doesn't).
  
              ## Did we ask to see '=cut' paragraphs?
              my $want_cut = $parser->parseopts('-process_cut_cmd');
              $want_cut and print "-process_cut_cmd\n";
  
  When invoked with multiple arguments, B<parseopts> treats them as
  key/value pairs and the specified parse-option names are set to the
  given values. Any unspecified parse-options are unaffected.
  
              ## Set them back to the default
              $parser->parseopts(-warnings => 0);
  
  When passed a single hash-ref, B<parseopts> uses that hash to completely
  reset the existing parse-options, all previous parse-option values
  are lost.
  
              ## Reset all options to default 
              $parser->parseopts( { } );
  
  See L<"PARSING OPTIONS"> for more information on the name and meaning of each
  parse-option currently recognized.
  
  =cut
  
  sub parseopts {
     local *myData = shift;
     local *myOpts = ($myData{_PARSEOPTS} ||= {});
     return %myOpts  if (@_ == 0);
     if (@_ == 1) {
        local $_ = shift;
        return  ref($_)  ?  $myData{_PARSEOPTS} = $_  :  $myOpts{$_};
     }
     my @newOpts = (%myOpts, @_);
     $myData{_PARSEOPTS} = { @newOpts };
  }
  
  ##---------------------------------------------------------------------------
  
  =head1 B<output_file()>
  
              $fname = $parser->output_file();
  
  Returns the name of the output file being written.
  
  =cut
  
  sub output_file {
     return $_[0]->{_OUTFILE};
  }
  
  ##---------------------------------------------------------------------------
  
  =head1 B<output_handle()>
  
              $fhandle = $parser->output_handle();
  
  Returns the output filehandle object.
  
  =cut
  
  sub output_handle {
     return $_[0]->{_OUTPUT};
  }
  
  ##---------------------------------------------------------------------------
  
  =head1 B<input_file()>
  
              $fname = $parser->input_file();
  
  Returns the name of the input file being read.
  
  =cut
  
  sub input_file {
     return $_[0]->{_INFILE};
  }
  
  ##---------------------------------------------------------------------------
  
  =head1 B<input_handle()>
  
              $fhandle = $parser->input_handle();
  
  Returns the current input filehandle object.
  
  =cut
  
  sub input_handle {
     return $_[0]->{_INPUT};
  }
  
  ##---------------------------------------------------------------------------
  
  =begin __PRIVATE__
  
  =head1 B<input_streams()>
  
              $listref = $parser->input_streams();
  
  Returns a reference to an array which corresponds to the stack of all
  the input streams that are currently in the middle of being parsed.
  
  While parsing an input stream, it is possible to invoke
  B<parse_from_file()> or B<parse_from_filehandle()> to parse a new input
  stream and then return to parsing the previous input stream. Each input
  stream to be parsed is pushed onto the end of this input stack
  before any of its input is read. The input stream that is currently
  being parsed is always at the end (or top) of the input stack. When an
  input stream has been exhausted, it is popped off the end of the
  input stack.
  
  Each element on this input stack is a reference to C<Pod::InputSource>
  object. Please see L<Pod::InputObjects> for more details.
  
  This method might be invoked when printing diagnostic messages, for example,
  to obtain the name and line number of the all input files that are currently
  being processed.
  
  =end __PRIVATE__
  
  =cut
  
  sub input_streams {
     return $_[0]->{_INPUT_STREAMS};
  }
  
  ##---------------------------------------------------------------------------
  
  =begin __PRIVATE__
  
  =head1 B<top_stream()>
  
              $hashref = $parser->top_stream();
  
  Returns a reference to the hash-table that represents the element
  that is currently at the top (end) of the input stream stack
  (see L<"input_streams()">). The return value will be the C<undef>
  if the input stack is empty.
  
  This method might be used when printing diagnostic messages, for example,
  to obtain the name and line number of the current input file.
  
  =end __PRIVATE__
  
  =cut
  
  sub top_stream {
     return $_[0]->{_TOP_STREAM} || undef;
  }
  
  #############################################################################
  
  =head1 PRIVATE METHODS AND DATA
  
  B<Pod::Parser> makes use of several internal methods and data fields
  which clients should not need to see or use. For the sake of avoiding
  name collisions for client data and methods, these methods and fields
  are briefly discussed here. Determined hackers may obtain further
  information about them by reading the B<Pod::Parser> source code.
  
  Private data fields are stored in the hash-object whose reference is
  returned by the B<new()> constructor for this class. The names of all
  private methods and data-fields used by B<Pod::Parser> begin with a
  prefix of "_" and match the regular expression C</^_\w+$/>.
  
  =cut
  
  ##---------------------------------------------------------------------------
  
  =begin _PRIVATE_
  
  =head1 B<_push_input_stream()>
  
              $hashref = $parser->_push_input_stream($in_fh,$out_fh);
  
  This method will push the given input stream on the input stack and
  perform any necessary beginning-of-document or beginning-of-file
  processing. The argument C<$in_fh> is the input stream filehandle to
  push, and C<$out_fh> is the corresponding output filehandle to use (if
  it is not given or is undefined, then the current output stream is used,
  which defaults to standard output if it doesnt exist yet).
  
  The value returned will be reference to the hash-table that represents
  the new top of the input stream stack. I<Please Note> that it is
  possible for this method to use default values for the input and output
  file handles. If this happens, you will need to look at the C<INPUT>
  and C<OUTPUT> instance data members to determine their new values.
  
  =end _PRIVATE_
  
  =cut
  
  sub _push_input_stream {
      my ($self, $in_fh, $out_fh) = @_;
      local *myData = $self;
  
      ## Initialize stuff for the entire document if this is *not*
      ## an included file.
      ##
      ## NOTE: we need to be *very* careful when "defaulting" the output
      ## filehandle. We only want to use a default value if this is the
      ## beginning of the entire document (but *not* if this is an included
      ## file).
      unless (defined  $myData{_TOP_STREAM}) {
          $out_fh  = \*STDOUT  unless (defined $out_fh);
          $myData{_CUTTING}       = 1;   ## current "cutting" state
          $myData{_INPUT_STREAMS} = [];  ## stack of all input streams
      }
  
      ## Initialize input indicators
      $myData{_OUTFILE} = '(unknown)'  unless (defined  $myData{_OUTFILE});
      $myData{_OUTPUT}  = $out_fh      if (defined  $out_fh);
      $in_fh            = \*STDIN      unless (defined  $in_fh);
      $myData{_INFILE}  = '(unknown)'  unless (defined  $myData{_INFILE});
      $myData{_INPUT}   = $in_fh;
      my $input_top     = $myData{_TOP_STREAM}
                        = new Pod::InputSource(
                              -name        => $myData{_INFILE},
                              -handle      => $in_fh,
                              -was_cutting => $myData{_CUTTING}
                          );
      local *input_stack = $myData{_INPUT_STREAMS};
      push(@input_stack, $input_top);
  
      ## Perform beginning-of-document and/or beginning-of-input processing
      $self->begin_pod()  if (@input_stack == 1);
      $self->begin_input();
  
      return  $input_top;
  }
  
  ##---------------------------------------------------------------------------
  
  =begin _PRIVATE_
  
  =head1 B<_pop_input_stream()>
  
              $hashref = $parser->_pop_input_stream();
  
  This takes no arguments. It will perform any necessary end-of-file or
  end-of-document processing and then pop the current input stream from
  the top of the input stack.
  
  The value returned will be reference to the hash-table that represents
  the new top of the input stream stack.
  
  =end _PRIVATE_
  
  =cut
  
  sub _pop_input_stream {
      my ($self) = @_;
      local *myData = $self;
      local *input_stack = $myData{_INPUT_STREAMS};
  
      ## Perform end-of-input and/or end-of-document processing
      $self->end_input()  if (@input_stack > 0);
      $self->end_pod()    if (@input_stack == 1);
  
      ## Restore cutting state to whatever it was before we started
      ## parsing this file.
      my $old_top = pop(@input_stack);
      $myData{_CUTTING} = $old_top->was_cutting();
  
      ## Dont forget to reset the input indicators
      my $input_top = undef;
      if (@input_stack > 0) {
         $input_top = $myData{_TOP_STREAM} = $input_stack[-1];
         $myData{_INFILE}  = $input_top->name();
         $myData{_INPUT}   = $input_top->handle();
      } else {
         delete $myData{_TOP_STREAM};
         delete $myData{_INPUT_STREAMS};
      }
  
      return  $input_top;
  }
  
  #############################################################################
  
  =head1 TREE-BASED PARSING
  
  If straightforward stream-based parsing wont meet your needs (as is
  likely the case for tasks such as translating PODs into structured
  markup languages like HTML and XML) then you may need to take the
  tree-based approach. Rather than doing everything in one pass and
  calling the B<interpolate()> method to expand sequences into text, it
  may be desirable to instead create a parse-tree using the B<parse_text()>
  method to return a tree-like structure which may contain an ordered
  list of children (each of which may be a text-string, or a similar
  tree-like structure).
  
  Pay special attention to L<"METHODS FOR PARSING AND PROCESSING"> and
  to the objects described in L<Pod::InputObjects>. The former describes
  the gory details and parameters for how to customize and extend the
  parsing behavior of B<Pod::Parser>. B<Pod::InputObjects> provides
  several objects that may all be used interchangeably as parse-trees. The
  most obvious one is the B<Pod::ParseTree> object. It defines the basic
  interface and functionality that all things trying to be a POD parse-tree
  should do. A B<Pod::ParseTree> is defined such that each "node" may be a
  text-string, or a reference to another parse-tree.  Each B<Pod::Paragraph>
  object and each B<Pod::InteriorSequence> object also supports the basic
  parse-tree interface.
  
  The B<parse_text()> method takes a given paragraph of text, and
  returns a parse-tree that contains one or more children, each of which
  may be a text-string, or an InteriorSequence object. There are also
  callback-options that may be passed to B<parse_text()> to customize
  the way it expands or transforms interior-sequences, as well as the
  returned result. These callbacks can be used to create a parse-tree
  with custom-made objects (which may or may not support the parse-tree
  interface, depending on how you choose to do it).
  
  If you wish to turn an entire POD document into a parse-tree, that process
  is fairly straightforward. The B<parse_text()> method is the key to doing
  this successfully. Every paragraph-callback (i.e. the polymorphic methods
  for B<command()>, B<verbatim()>, and B<textblock()> paragraphs) takes
  a B<Pod::Paragraph> object as an argument. Each paragraph object has a
  B<parse_tree()> method that can be used to get or set a corresponding
  parse-tree. So for each of those paragraph-callback methods, simply call
  B<parse_text()> with the options you desire, and then use the returned
  parse-tree to assign to the given paragraph object.
  
  That gives you a parse-tree for each paragraph - so now all you need is
  an ordered list of paragraphs. You can maintain that yourself as a data
  element in the object/hash. The most straightforward way would be simply
  to use an array-ref, with the desired set of custom "options" for each
  invocation of B<parse_text>. Let's assume the desired option-set is
  given by the hash C<%options>. Then we might do something like the
  following:
  
      package MyPodParserTree;
  
      @ISA = qw( Pod::Parser );
  
      ...
  
      sub begin_pod {
          my $self = shift;
          $self->{'-paragraphs'} = [];  ## initialize paragraph list
      }
  
      sub command { 
          my ($parser, $command, $paragraph, $line_num, $pod_para) = @_;
          my $ptree = $parser->parse_text({%options}, $paragraph, ...);
          $pod_para->parse_tree( $ptree );
          push @{ $self->{'-paragraphs'} }, $pod_para;
      }
  
      sub verbatim { 
          my ($parser, $paragraph, $line_num, $pod_para) = @_;
          push @{ $self->{'-paragraphs'} }, $pod_para;
      }
  
      sub textblock { 
          my ($parser, $paragraph, $line_num, $pod_para) = @_;
          my $ptree = $parser->parse_text({%options}, $paragraph, ...);
          $pod_para->parse_tree( $ptree );
          push @{ $self->{'-paragraphs'} }, $pod_para;
      }
  
      ...
  
      package main;
      ...
      my $parser = new MyPodParserTree(...);
      $parser->parse_from_file(...);
      my $paragraphs_ref = $parser->{'-paragraphs'};
  
  Of course, in this module-author's humble opinion, I'd be more inclined to
  use the existing B<Pod::ParseTree> object than a simple array. That way
  everything in it, paragraphs and sequences, all respond to the same core
  interface for all parse-tree nodes. The result would look something like:
  
      package MyPodParserTree2;
  
      ...
  
      sub begin_pod {
          my $self = shift;
          $self->{'-ptree'} = new Pod::ParseTree;  ## initialize parse-tree
      }
  
      sub parse_tree {
          ## convenience method to get/set the parse-tree for the entire POD
          (@_ > 1)  and  $_[0]->{'-ptree'} = $_[1];
          return $_[0]->{'-ptree'};
      }
  
      sub command { 
          my ($parser, $command, $paragraph, $line_num, $pod_para) = @_;
          my $ptree = $parser->parse_text({<<options>>}, $paragraph, ...);
          $pod_para->parse_tree( $ptree );
          $parser->parse_tree()->append( $pod_para );
      }
  
      sub verbatim { 
          my ($parser, $paragraph, $line_num, $pod_para) = @_;
          $parser->parse_tree()->append( $pod_para );
      }
  
      sub textblock { 
          my ($parser, $paragraph, $line_num, $pod_para) = @_;
          my $ptree = $parser->parse_text({<<options>>}, $paragraph, ...);
          $pod_para->parse_tree( $ptree );
          $parser->parse_tree()->append( $pod_para );
      }
  
      ...
  
      package main;
      ...
      my $parser = new MyPodParserTree2(...);
      $parser->parse_from_file(...);
      my $ptree = $parser->parse_tree;
      ...
  
  Now you have the entire POD document as one great big parse-tree. You
  can even use the B<-expand_seq> option to B<parse_text> to insert
  whole different kinds of objects. Just don't expect B<Pod::Parser>
  to know what to do with them after that. That will need to be in your
  code. Or, alternatively, you can insert any object you like so long as
  it conforms to the B<Pod::ParseTree> interface.
  
  One could use this to create subclasses of B<Pod::Paragraphs> and
  B<Pod::InteriorSequences> for specific commands (or to create your own
  custom node-types in the parse-tree) and add some kind of B<emit()>
  method to each custom node/subclass object in the tree. Then all you'd
  need to do is recursively walk the tree in the desired order, processing
  the children (most likely from left to right) by formatting them if
  they are text-strings, or by calling their B<emit()> method if they
  are objects/references.
  
  =head1 CAVEATS
  
  Please note that POD has the notion of "paragraphs": this is something
  starting I<after> a blank (read: empty) line, with the single exception
  of the file start, which is also starting a paragraph. That means that
  especially a command (e.g. C<=head1>) I<must> be preceded with a blank
  line; C<__END__> is I<not> a blank line.
  
  =head1 SEE ALSO
  
  L<Pod::InputObjects>, L<Pod::Select>
  
  B<Pod::InputObjects> defines POD input objects corresponding to
  command paragraphs, parse-trees, and interior-sequences.
  
  B<Pod::Select> is a subclass of B<Pod::Parser> which provides the ability
  to selectively include and/or exclude sections of a POD document from being
  translated based upon the current heading, subheading, subsubheading, etc.
  
  =for __PRIVATE__
  B<Pod::Callbacks> is a subclass of B<Pod::Parser> which gives its users
  the ability the employ I<callback functions> instead of, or in addition
  to, overriding methods of the base class.
  
  =for __PRIVATE__
  B<Pod::Select> and B<Pod::Callbacks> do not override any
  methods nor do they define any new methods with the same name. Because
  of this, they may I<both> be used (in combination) as a base class of
  the same subclass in order to combine their functionality without
  causing any namespace clashes due to multiple inheritance.
  
  =head1 AUTHOR
  
  Please report bugs using L<http://rt.cpan.org>.
  
  Brad Appleton E<lt>bradapp@enteract.comE<gt>
  
  Based on code for B<Pod::Text> written by
  Tom Christiansen E<lt>tchrist@mox.perl.comE<gt>
  
  =head1 LICENSE
  
  Pod-Parser is free software; you can redistribute it and/or modify it
  under the terms of the Artistic License distributed with Perl version
  5.000 or (at your option) any later version. Please refer to the
  Artistic License that came with your Perl distribution for more
  details. If your version of Perl was not distributed under the
  terms of the Artistic License, than you may distribute PodParser
  under the same terms as Perl itself.
  
  =cut
  
  1;
  # vim: ts=4 sw=4 et
POD_PARSER

$fatpacked{"Pod/PlainText.pm"} = <<'POD_PLAINTEXT';
  # Pod::PlainText -- Convert POD data to formatted ASCII text.
  # $Id: Text.pm,v 2.1 1999/09/20 11:53:33 eagle Exp $
  #
  # Copyright 1999-2000 by Russ Allbery <rra@stanford.edu>
  #
  # This program is free software; you can redistribute it and/or modify it
  # under the same terms as Perl itself.
  #
  # This module is intended to be a replacement for Pod::Text, and attempts to
  # match its output except for some specific circumstances where other
  # decisions seemed to produce better output.  It uses Pod::Parser and is
  # designed to be very easy to subclass.
  
  ############################################################################
  # Modules and declarations
  ############################################################################
  
  package Pod::PlainText;
  use strict;
  
  require 5.005;
  
  use Carp qw(carp croak);
  use Pod::Select ();
  
  use vars qw(@ISA %ESCAPES $VERSION);
  
  # We inherit from Pod::Select instead of Pod::Parser so that we can be used
  # by Pod::Usage.
  @ISA = qw(Pod::Select);
  
  $VERSION = '2.05';
  
  BEGIN {
     if ($] < 5.006) {
        require Symbol;
        import Symbol;
     }
  }
  
  ############################################################################
  # Table of supported E<> escapes
  ############################################################################
  
  # This table is taken near verbatim from Pod::PlainText in Pod::Parser,
  # which got it near verbatim from the original Pod::Text.  It is therefore
  # credited to Tom Christiansen, and I'm glad I didn't have to write it.  :)
  %ESCAPES = (
      'amp'       =>    '&',      # ampersand
      'lt'        =>    '<',      # left chevron, less-than
      'gt'        =>    '>',      # right chevron, greater-than
      'quot'      =>    '"',      # double quote
  
      "Aacute"    =>    "\xC1",   # capital A, acute accent
      "aacute"    =>    "\xE1",   # small a, acute accent
      "Acirc"     =>    "\xC2",   # capital A, circumflex accent
      "acirc"     =>    "\xE2",   # small a, circumflex accent
      "AElig"     =>    "\xC6",   # capital AE diphthong (ligature)
      "aelig"     =>    "\xE6",   # small ae diphthong (ligature)
      "Agrave"    =>    "\xC0",   # capital A, grave accent
      "agrave"    =>    "\xE0",   # small a, grave accent
      "Aring"     =>    "\xC5",   # capital A, ring
      "aring"     =>    "\xE5",   # small a, ring
      "Atilde"    =>    "\xC3",   # capital A, tilde
      "atilde"    =>    "\xE3",   # small a, tilde
      "Auml"      =>    "\xC4",   # capital A, dieresis or umlaut mark
      "auml"      =>    "\xE4",   # small a, dieresis or umlaut mark
      "Ccedil"    =>    "\xC7",   # capital C, cedilla
      "ccedil"    =>    "\xE7",   # small c, cedilla
      "Eacute"    =>    "\xC9",   # capital E, acute accent
      "eacute"    =>    "\xE9",   # small e, acute accent
      "Ecirc"     =>    "\xCA",   # capital E, circumflex accent
      "ecirc"     =>    "\xEA",   # small e, circumflex accent
      "Egrave"    =>    "\xC8",   # capital E, grave accent
      "egrave"    =>    "\xE8",   # small e, grave accent
      "ETH"       =>    "\xD0",   # capital Eth, Icelandic
      "eth"       =>    "\xF0",   # small eth, Icelandic
      "Euml"      =>    "\xCB",   # capital E, dieresis or umlaut mark
      "euml"      =>    "\xEB",   # small e, dieresis or umlaut mark
      "Iacute"    =>    "\xCD",   # capital I, acute accent
      "iacute"    =>    "\xED",   # small i, acute accent
      "Icirc"     =>    "\xCE",   # capital I, circumflex accent
      "icirc"     =>    "\xEE",   # small i, circumflex accent
      "Igrave"    =>    "\xCD",   # capital I, grave accent
      "igrave"    =>    "\xED",   # small i, grave accent
      "Iuml"      =>    "\xCF",   # capital I, dieresis or umlaut mark
      "iuml"      =>    "\xEF",   # small i, dieresis or umlaut mark
      "Ntilde"    =>    "\xD1",   # capital N, tilde
      "ntilde"    =>    "\xF1",   # small n, tilde
      "Oacute"    =>    "\xD3",   # capital O, acute accent
      "oacute"    =>    "\xF3",   # small o, acute accent
      "Ocirc"     =>    "\xD4",   # capital O, circumflex accent
      "ocirc"     =>    "\xF4",   # small o, circumflex accent
      "Ograve"    =>    "\xD2",   # capital O, grave accent
      "ograve"    =>    "\xF2",   # small o, grave accent
      "Oslash"    =>    "\xD8",   # capital O, slash
      "oslash"    =>    "\xF8",   # small o, slash
      "Otilde"    =>    "\xD5",   # capital O, tilde
      "otilde"    =>    "\xF5",   # small o, tilde
      "Ouml"      =>    "\xD6",   # capital O, dieresis or umlaut mark
      "ouml"      =>    "\xF6",   # small o, dieresis or umlaut mark
      "szlig"     =>    "\xDF",   # small sharp s, German (sz ligature)
      "THORN"     =>    "\xDE",   # capital THORN, Icelandic
      "thorn"     =>    "\xFE",   # small thorn, Icelandic
      "Uacute"    =>    "\xDA",   # capital U, acute accent
      "uacute"    =>    "\xFA",   # small u, acute accent
      "Ucirc"     =>    "\xDB",   # capital U, circumflex accent
      "ucirc"     =>    "\xFB",   # small u, circumflex accent
      "Ugrave"    =>    "\xD9",   # capital U, grave accent
      "ugrave"    =>    "\xF9",   # small u, grave accent
      "Uuml"      =>    "\xDC",   # capital U, dieresis or umlaut mark
      "uuml"      =>    "\xFC",   # small u, dieresis or umlaut mark
      "Yacute"    =>    "\xDD",   # capital Y, acute accent
      "yacute"    =>    "\xFD",   # small y, acute accent
      "yuml"      =>    "\xFF",   # small y, dieresis or umlaut mark
  
      "lchevron"  =>    "\xAB",   # left chevron (double less than)
      "rchevron"  =>    "\xBB",   # right chevron (double greater than)
  );
  
  
  ############################################################################
  # Initialization
  ############################################################################
  
  # Initialize the object.  Must be sure to call our parent initializer.
  sub initialize {
      my $self = shift;
  
      $$self{alt}      = 0  unless defined $$self{alt};
      $$self{indent}   = 4  unless defined $$self{indent};
      $$self{loose}    = 0  unless defined $$self{loose};
      $$self{sentence} = 0  unless defined $$self{sentence};
      $$self{width}    = 76 unless defined $$self{width};
  
      $$self{INDENTS}  = [];              # Stack of indentations.
      $$self{MARGIN}   = $$self{indent};  # Current left margin in spaces.
  
      return $self->SUPER::initialize;
  }
  
  
  ############################################################################
  # Core overrides
  ############################################################################
  
  # Called for each command paragraph.  Gets the command, the associated
  # paragraph, the line number, and a Pod::Paragraph object.  Just dispatches
  # the command to a method named the same as the command.  =cut is handled
  # internally by Pod::Parser.
  sub command {
      my $self = shift;
      my $command = shift;
      return if $command eq 'pod';
      return if ($$self{EXCLUDE} && $command ne 'end');
      if (defined $$self{ITEM}) {
        $self->item ("\n");
        local $_ = "\n";
        $self->output($_) if($command eq 'back');
      }
      $command = 'cmd_' . $command;
      return $self->$command (@_);
  }
  
  # Called for a verbatim paragraph.  Gets the paragraph, the line number, and
  # a Pod::Paragraph object.  Just output it verbatim, but with tabs converted
  # to spaces.
  sub verbatim {
      my $self = shift;
      return if $$self{EXCLUDE};
      $self->item if defined $$self{ITEM};
      local $_ = shift;
      return if /^\s*$/;
      s/^(\s*\S+)/(' ' x $$self{MARGIN}) . $1/gme;
      return $self->output($_);
  }
  
  # Called for a regular text block.  Gets the paragraph, the line number, and
  # a Pod::Paragraph object.  Perform interpolation and output the results.
  sub textblock {
      my $self = shift;
      return if $$self{EXCLUDE};
      if($$self{VERBATIM}) {
        $self->output($_[0]);
        return;
      }
      local $_ = shift;
      my $line = shift;
  
      # Perform a little magic to collapse multiple L<> references.  This is
      # here mostly for backwards-compatibility.  We'll just rewrite the whole
      # thing into actual text at this part, bypassing the whole internal
      # sequence parsing thing.
      s{
          (
            L<                    # A link of the form L</something>.
                /
                (
                    [:\w]+        # The item has to be a simple word...
                    (\(\))?       # ...or simple function.
                )
            >
            (
                ,?\s+(and\s+)?    # Allow lots of them, conjuncted.
                L<  
                    /
                    (
                        [:\w]+
                        (\(\))?
                    )
                >
            )+
          )
      } {
          local $_ = $1;
          s%L</([^>]+)>%$1%g;
          my @items = split /(?:,?\s+(?:and\s+)?)/;
          my $string = "the ";
          my $i;
          for ($i = 0; $i < @items; $i++) {
              $string .= $items[$i];
              $string .= ", " if @items > 2 && $i != $#items;
              $string .= " and " if ($i == $#items - 1);
          }
          $string .= " entries elsewhere in this document";
          $string;
      }gex;
  
      # Now actually interpolate and output the paragraph.
      $_ = $self->interpolate ($_, $line);
      s/\s*$/\n/s;
      if (defined $$self{ITEM}) {
          $self->item ($_ . "\n");
      } else {
          $self->output ($self->reformat ($_ . "\n"));
      }
  }
  
  # Called for an interior sequence.  Gets the command, argument, and a
  # Pod::InteriorSequence object and is expected to return the resulting text.
  # Calls code, bold, italic, file, and link to handle those types of
  # sequences, and handles S<>, E<>, X<>, and Z<> directly.
  sub interior_sequence {
      my $self = shift;
      my $command = shift;
      local $_ = shift;
      return '' if ($command eq 'X' || $command eq 'Z');
  
      # Expand escapes into the actual character now, carping if invalid.
      if ($command eq 'E') {
          return $ESCAPES{$_} if defined $ESCAPES{$_};
          carp "Unknown escape: E<$_>";
          return "E<$_>";
      }
  
      # For all the other sequences, empty content produces no output.
      return if $_ eq '';
  
      # For S<>, compress all internal whitespace and then map spaces to \01.
      # When we output the text, we'll map this back.
      if ($command eq 'S') {
          s/\s{2,}/ /g;
          tr/ /\01/;
          return $_;
      }
  
      # Anything else needs to get dispatched to another method.
      if    ($command eq 'B') { return $self->seq_b ($_) }
      elsif ($command eq 'C') { return $self->seq_c ($_) }
      elsif ($command eq 'F') { return $self->seq_f ($_) }
      elsif ($command eq 'I') { return $self->seq_i ($_) }
      elsif ($command eq 'L') { return $self->seq_l ($_) }
      else { carp "Unknown sequence $command<$_>" }
  }
  
  # Called for each paragraph that's actually part of the POD.  We take
  # advantage of this opportunity to untabify the input.
  sub preprocess_paragraph {
      my $self = shift;
      local $_ = shift;
      1 while s/^(.*?)(\t+)/$1 . ' ' x (length ($2) * 8 - length ($1) % 8)/me;
      return $_;
  }
  
  
  ############################################################################
  # Command paragraphs
  ############################################################################
  
  # All command paragraphs take the paragraph and the line number.
  
  # First level heading.
  sub cmd_head1 {
      my $self = shift;
      local $_ = shift;
      s/\s+$//s;
      $_ = $self->interpolate ($_, shift);
      if ($$self{alt}) {
          $self->output ("\n==== $_ ====\n\n");
      } else {
          $_ .= "\n" if $$self{loose};
          $self->output ($_ . "\n");
      }
  }
  
  # Second level heading.
  sub cmd_head2 {
      my $self = shift;
      local $_ = shift;
      s/\s+$//s;
      $_ = $self->interpolate ($_, shift);
      if ($$self{alt}) {
          $self->output ("\n==   $_   ==\n\n");
      } else {
          $_ .= "\n" if $$self{loose};
          $self->output (' ' x ($$self{indent} / 2) . $_ . "\n");
      }
  }
  
  # third level heading - not strictly perlpodspec compliant
  sub cmd_head3 {
      my $self = shift;
      local $_ = shift;
      s/\s+$//s;
      $_ = $self->interpolate ($_, shift);
      if ($$self{alt}) {
          $self->output ("\n= $_ =\n");
      } else {
          $_ .= "\n" if $$self{loose};
          $self->output (' ' x ($$self{indent}) . $_ . "\n");
      }
  }
  
  # fourth level heading - not strictly perlpodspec compliant
  # just like head3
  *cmd_head4 = \&cmd_head3;
  
  # Start a list.
  sub cmd_over {
      my $self = shift;
      local $_ = shift;
      unless (/^[-+]?\d+\s+$/) { $_ = $$self{indent} }
      push (@{ $$self{INDENTS} }, $$self{MARGIN});
      $$self{MARGIN} += ($_ + 0);
  }
  
  # End a list.
  sub cmd_back {
      my $self = shift;
      $$self{MARGIN} = pop @{ $$self{INDENTS} };
      unless (defined $$self{MARGIN}) {
          carp 'Unmatched =back';
          $$self{MARGIN} = $$self{indent};
      }
  }
  
  # An individual list item.
  sub cmd_item {
      my $self = shift;
      if (defined $$self{ITEM}) { $self->item }
      local $_ = shift;
      s/\s+$//s;
      $$self{ITEM} = $self->interpolate ($_);
  }
  
  # Begin a block for a particular translator.  Setting VERBATIM triggers
  # special handling in textblock().
  sub cmd_begin {
      my $self = shift;
      local $_ = shift;
      my ($kind) = /^(\S+)/ or return;
      if ($kind eq 'text') {
          $$self{VERBATIM} = 1;
      } else {
          $$self{EXCLUDE} = 1;
      }
  }
  
  # End a block for a particular translator.  We assume that all =begin/=end
  # pairs are properly closed.
  sub cmd_end {
      my $self = shift;
      $$self{EXCLUDE} = 0;
      $$self{VERBATIM} = 0;
  }
  
  # One paragraph for a particular translator.  Ignore it unless it's intended
  # for text, in which case we treat it as a verbatim text block.
  sub cmd_for {
      my $self = shift;
      local $_ = shift;
      my $line = shift;
      return unless s/^text\b[ \t]*\r?\n?//;
      $self->verbatim ($_, $line);
  }
  
  
  ############################################################################
  # Interior sequences
  ############################################################################
  
  # The simple formatting ones.  These are here mostly so that subclasses can
  # override them and do more complicated things.
  sub seq_b { return $_[0]{alt} ? "``$_[1]''" : $_[1] }
  sub seq_c { return $_[0]{alt} ? "``$_[1]''" : "`$_[1]'" }
  sub seq_f { return $_[0]{alt} ? "\"$_[1]\"" : $_[1] }
  sub seq_i { return '*' . $_[1] . '*' }
  
  # The complicated one.  Handle links.  Since this is plain text, we can't
  # actually make any real links, so this is all to figure out what text we
  # print out.
  sub seq_l {
      my $self = shift;
      local $_ = shift;
  
      # Smash whitespace in case we were split across multiple lines.
      s/\s+/ /g;
  
      # If we were given any explicit text, just output it.
      if (/^([^|]+)\|/) { return $1 }
  
      # Okay, leading and trailing whitespace isn't important; get rid of it.
      s/^\s+//;
      s/\s+$//;
  
      # Default to using the whole content of the link entry as a section
      # name.  Note that L<manpage/> forces a manpage interpretation, as does
      # something looking like L<manpage(section)>.  The latter is an
      # enhancement over the original Pod::Text.
      my ($manpage, $section) = ('', $_);
      if (/^(?:https?|ftp|news):/) {
          # a URL
          return $_;
      } elsif (/^"\s*(.*?)\s*"$/) {
          $section = '"' . $1 . '"';
      } elsif (m/^[-:.\w]+(?:\(\S+\))?$/) {
          ($manpage, $section) = ($_, '');
      } elsif (m{/}) {
          ($manpage, $section) = split (/\s*\/\s*/, $_, 2);
      }
  
      my $text = '';
      # Now build the actual output text.
      if (!length $section) {
          $text = "the $manpage manpage" if length $manpage;
      } elsif ($section =~ /^[:\w]+(?:\(\))?/) {
          $text .= 'the ' . $section . ' entry';
          $text .= (length $manpage) ? " in the $manpage manpage"
                                     : ' elsewhere in this document';
      } else {
          $section =~ s/^\"\s*//;
          $section =~ s/\s*\"$//;
          $text .= 'the section on "' . $section . '"';
          $text .= " in the $manpage manpage" if length $manpage;
      }
      return $text;
  }
  
  
  ############################################################################
  # List handling
  ############################################################################
  
  # This method is called whenever an =item command is complete (in other
  # words, we've seen its associated paragraph or know for certain that it
  # doesn't have one).  It gets the paragraph associated with the item as an
  # argument.  If that argument is empty, just output the item tag; if it
  # contains a newline, output the item tag followed by the newline.
  # Otherwise, see if there's enough room for us to output the item tag in the
  # margin of the text or if we have to put it on a separate line.
  sub item {
      my $self = shift;
      local $_ = shift;
      my $tag = $$self{ITEM};
      unless (defined $tag) {
          carp 'item called without tag';
          return;
      }
      undef $$self{ITEM};
      my $indent = $$self{INDENTS}[-1];
      unless (defined $indent) { $indent = $$self{indent} }
      my $space = ' ' x $indent;
      $space =~ s/^ /:/ if $$self{alt};
      if (!$_ || /^\s+$/ || ($$self{MARGIN} - $indent < length ($tag) + 1)) {
          my $margin = $$self{MARGIN};
          $$self{MARGIN} = $indent;
          my $output = $self->reformat ($tag);
          $output =~ s/[\r\n]*$/\n/;
          $self->output ($output);
          $$self{MARGIN} = $margin;
          $self->output ($self->reformat ($_)) if /\S/;
      } else {
          $_ = $self->reformat ($_);
          s/^ /:/ if ($$self{alt} && $indent > 0);
          my $tagspace = ' ' x length $tag;
          s/^($space)$tagspace/$1$tag/ or carp 'Bizarre space in item';
          $self->output ($_);
      }
  }
  
  
  ############################################################################
  # Output formatting
  ############################################################################
  
  # Wrap a line, indenting by the current left margin.  We can't use
  # Text::Wrap because it plays games with tabs.  We can't use formline, even
  # though we'd really like to, because it screws up non-printing characters.
  # So we have to do the wrapping ourselves.
  sub wrap {
      my $self = shift;
      local $_ = shift;
      my $output = '';
      my $spaces = ' ' x $$self{MARGIN};
      my $width = $$self{width} - $$self{MARGIN};
      while (length > $width) {
          if (s/^([^\r\n]{0,$width})\s+// || s/^([^\r\n]{$width})//) {
              $output .= $spaces . $1 . "\n";
          } else {
              last;
          }
      }
      $output .= $spaces . $_;
      $output =~ s/\s+$/\n\n/;
      return $output;
  }
  
  # Reformat a paragraph of text for the current margin.  Takes the text to
  # reformat and returns the formatted text.
  sub reformat {
      my $self = shift;
      local $_ = shift;
  
      # If we're trying to preserve two spaces after sentences, do some
      # munging to support that.  Otherwise, smash all repeated whitespace.
      if ($$self{sentence}) {
          s/ +$//mg;
          s/\.\r?\n/. \n/g;
          s/[\r\n]+/ /g;
          s/   +/  /g;
      } else {
          s/\s+/ /g;
      }
      return $self->wrap($_);
  }
  
  # Output text to the output device.
  sub output { $_[1] =~ tr/\01/ /; print { $_[0]->output_handle } $_[1] }
  
  
  ############################################################################
  # Backwards compatibility
  ############################################################################
  
  # The old Pod::Text module did everything in a pod2text() function.  This
  # tries to provide the same interface for legacy applications.
  sub pod2text {
      my @args;
  
      # This is really ugly; I hate doing option parsing in the middle of a
      # module.  But the old Pod::Text module supported passing flags to its
      # entry function, so handle -a and -<number>.
      while ($_[0] =~ /^-/) {
          my $flag = shift;
          if    ($flag eq '-a')       { push (@args, alt => 1)    }
          elsif ($flag =~ /^-(\d+)$/) { push (@args, width => $1) }
          else {
              unshift (@_, $flag);
              last;
          }
      }
  
      # Now that we know what arguments we're using, create the parser.
      my $parser = Pod::PlainText->new (@args);
  
      # If two arguments were given, the second argument is going to be a file
      # handle.  That means we want to call parse_from_filehandle(), which
      # means we need to turn the first argument into a file handle.  Magic
      # open will handle the <&STDIN case automagically.
      if (defined $_[1]) {
          my $infh;
          if ($] < 5.006) {
            $infh = gensym();
          }
          unless (open ($infh, $_[0])) {
              croak ("Can't open $_[0] for reading: $!\n");
          }
          $_[0] = $infh;
          return $parser->parse_from_filehandle (@_);
      } else {
          return $parser->parse_from_file (@_);
      }
  }
  
  
  ############################################################################
  # Module return value and documentation
  ############################################################################
  
  1;
  __END__
  
  =head1 NAME
  
  Pod::PlainText - Convert POD data to formatted ASCII text
  
  =head1 SYNOPSIS
  
      use Pod::PlainText;
      my $parser = Pod::PlainText->new (sentence => 0, width => 78);
  
      # Read POD from STDIN and write to STDOUT.
      $parser->parse_from_filehandle;
  
      # Read POD from file.pod and write to file.txt.
      $parser->parse_from_file ('file.pod', 'file.txt');
  
  =head1 DESCRIPTION
  
  Pod::PlainText is a module that can convert documentation in the POD format (the
  preferred language for documenting Perl) into formatted ASCII.  It uses no
  special formatting controls or codes whatsoever, and its output is therefore
  suitable for nearly any device.
  
  As a derived class from Pod::Parser, Pod::PlainText supports the same methods and
  interfaces.  See L<Pod::Parser> for all the details; briefly, one creates a
  new parser with C<Pod::PlainText-E<gt>new()> and then calls either
  parse_from_filehandle() or parse_from_file().
  
  new() can take options, in the form of key/value pairs, that control the
  behavior of the parser.  The currently recognized options are:
  
  =over 4
  
  =item alt
  
  If set to a true value, selects an alternate output format that, among other
  things, uses a different heading style and marks C<=item> entries with a
  colon in the left margin.  Defaults to false.
  
  =item indent
  
  The number of spaces to indent regular text, and the default indentation for
  C<=over> blocks.  Defaults to 4.
  
  =item loose
  
  If set to a true value, a blank line is printed after a C<=headN> headings.
  If set to false (the default), no blank line is printed after C<=headN>.
  This is the default because it's the expected formatting for manual pages;
  if you're formatting arbitrary text documents, setting this to true may
  result in more pleasing output.
  
  =item sentence
  
  If set to a true value, Pod::PlainText will assume that each sentence ends in two
  spaces, and will try to preserve that spacing.  If set to false, all
  consecutive whitespace in non-verbatim paragraphs is compressed into a
  single space.  Defaults to true.
  
  =item width
  
  The column at which to wrap text on the right-hand side.  Defaults to 76.
  
  =back
  
  The standard Pod::Parser method parse_from_filehandle() takes up to two
  arguments, the first being the file handle to read POD from and the second
  being the file handle to write the formatted output to.  The first defaults
  to STDIN if not given, and the second defaults to STDOUT.  The method
  parse_from_file() is almost identical, except that its two arguments are the
  input and output disk files instead.  See L<Pod::Parser> for the specific
  details.
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item Bizarre space in item
  
  (W) Something has gone wrong in internal C<=item> processing.  This message
  indicates a bug in Pod::PlainText; you should never see it.
  
  =item Can't open %s for reading: %s
  
  (F) Pod::PlainText was invoked via the compatibility mode pod2text() interface
  and the input file it was given could not be opened.
  
  =item Unknown escape: %s
  
  (W) The POD source contained an C<EE<lt>E<gt>> escape that Pod::PlainText didn't
  know about.
  
  =item Unknown sequence: %s
  
  (W) The POD source contained a non-standard internal sequence (something of
  the form C<XE<lt>E<gt>>) that Pod::PlainText didn't know about.
  
  =item Unmatched =back
  
  (W) Pod::PlainText encountered a C<=back> command that didn't correspond to an
  C<=over> command.
  
  =back
  
  =head1 RESTRICTIONS
  
  Embedded Ctrl-As (octal 001) in the input will be mapped to spaces on
  output, due to an internal implementation detail.
  
  =head1 NOTES
  
  This is a replacement for an earlier Pod::Text module written by Tom
  Christiansen.  It has a revamped interface, since it now uses Pod::Parser,
  but an interface roughly compatible with the old Pod::Text::pod2text()
  function is still available.  Please change to the new calling convention,
  though.
  
  The original Pod::Text contained code to do formatting via termcap
  sequences, although it wasn't turned on by default and it was problematic to
  get it to work at all.  This rewrite doesn't even try to do that, but a
  subclass of it does.  Look for L<Pod::Text::Termcap|Pod::Text::Termcap>.
  
  =head1 SEE ALSO
  
  B<Pod::PlainText> is part of the L<Pod::Parser> distribution.
  
  L<Pod::Parser|Pod::Parser>, L<Pod::Text::Termcap|Pod::Text::Termcap>,
  pod2text(1)
  
  =head1 AUTHOR
  
  Please report bugs using L<http://rt.cpan.org>.
  
  Russ Allbery E<lt>rra@stanford.eduE<gt>, based I<very> heavily on the
  original Pod::Text by Tom Christiansen E<lt>tchrist@mox.perl.comE<gt> and
  its conversion to Pod::Parser by Brad Appleton
  E<lt>bradapp@enteract.comE<gt>.
  
  =cut
POD_PLAINTEXT

$fatpacked{"Pod/Select.pm"} = <<'POD_SELECT';
  #############################################################################
  # Pod/Select.pm -- function to select portions of POD docs
  #
  # Copyright (C) 1996-2000 by Bradford Appleton. All rights reserved.
  # This file is part of "PodParser". PodParser is free software;
  # you can redistribute it and/or modify it under the same terms
  # as Perl itself.
  #############################################################################
  
  package Pod::Select;
  use strict;
  
  use vars qw($VERSION @ISA @EXPORT $MAX_HEADING_LEVEL %myData @section_headings @selected_sections);
  $VERSION = '1.51'; ## Current version of this package
  require  5.005;    ## requires this Perl version or later
  
  #############################################################################
  
  =head1 NAME
  
  Pod::Select, podselect() - extract selected sections of POD from input
  
  =head1 SYNOPSIS
  
      use Pod::Select;
  
      ## Select all the POD sections for each file in @filelist
      ## and print the result on standard output.
      podselect(@filelist);
  
      ## Same as above, but write to tmp.out
      podselect({-output => "tmp.out"}, @filelist):
  
      ## Select from the given filelist, only those POD sections that are
      ## within a 1st level section named any of: NAME, SYNOPSIS, OPTIONS.
      podselect({-sections => ["NAME|SYNOPSIS", "OPTIONS"]}, @filelist):
  
      ## Select the "DESCRIPTION" section of the PODs from STDIN and write
      ## the result to STDERR.
      podselect({-output => ">&STDERR", -sections => ["DESCRIPTION"]}, \*STDIN);
  
  or
  
      use Pod::Select;
  
      ## Create a parser object for selecting POD sections from the input
      $parser = new Pod::Select();
  
      ## Select all the POD sections for each file in @filelist
      ## and print the result to tmp.out.
      $parser->parse_from_file("<&STDIN", "tmp.out");
  
      ## Select from the given filelist, only those POD sections that are
      ## within a 1st level section named any of: NAME, SYNOPSIS, OPTIONS.
      $parser->select("NAME|SYNOPSIS", "OPTIONS");
      for (@filelist) { $parser->parse_from_file($_); }
  
      ## Select the "DESCRIPTION" and "SEE ALSO" sections of the PODs from
      ## STDIN and write the result to STDERR.
      $parser->select("DESCRIPTION");
      $parser->add_selection("SEE ALSO");
      $parser->parse_from_filehandle(\*STDIN, \*STDERR);
  
  =head1 REQUIRES
  
  perl5.005, Pod::Parser, Exporter, Carp
  
  =head1 EXPORTS
  
  podselect()
  
  =head1 DESCRIPTION
  
  B<podselect()> is a function which will extract specified sections of
  pod documentation from an input stream. This ability is provided by the
  B<Pod::Select> module which is a subclass of B<Pod::Parser>.
  B<Pod::Select> provides a method named B<select()> to specify the set of
  POD sections to select for processing/printing. B<podselect()> merely
  creates a B<Pod::Select> object and then invokes the B<podselect()>
  followed by B<parse_from_file()>.
  
  =head1 SECTION SPECIFICATIONS
  
  B<podselect()> and B<Pod::Select::select()> may be given one or more
  "section specifications" to restrict the text processed to only the
  desired set of sections and their corresponding subsections.  A section
  specification is a string containing one or more Perl-style regular
  expressions separated by forward slashes ("/").  If you need to use a
  forward slash literally within a section title you can escape it with a
  backslash ("\/").
  
  The formal syntax of a section specification is:
  
  =over 4
  
  =item *
  
  I<head1-title-regex>/I<head2-title-regex>/...
  
  =back
  
  Any omitted or empty regular expressions will default to ".*".
  Please note that each regular expression given is implicitly
  anchored by adding "^" and "$" to the beginning and end.  Also, if a
  given regular expression starts with a "!" character, then the
  expression is I<negated> (so C<!foo> would match anything I<except>
  C<foo>).
  
  Some example section specifications follow.
  
  =over 4
  
  =item *
  
  Match the C<NAME> and C<SYNOPSIS> sections and all of their subsections:
  
  C<NAME|SYNOPSIS>
  
  =item *
  
  Match only the C<Question> and C<Answer> subsections of the C<DESCRIPTION>
  section:
  
  C<DESCRIPTION/Question|Answer>
  
  =item *
  
  Match the C<Comments> subsection of I<all> sections:
  
  C</Comments>
  
  =item *
  
  Match all subsections of C<DESCRIPTION> I<except> for C<Comments>:
  
  C<DESCRIPTION/!Comments>
  
  =item *
  
  Match the C<DESCRIPTION> section but do I<not> match any of its subsections:
  
  C<DESCRIPTION/!.+>
  
  =item *
  
  Match all top level sections but none of their subsections:
  
  C</!.+>
  
  =back 
  
  =begin _NOT_IMPLEMENTED_
  
  =head1 RANGE SPECIFICATIONS
  
  B<podselect()> and B<Pod::Select::select()> may be given one or more
  "range specifications" to restrict the text processed to only the
  desired ranges of paragraphs in the desired set of sections. A range
  specification is a string containing a single Perl-style regular
  expression (a regex), or else two Perl-style regular expressions
  (regexs) separated by a ".." (Perl's "range" operator is "..").
  The regexs in a range specification are delimited by forward slashes
  ("/").  If you need to use a forward slash literally within a regex you
  can escape it with a backslash ("\/").
  
  The formal syntax of a range specification is:
  
  =over 4
  
  =item *
  
  /I<start-range-regex>/[../I<end-range-regex>/]
  
  =back
  
  Where each the item inside square brackets (the ".." followed by the
  end-range-regex) is optional. Each "range-regex" is of the form:
  
      =cmd-expr text-expr
  
  Where I<cmd-expr> is intended to match the name of one or more POD
  commands, and I<text-expr> is intended to match the paragraph text for
  the command. If a range-regex is supposed to match a POD command, then
  the first character of the regex (the one after the initial '/')
  absolutely I<must> be a single '=' character; it may not be anything
  else (not even a regex meta-character) if it is supposed to match
  against the name of a POD command.
  
  If no I<=cmd-expr> is given then the text-expr will be matched against
  plain textblocks unless it is preceded by a space, in which case it is
  matched against verbatim text-blocks. If no I<text-expr> is given then
  only the command-portion of the paragraph is matched against.
  
  Note that these two expressions are each implicitly anchored. This
  means that when matching against the command-name, there will be an
  implicit '^' and '$' around the given I<=cmd-expr>; and when matching
  against the paragraph text there will be an implicit '\A' and '\Z'
  around the given I<text-expr>.
  
  Unlike with section-specs, the '!' character does I<not> have any special
  meaning (negation or otherwise) at the beginning of a range-spec!
  
  Some example range specifications follow.
  
  =over 4
  
  =item
  Match all C<=for html> paragraphs:
  
  C</=for html/>
  
  =item
  Match all paragraphs between C<=begin html> and C<=end html>
  (note that this will I<not> work correctly if such sections
  are nested):
  
  C</=begin html/../=end html/>
  
  =item
  Match all paragraphs between the given C<=item> name until the end of the
  current section:
  
  C</=item mine/../=head\d/>
  
  =item
  Match all paragraphs between the given C<=item> until the next item, or
  until the end of the itemized list (note that this will I<not> work as
  desired if the item contains an itemized list nested within it):
  
  C</=item mine/../=(item|back)/>
  
  =back 
  
  =end _NOT_IMPLEMENTED_
  
  =cut
  
  #############################################################################
  
  #use diagnostics;
  use Carp;
  use Pod::Parser 1.04;
  
  @ISA = qw(Pod::Parser);
  @EXPORT = qw(&podselect);
  
  ## Maximum number of heading levels supported for '=headN' directives
  *MAX_HEADING_LEVEL = \3;
  
  #############################################################################
  
  =head1 OBJECT METHODS
  
  The following methods are provided in this module. Each one takes a
  reference to the object itself as an implicit first parameter.
  
  =cut
  
  ##---------------------------------------------------------------------------
  
  ## =begin _PRIVATE_
  ## 
  ## =head1 B<_init_headings()>
  ## 
  ## Initialize the current set of active section headings.
  ## 
  ## =cut
  ## 
  ## =end _PRIVATE_
  
  sub _init_headings {
      my $self = shift;
      local *myData = $self;
  
      ## Initialize current section heading titles if necessary
      unless (defined $myData{_SECTION_HEADINGS}) {
          local *section_headings = $myData{_SECTION_HEADINGS} = [];
          for (my $i = 0; $i < $MAX_HEADING_LEVEL; ++$i) {
              $section_headings[$i] = '';
          }
      }
  }
  
  ##---------------------------------------------------------------------------
  
  =head1 B<curr_headings()>
  
              ($head1, $head2, $head3, ...) = $parser->curr_headings();
              $head1 = $parser->curr_headings(1);
  
  This method returns a list of the currently active section headings and
  subheadings in the document being parsed. The list of headings returned
  corresponds to the most recently parsed paragraph of the input.
  
  If an argument is given, it must correspond to the desired section
  heading number, in which case only the specified section heading is
  returned. If there is no current section heading at the specified
  level, then C<undef> is returned.
  
  =cut
  
  sub curr_headings {
      my $self = shift;
      $self->_init_headings()  unless (defined $self->{_SECTION_HEADINGS});
      my @headings = @{ $self->{_SECTION_HEADINGS} };
      return (@_ > 0  and  $_[0] =~ /^\d+$/) ? $headings[$_[0] - 1] : @headings;
  }
  
  ##---------------------------------------------------------------------------
  
  =head1 B<select()>
  
              $parser->select($section_spec1,$section_spec2,...);
  
  This method is used to select the particular sections and subsections of
  POD documentation that are to be printed and/or processed. The existing
  set of selected sections is I<replaced> with the given set of sections.
  See B<add_selection()> for adding to the current set of selected
  sections.
  
  Each of the C<$section_spec> arguments should be a section specification
  as described in L<"SECTION SPECIFICATIONS">.  The section specifications
  are parsed by this method and the resulting regular expressions are
  stored in the invoking object.
  
  If no C<$section_spec> arguments are given, then the existing set of
  selected sections is cleared out (which means C<all> sections will be
  processed).
  
  This method should I<not> normally be overridden by subclasses.
  
  =cut
  
  sub select {
      my ($self, @sections) = @_;
      local *myData = $self;
      local $_;
  
  ### NEED TO DISCERN A SECTION-SPEC FROM A RANGE-SPEC (look for m{^/.+/$}?)
  
      ##---------------------------------------------------------------------
      ## The following is a blatant hack for backward compatibility, and for
      ## implementing add_selection(). If the *first* *argument* is the
      ## string "+", then the remaining section specifications are *added*
      ## to the current set of selections; otherwise the given section
      ## specifications will *replace* the current set of selections.
      ##
      ## This should probably be fixed someday, but for the present time,
      ## it seems incredibly unlikely that "+" would ever correspond to
      ## a legitimate section heading
      ##---------------------------------------------------------------------
      my $add = ($sections[0] eq '+') ? shift(@sections) : '';
  
      ## Reset the set of sections to use
      unless (@sections) {
          delete $myData{_SELECTED_SECTIONS}  unless ($add);
          return;
      }
      $myData{_SELECTED_SECTIONS} = []
          unless ($add  &&  exists $myData{_SELECTED_SECTIONS});
      local *selected_sections = $myData{_SELECTED_SECTIONS};
  
      ## Compile each spec
      for my $spec (@sections) {
          if ( defined($_ = _compile_section_spec($spec)) ) {
              ## Store them in our sections array
              push(@selected_sections, $_);
          }
          else {
              carp qq{Ignoring section spec "$spec"!\n};
          }
      }
  }
  
  ##---------------------------------------------------------------------------
  
  =head1 B<add_selection()>
  
              $parser->add_selection($section_spec1,$section_spec2,...);
  
  This method is used to add to the currently selected sections and
  subsections of POD documentation that are to be printed and/or
  processed. See <select()> for replacing the currently selected sections.
  
  Each of the C<$section_spec> arguments should be a section specification
  as described in L<"SECTION SPECIFICATIONS">. The section specifications
  are parsed by this method and the resulting regular expressions are
  stored in the invoking object.
  
  This method should I<not> normally be overridden by subclasses.
  
  =cut
  
  sub add_selection {
      my $self = shift;
      return $self->select('+', @_);
  }
  
  ##---------------------------------------------------------------------------
  
  =head1 B<clear_selections()>
  
              $parser->clear_selections();
  
  This method takes no arguments, it has the exact same effect as invoking
  <select()> with no arguments.
  
  =cut
  
  sub clear_selections {
      my $self = shift;
      return $self->select();
  }
  
  ##---------------------------------------------------------------------------
  
  =head1 B<match_section()>
  
              $boolean = $parser->match_section($heading1,$heading2,...);
  
  Returns a value of true if the given section and subsection heading
  titles match any of the currently selected section specifications in
  effect from prior calls to B<select()> and B<add_selection()> (or if
  there are no explicitly selected/deselected sections).
  
  The arguments C<$heading1>, C<$heading2>, etc. are the heading titles of
  the corresponding sections, subsections, etc. to try and match.  If
  C<$headingN> is omitted then it defaults to the current corresponding
  section heading title in the input.
  
  This method should I<not> normally be overridden by subclasses.
  
  =cut
  
  sub match_section {
      my $self = shift;
      my (@headings) = @_;
      local *myData = $self;
  
      ## Return true if no restrictions were explicitly specified
      my $selections = (exists $myData{_SELECTED_SECTIONS})
                         ?  $myData{_SELECTED_SECTIONS}  :  undef;
      return  1  unless ((defined $selections) && @{$selections});
  
      ## Default any unspecified sections to the current one
      my @current_headings = $self->curr_headings();
      for (my $i = 0; $i < $MAX_HEADING_LEVEL; ++$i) {
          (defined $headings[$i])  or  $headings[$i] = $current_headings[$i];
      }
  
      ## Look for a match against the specified section expressions
      for my $section_spec ( @{$selections} ) {
          ##------------------------------------------------------
          ## Each portion of this spec must match in order for
          ## the spec to be matched. So we will start with a 
          ## match-value of 'true' and logically 'and' it with
          ## the results of matching a given element of the spec.
          ##------------------------------------------------------
          my $match = 1;
          for (my $i = 0; $i < $MAX_HEADING_LEVEL; ++$i) {
              my $regex   = $section_spec->[$i];
              my $negated = ($regex =~ s/^\!//);
              $match  &= ($negated ? ($headings[$i] !~ /${regex}/)
                                   : ($headings[$i] =~ /${regex}/));
              last unless ($match);
          }
          return  1  if ($match);
      }
      return  0;  ## no match
  }
  
  ##---------------------------------------------------------------------------
  
  =head1 B<is_selected()>
  
              $boolean = $parser->is_selected($paragraph);
  
  This method is used to determine if the block of text given in
  C<$paragraph> falls within the currently selected set of POD sections
  and subsections to be printed or processed. This method is also
  responsible for keeping track of the current input section and
  subsections. It is assumed that C<$paragraph> is the most recently read
  (but not yet processed) input paragraph.
  
  The value returned will be true if the C<$paragraph> and the rest of the
  text in the same section as C<$paragraph> should be selected (included)
  for processing; otherwise a false value is returned.
  
  =cut
  
  sub is_selected {
      my ($self, $paragraph) = @_;
      local $_;
      local *myData = $self;
  
      $self->_init_headings()  unless (defined $myData{_SECTION_HEADINGS});
  
      ## Keep track of current sections levels and headings
      $_ = $paragraph;
      if (/^=((?:sub)*)(?:head(?:ing)?|sec(?:tion)?)(\d*)\s+(.*?)\s*$/)
      {
          ## This is a section heading command
          my ($level, $heading) = ($2, $3);
          $level = 1 + (length($1) / 3)  if ((! length $level) || (length $1));
          ## Reset the current section heading at this level
          $myData{_SECTION_HEADINGS}->[$level - 1] = $heading;
          ## Reset subsection headings of this one to empty
          for (my $i = $level; $i < $MAX_HEADING_LEVEL; ++$i) {
              $myData{_SECTION_HEADINGS}->[$i] = '';
          }
      }
  
      return  $self->match_section();
  }
  
  #############################################################################
  
  =head1 EXPORTED FUNCTIONS
  
  The following functions are exported by this module. Please note that
  these are functions (not methods) and therefore C<do not> take an
  implicit first argument.
  
  =cut
  
  ##---------------------------------------------------------------------------
  
  =head1 B<podselect()>
  
              podselect(\%options,@filelist);
  
  B<podselect> will print the raw (untranslated) POD paragraphs of all
  POD sections in the given input files specified by C<@filelist>
  according to the given options.
  
  If any argument to B<podselect> is a reference to a hash
  (associative array) then the values with the following keys are
  processed as follows:
  
  =over 4
  
  =item B<-output>
  
  A string corresponding to the desired output file (or ">&STDOUT"
  or ">&STDERR"). The default is to use standard output.
  
  =item B<-sections>
  
  A reference to an array of sections specifications (as described in
  L<"SECTION SPECIFICATIONS">) which indicate the desired set of POD
  sections and subsections to be selected from input. If no section
  specifications are given, then all sections of the PODs are used.
  
  =begin _NOT_IMPLEMENTED_
  
  =item B<-ranges>
  
  A reference to an array of range specifications (as described in
  L<"RANGE SPECIFICATIONS">) which indicate the desired range of POD
  paragraphs to be selected from the desired input sections. If no range
  specifications are given, then all paragraphs of the desired sections
  are used.
  
  =end _NOT_IMPLEMENTED_
  
  =back
  
  All other arguments should correspond to the names of input files
  containing POD sections. A file name of "-" or "<&STDIN" will
  be interpreted to mean standard input (which is the default if no
  filenames are given).
  
  =cut 
  
  sub podselect {
      my(@argv) = @_;
      my %defaults = ();
      my $pod_parser = new Pod::Select(%defaults);
      my $num_inputs = 0;
      my $output = '>&STDOUT';
      my %opts;
      local $_;
      for (@argv) {
          if (ref($_)) {
          next unless (ref($_) eq 'HASH');
              %opts = (%defaults, %{$_});
  
              ##-------------------------------------------------------------
              ## Need this for backward compatibility since we formerly used
              ## options that were all uppercase words rather than ones that
              ## looked like Unix command-line options.
              ## to be uppercase keywords)
              ##-------------------------------------------------------------
              %opts = map {
                  my ($key, $val) = (lc $_, $opts{$_});
                  $key =~ s/^(?=\w)/-/;
                  $key =~ /^-se[cl]/  and  $key  = '-sections';
                  #! $key eq '-range'    and  $key .= 's';
                  ($key => $val);
              } (keys %opts);
  
              ## Process the options
              (exists $opts{'-output'})  and  $output = $opts{'-output'};
  
              ## Select the desired sections
              $pod_parser->select(@{ $opts{'-sections'} })
                  if ( (defined $opts{'-sections'})
                       && ((ref $opts{'-sections'}) eq 'ARRAY') );
  
              #! ## Select the desired paragraph ranges
              #! $pod_parser->select(@{ $opts{'-ranges'} })
              #!     if ( (defined $opts{'-ranges'})
              #!          && ((ref $opts{'-ranges'}) eq 'ARRAY') );
          }
          else {
              $pod_parser->parse_from_file($_, $output);
              ++$num_inputs;
          }
      }
      $pod_parser->parse_from_file('-')  unless ($num_inputs > 0);
  }
  
  #############################################################################
  
  =head1 PRIVATE METHODS AND DATA
  
  B<Pod::Select> makes uses a number of internal methods and data fields
  which clients should not need to see or use. For the sake of avoiding
  name collisions with client data and methods, these methods and fields
  are briefly discussed here. Determined hackers may obtain further
  information about them by reading the B<Pod::Select> source code.
  
  Private data fields are stored in the hash-object whose reference is
  returned by the B<new()> constructor for this class. The names of all
  private methods and data-fields used by B<Pod::Select> begin with a
  prefix of "_" and match the regular expression C</^_\w+$/>.
  
  =cut
  
  ##---------------------------------------------------------------------------
  
  =begin _PRIVATE_
  
  =head1 B<_compile_section_spec()>
  
              $listref = $parser->_compile_section_spec($section_spec);
  
  This function (note it is a function and I<not> a method) takes a
  section specification (as described in L<"SECTION SPECIFICATIONS">)
  given in C<$section_sepc>, and compiles it into a list of regular
  expressions. If C<$section_spec> has no syntax errors, then a reference
  to the list (array) of corresponding regular expressions is returned;
  otherwise C<undef> is returned and an error message is printed (using
  B<carp>) for each invalid regex.
  
  =end _PRIVATE_
  
  =cut
  
  sub _compile_section_spec {
      my ($section_spec) = @_;
      my (@regexs, $negated);
  
      ## Compile the spec into a list of regexs
      local $_ = $section_spec;
      s{\\\\}{\001}g;  ## handle escaped backward slashes
      s{\\/}{\002}g;   ## handle escaped forward slashes
  
      ## Parse the regexs for the heading titles
      @regexs = split(/\//, $_, $MAX_HEADING_LEVEL);
  
      ## Set default regex for ommitted levels
      for (my $i = 0; $i < $MAX_HEADING_LEVEL; ++$i) {
          $regexs[$i]  = '.*'  unless ((defined $regexs[$i])
                                       && (length $regexs[$i]));
      }
      ## Modify the regexs as needed and validate their syntax
      my $bad_regexs = 0;
      for (@regexs) {
          $_ .= '.+'  if ($_ eq '!');
          s{\001}{\\\\}g;       ## restore escaped backward slashes
          s{\002}{\\/}g;        ## restore escaped forward slashes
          $negated = s/^\!//;   ## check for negation
          eval "m{$_}";         ## check regex syntax
          if ($@) {
              ++$bad_regexs;
              carp qq{Bad regular expression /$_/ in "$section_spec": $@\n};
          }
          else {
              ## Add the forward and rear anchors (and put the negator back)
              $_ = '^' . $_  unless (/^\^/);
              $_ = $_ . '$'  unless (/\$$/);
              $_ = '!' . $_  if ($negated);
          }
      }
      return  (! $bad_regexs) ? [ @regexs ] : undef;
  }
  
  ##---------------------------------------------------------------------------
  
  =begin _PRIVATE_
  
  =head2 $self->{_SECTION_HEADINGS}
  
  A reference to an array of the current section heading titles for each
  heading level (note that the first heading level title is at index 0).
  
  =end _PRIVATE_
  
  =cut
  
  ##---------------------------------------------------------------------------
  
  =begin _PRIVATE_
  
  =head2 $self->{_SELECTED_SECTIONS}
  
  A reference to an array of references to arrays. Each subarray is a list
  of anchored regular expressions (preceded by a "!" if the expression is to
  be negated). The index of the expression in the subarray should correspond
  to the index of the heading title in C<$self-E<gt>{_SECTION_HEADINGS}>
  that it is to be matched against.
  
  =end _PRIVATE_
  
  =cut
  
  #############################################################################
  
  =head1 SEE ALSO
  
  L<Pod::Parser>
  
  =head1 AUTHOR
  
  Please report bugs using L<http://rt.cpan.org>.
  
  Brad Appleton E<lt>bradapp@enteract.comE<gt>
  
  Based on code for B<pod2text> written by
  Tom Christiansen E<lt>tchrist@mox.perl.comE<gt>
  
  B<Pod::Select> is part of the L<Pod::Parser> distribution.
  
  =cut
  
  1;
  # vim: ts=4 sw=4 et
POD_SELECT

$fatpacked{"Pod/Usage.pm"} = <<'POD_USAGE';
  #############################################################################
  # Pod/Usage.pm -- print usage messages for the running script.
  #
  # Copyright (C) 1996-2000 by Bradford Appleton. All rights reserved.
  # This file is part of "PodParser". PodParser is free software;
  # you can redistribute it and/or modify it under the same terms
  # as Perl itself.
  #############################################################################
  
  package Pod::Usage;
  use strict;
  
  use vars qw($VERSION @ISA @EXPORT);
  $VERSION = '1.51';  ## Current version of this package
  require  5.005;    ## requires this Perl version or later
  
  =head1 NAME
  
  Pod::Usage, pod2usage() - print a usage message from embedded pod documentation
  
  =head1 SYNOPSIS
  
    use Pod::Usage
  
    my $message_text  = "This text precedes the usage message.";
    my $exit_status   = 2;          ## The exit status to use
    my $verbose_level = 0;          ## The verbose level to use
    my $filehandle    = \*STDERR;   ## The filehandle to write to
  
    pod2usage($message_text);
  
    pod2usage($exit_status);
  
    pod2usage( { -message => $message_text ,
                 -exitval => $exit_status  ,  
                 -verbose => $verbose_level,  
                 -output  => $filehandle } );
  
    pod2usage(   -msg     => $message_text ,
                 -exitval => $exit_status  ,  
                 -verbose => $verbose_level,  
                 -output  => $filehandle   );
  
    pod2usage(   -verbose => 2,
                 -noperldoc => 1  )
  
  =head1 ARGUMENTS
  
  B<pod2usage> should be given either a single argument, or a list of
  arguments corresponding to an associative array (a "hash"). When a single
  argument is given, it should correspond to exactly one of the following:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the usage message
  
  =item *
  
  A numeric value corresponding to the desired exit status
  
  =item *
  
  A reference to a hash
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message>
  
  =item C<-msg>
  
  The text of a message to print immediately prior to printing the
  program's usage message. 
  
  =item C<-exitval>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string "NOEXIT" to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-verbose>
  
  The desired level of "verboseness" to use when printing the usage
  message. If the corresponding value is 0, then only the "SYNOPSIS"
  section of the pod documentation is printed. If the corresponding value
  is 1, then the "SYNOPSIS" section, along with any section entitled
  "OPTIONS", "ARGUMENTS", or "OPTIONS AND ARGUMENTS" is printed.  If the
  corresponding value is 2 or more then the entire manpage is printed.
  
  The special verbosity level 99 requires to also specify the -sections
  parameter; then these sections are extracted (see L<Pod::Select>)
  and printed.
  
  =item C<-sections>
  
  A string representing a selection list for sections to be printed
  when -verbose is set to 99, e.g. C<"NAME|SYNOPSIS|DESCRIPTION|VERSION">.
  
  Alternatively, an array reference of section specifications can be used:
  
    pod2usage(-verbose => 99, 
              -sections => [ qw(fred fred/subsection) ] );
  
  =item C<-output>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =item C<-input>
  
  A reference to a filehandle, or the pathname of a file from which the
  invoking script's pod documentation should be read.  It defaults to the
  file indicated by C<$0> (C<$PROGRAM_NAME> for users of F<English.pm>).
  
  If you are calling B<pod2usage()> from a module and want to display
  that module's POD, you can use this:
  
    use Pod::Find qw(pod_where);
    pod2usage( -input => pod_where({-inc => 1}, __PACKAGE__) );
  
  =item C<-pathlist>
  
  A list of directory paths. If the input file does not exist, then it
  will be searched for in the given directory list (in the order the
  directories appear in the list). It defaults to the list of directories
  implied by C<$ENV{PATH}>. The list may be specified either by a reference
  to an array, or by a string of directory paths which use the same path
  separator as C<$ENV{PATH}> on your system (e.g., C<:> for Unix, C<;> for
  MSWin32 and DOS).
  
  =item C<-noperldoc>
  
  By default, Pod::Usage will call L<perldoc> when -verbose >= 2 is
  specified. This does not work well e.g. if the script was packed
  with L<PAR>. The -noperldoc option suppresses the external call to
  L<perldoc> and uses the simple text formatter (L<Pod::Text>) to 
  output the POD.
  
  =back
  
  =head2 Pass-through options
  
  The following options are passed through to the underlying text formatter
  (L<Pod::Text> or L<Pod::PlainText> for Perl versions E<lt> 5.005_58). See 
  the manual pages of these modules for more information.
  
    alt code indent loose margin quotes sentence stderr utf8 width
  
  =head1 DESCRIPTION
  
  B<pod2usage> will print a usage message for the invoking script (using
  its embedded pod documentation) and then exit the script with the
  desired exit status. The usage message printed may have any one of three
  levels of "verboseness": If the verbose level is 0, then only a synopsis
  is printed. If the verbose level is 1, then the synopsis is printed
  along with a description (if present) of the command line options and
  arguments. If the verbose level is 2, then the entire manual page is
  printed.
  
  Unless they are explicitly specified, the default values for the exit
  status, verbose level, and output stream to use are determined as
  follows:
  
  =over 4
  
  =item *
  
  If neither the exit status nor the verbose level is specified, then the
  default is to use an exit status of 2 with a verbose level of 0.
  
  =item *
  
  If an exit status I<is> specified but the verbose level is I<not>, then the
  verbose level will default to 1 if the exit status is less than 2 and
  will default to 0 otherwise.
  
  =item *
  
  If an exit status is I<not> specified but verbose level I<is> given, then
  the exit status will default to 2 if the verbose level is 0 and will
  default to 1 otherwise.
  
  =item *
  
  If the exit status used is less than 2, then output is printed on
  C<STDOUT>.  Otherwise output is printed on C<STDERR>.
  
  =back
  
  Although the above may seem a bit confusing at first, it generally does
  "the right thing" in most situations.  This determination of the default
  values to use is based upon the following typical Unix conventions:
  
  =over 4
  
  =item *
  
  An exit status of 0 implies "success". For example, B<diff(1)> exits
  with a status of 0 if the two files have the same contents.
  
  =item *
  
  An exit status of 1 implies possibly abnormal, but non-defective, program
  termination.  For example, B<grep(1)> exits with a status of 1 if
  it did I<not> find a matching line for the given regular expression.
  
  =item *
  
  An exit status of 2 or more implies a fatal error. For example, B<ls(1)>
  exits with a status of 2 if you specify an illegal (unknown) option on
  the command line.
  
  =item *
  
  Usage messages issued as a result of bad command-line syntax should go
  to C<STDERR>.  However, usage messages issued due to an explicit request
  to print usage (like specifying B<-help> on the command line) should go
  to C<STDOUT>, just in case the user wants to pipe the output to a pager
  (such as B<more(1)>).
  
  =item *
  
  If program usage has been explicitly requested by the user, it is often
  desirable to exit with a status of 1 (as opposed to 0) after issuing
  the user-requested usage message.  It is also desirable to give a
  more verbose description of program usage in this case.
  
  =back
  
  B<pod2usage> doesn't force the above conventions upon you, but it will
  use them by default if you don't expressly tell it to do otherwise.  The
  ability of B<pod2usage()> to accept a single number or a string makes it
  convenient to use as an innocent looking error message handling function:
  
      use Pod::Usage;
      use Getopt::Long;
  
      ## Parse options
      GetOptions("help", "man", "flag1")  ||  pod2usage(2);
      pod2usage(1)  if ($opt_help);
      pod2usage(-verbose => 2)  if ($opt_man);
  
      ## Check for too many filenames
      pod2usage("$0: Too many files given.\n")  if (@ARGV > 1);
  
  Some user's however may feel that the above "economy of expression" is
  not particularly readable nor consistent and may instead choose to do
  something more like the following:
  
      use Pod::Usage;
      use Getopt::Long;
  
      ## Parse options
      GetOptions("help", "man", "flag1")  ||  pod2usage(-verbose => 0);
      pod2usage(-verbose => 1)  if ($opt_help);
      pod2usage(-verbose => 2)  if ($opt_man);
  
      ## Check for too many filenames
      pod2usage(-verbose => 2, -message => "$0: Too many files given.\n")
          if (@ARGV > 1);
  
  As with all things in Perl, I<there's more than one way to do it>, and
  B<pod2usage()> adheres to this philosophy.  If you are interested in
  seeing a number of different ways to invoke B<pod2usage> (although by no
  means exhaustive), please refer to L<"EXAMPLES">.
  
  =head1 EXAMPLES
  
  Each of the following invocations of C<pod2usage()> will print just the
  "SYNOPSIS" section to C<STDERR> and will exit with a status of 2:
  
      pod2usage();
  
      pod2usage(2);
  
      pod2usage(-verbose => 0);
  
      pod2usage(-exitval => 2);
  
      pod2usage({-exitval => 2, -output => \*STDERR});
  
      pod2usage({-verbose => 0, -output  => \*STDERR});
  
      pod2usage(-exitval => 2, -verbose => 0);
  
      pod2usage(-exitval => 2, -verbose => 0, -output => \*STDERR);
  
  Each of the following invocations of C<pod2usage()> will print a message
  of "Syntax error." (followed by a newline) to C<STDERR>, immediately
  followed by just the "SYNOPSIS" section (also printed to C<STDERR>) and
  will exit with a status of 2:
  
      pod2usage("Syntax error.");
  
      pod2usage(-message => "Syntax error.", -verbose => 0);
  
      pod2usage(-msg  => "Syntax error.", -exitval => 2);
  
      pod2usage({-msg => "Syntax error.", -exitval => 2, -output => \*STDERR});
  
      pod2usage({-msg => "Syntax error.", -verbose => 0, -output => \*STDERR});
  
      pod2usage(-msg  => "Syntax error.", -exitval => 2, -verbose => 0);
  
      pod2usage(-message => "Syntax error.",
                -exitval => 2,
                -verbose => 0,
                -output  => \*STDERR);
  
  Each of the following invocations of C<pod2usage()> will print the
  "SYNOPSIS" section and any "OPTIONS" and/or "ARGUMENTS" sections to
  C<STDOUT> and will exit with a status of 1:
  
      pod2usage(1);
  
      pod2usage(-verbose => 1);
  
      pod2usage(-exitval => 1);
  
      pod2usage({-exitval => 1, -output => \*STDOUT});
  
      pod2usage({-verbose => 1, -output => \*STDOUT});
  
      pod2usage(-exitval => 1, -verbose => 1);
  
      pod2usage(-exitval => 1, -verbose => 1, -output => \*STDOUT});
  
  Each of the following invocations of C<pod2usage()> will print the
  entire manual page to C<STDOUT> and will exit with a status of 1:
  
      pod2usage(-verbose  => 2);
  
      pod2usage({-verbose => 2, -output => \*STDOUT});
  
      pod2usage(-exitval  => 1, -verbose => 2);
  
      pod2usage({-exitval => 1, -verbose => 2, -output => \*STDOUT});
  
  =head2 Recommended Use
  
  Most scripts should print some type of usage message to C<STDERR> when a
  command line syntax error is detected. They should also provide an
  option (usually C<-H> or C<-help>) to print a (possibly more verbose)
  usage message to C<STDOUT>. Some scripts may even wish to go so far as to
  provide a means of printing their complete documentation to C<STDOUT>
  (perhaps by allowing a C<-man> option). The following complete example
  uses B<Pod::Usage> in combination with B<Getopt::Long> to do all of these
  things:
  
      use Getopt::Long;
      use Pod::Usage;
  
      my $man = 0;
      my $help = 0;
      ## Parse options and print usage if there is a syntax error,
      ## or if usage was explicitly requested.
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-verbose => 2) if $man;
  
      ## If no arguments were given, then allow STDIN to be used only
      ## if it's not connected to a terminal (otherwise print usage)
      pod2usage("$0: No files given.")  if ((@ARGV == 0) && (-t STDIN));
      __END__
  
      =head1 NAME
  
      sample - Using GetOpt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 8
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  =head1 CAVEATS
  
  By default, B<pod2usage()> will use C<$0> as the path to the pod input
  file.  Unfortunately, not all systems on which Perl runs will set C<$0>
  properly (although if C<$0> isn't found, B<pod2usage()> will search
  C<$ENV{PATH}> or else the list specified by the C<-pathlist> option).
  If this is the case for your system, you may need to explicitly specify
  the path to the pod docs for the invoking script using something
  similar to the following:
  
      pod2usage(-exitval => 2, -input => "/path/to/your/pod/docs");
  
  In the pathological case that a script is called via a relative path
  I<and> the script itself changes the current working directory
  (see L<perlfunc/chdir>) I<before> calling pod2usage, Pod::Usage will
  fail even on robust platforms. Don't do that.
  
  =head1 AUTHOR
  
  Please report bugs using L<http://rt.cpan.org>.
  
  Marek Rouchal E<lt>marekr@cpan.orgE<gt>
  
  Brad Appleton E<lt>bradapp@enteract.comE<gt>
  
  Based on code for B<Pod::Text::pod2text()> written by
  Tom Christiansen E<lt>tchrist@mox.perl.comE<gt>
  
  =head1 ACKNOWLEDGMENTS
  
  Steven McDougall E<lt>swmcd@world.std.comE<gt> for his help and patience
  with re-writing this manpage.
  
  =head1 SEE ALSO
  
  B<Pod::Usage> is part of the L<Pod::Parser> distribution.
  
  L<Pod::Parser>, L<Getopt::Long>, L<Pod::Find>
  
  =cut
  
  #############################################################################
  
  #use diagnostics;
  use Carp;
  use Config;
  use Exporter;
  use File::Spec;
  
  @EXPORT = qw(&pod2usage);
  BEGIN {
      if ( $] >= 5.005_58 ) {
         require Pod::Text;
         @ISA = qw( Pod::Text );
      }
      else {
         require Pod::PlainText;
         @ISA = qw( Pod::PlainText );
      }
  }
  
  require Pod::Select;
  
  ##---------------------------------------------------------------------------
  
  ##---------------------------------
  ## Function definitions begin here
  ##---------------------------------
  
  sub pod2usage {
      local($_) = shift;
      my %opts;
      ## Collect arguments
      if (@_ > 0) {
          ## Too many arguments - assume that this is a hash and
          ## the user forgot to pass a reference to it.
          %opts = ($_, @_);
      }
      elsif (!defined $_) {
        $_ = '';
      }
      elsif (ref $_) {
          ## User passed a ref to a hash
          %opts = %{$_}  if (ref($_) eq 'HASH');
      }
      elsif (/^[-+]?\d+$/) {
          ## User passed in the exit value to use
          $opts{'-exitval'} =  $_;
      }
      else {
          ## User passed in a message to print before issuing usage.
          $_  and  $opts{'-message'} = $_;
      }
  
      ## Need this for backward compatibility since we formerly used
      ## options that were all uppercase words rather than ones that
      ## looked like Unix command-line options.
      ## to be uppercase keywords)
      %opts = map {
          my ($key, $val) = ($_, $opts{$_});
          $key =~ s/^(?=\w)/-/;
          $key =~ /^-msg/i   and  $key = '-message';
          $key =~ /^-exit/i  and  $key = '-exitval';
          lc($key) => $val;
      } (keys %opts);
  
      ## Now determine default -exitval and -verbose values to use
      if ((! defined $opts{'-exitval'}) && (! defined $opts{'-verbose'})) {
          $opts{'-exitval'} = 2;
          $opts{'-verbose'} = 0;
      }
      elsif (! defined $opts{'-exitval'}) {
          $opts{'-exitval'} = ($opts{'-verbose'} > 0) ? 1 : 2;
      }
      elsif (! defined $opts{'-verbose'}) {
          $opts{'-verbose'} = (lc($opts{'-exitval'}) eq 'noexit' ||
                               $opts{'-exitval'} < 2);
      }
  
      ## Default the output file
      $opts{'-output'} = (lc($opts{'-exitval'}) eq 'noexit' ||
                          $opts{'-exitval'} < 2) ? \*STDOUT : \*STDERR
              unless (defined $opts{'-output'});
      ## Default the input file
      $opts{'-input'} = $0  unless (defined $opts{'-input'});
  
      ## Look up input file in path if it doesnt exist.
      unless ((ref $opts{'-input'}) || (-e $opts{'-input'})) {
          my $basename = $opts{'-input'};
          my $pathsep = ($^O =~ /^(?:dos|os2|MSWin32)$/i) ? ';'
                              : (($^O eq 'MacOS' || $^O eq 'VMS') ? ',' :  ':');
          my $pathspec = $opts{'-pathlist'} || $ENV{PATH} || $ENV{PERL5LIB};
  
          my @paths = (ref $pathspec) ? @$pathspec : split($pathsep, $pathspec);
          for my $dirname (@paths) {
              $_ = File::Spec->catfile($dirname, $basename)  if length;
              last if (-e $_) && ($opts{'-input'} = $_);
          }
      }
  
      ## Now create a pod reader and constrain it to the desired sections.
      my $parser = new Pod::Usage(USAGE_OPTIONS => \%opts);
      if ($opts{'-verbose'} == 0) {
          $parser->select('(?:SYNOPSIS|USAGE)\s*');
      }
      elsif ($opts{'-verbose'} == 1) {
          my $opt_re = '(?i)' .
                       '(?:OPTIONS|ARGUMENTS)' .
                       '(?:\s*(?:AND|\/)\s*(?:OPTIONS|ARGUMENTS))?';
          $parser->select( '(?:SYNOPSIS|USAGE)\s*', $opt_re, "DESCRIPTION/$opt_re" );
      }
      elsif ($opts{'-verbose'} >= 2 && $opts{'-verbose'} != 99) {
          $parser->select('.*');
      }
      elsif ($opts{'-verbose'} == 99) {
          my $sections = $opts{'-sections'};
          $parser->select( (ref $sections) ? @$sections : $sections );
          $opts{'-verbose'} = 1;
      }
  
      ## Now translate the pod document and then exit with the desired status
      if (      !$opts{'-noperldoc'}
           and  $opts{'-verbose'} >= 2
           and  !ref($opts{'-input'})
           and  $opts{'-output'} == \*STDOUT )
      {
         ## spit out the entire PODs. Might as well invoke perldoc
         my $progpath = File::Spec->catfile($Config{scriptdirexp} 
  	       || $Config{scriptdir}, 'perldoc');
         print { $opts{'-output'} } ($opts{'-message'}, "\n") if($opts{'-message'});
         if(defined $opts{-input} && $opts{-input} =~ /^\s*(\S.*?)\s*$/) {
           # the perldocs back to 5.005 should all have -F
  	 # without -F there are warnings in -T scripts
           system($progpath, '-F', $1);
           if($?) {
             # RT16091: fall back to more if perldoc failed
             system(($Config{pager} || $ENV{PAGER} || '/bin/more'), $1);
           }
         } else {
           croak "Unspecified input file or insecure argument.\n";
         }
      }
      else {
         $parser->parse_from_file($opts{'-input'}, $opts{'-output'});
      }
  
      exit($opts{'-exitval'})  unless (lc($opts{'-exitval'}) eq 'noexit');
  }
  
  ##---------------------------------------------------------------------------
  
  ##-------------------------------
  ## Method definitions begin here
  ##-------------------------------
  
  sub new {
      my $this = shift;
      my $class = ref($this) || $this;
      my %params = @_;
      my $self = {%params};
      bless $self, $class;
      if ($self->can('initialize')) {
          $self->initialize();
      } else {
          # pass through options to Pod::Text
          my %opts;
         	for (qw(alt code indent loose margin quotes sentence stderr utf8 width)) {
              my $val = $params{USAGE_OPTIONS}{"-$_"};
              $opts{$_} = $val if defined $val;
          }
          $self = $self->SUPER::new(%opts);
          %$self = (%$self, %params);
      }
      return $self;
  }
  
  sub select {
      my ($self, @sections) = @_;
      if ($ISA[0]->can('select')) {
          $self->SUPER::select(@sections);
      } else {
          # we're using Pod::Simple - need to mimic the behavior of Pod::Select
          my $add = ($sections[0] eq '+') ? shift(@sections) : '';
          ## Reset the set of sections to use
          unless (@sections) {
            delete $self->{USAGE_SELECT} unless ($add);
            return;
          }
          $self->{USAGE_SELECT} = []
            unless ($add && $self->{USAGE_SELECT});
          my $sref = $self->{USAGE_SELECT};
          ## Compile each spec
          for my $spec (@sections) {
            my $cs = Pod::Select::_compile_section_spec($spec);
            if ( defined $cs ) {
              ## Store them in our sections array
              push(@$sref, $cs);
            } else {
              carp qq{Ignoring section spec "$spec"!\n};
            }
          }
      }
  }
  
  # Override Pod::Text->seq_i to return just "arg", not "*arg*".
  sub seq_i { return $_[1] }
  
  # This overrides the Pod::Text method to do something very akin to what
  # Pod::Select did as well as the work done below by preprocess_paragraph.
  # Note that the below is very, very specific to Pod::Text.
  sub _handle_element_end {
      my ($self, $element) = @_;
      if ($element eq 'head1') {
          $self->{USAGE_HEADINGS} = [ $$self{PENDING}[-1][1] ];
          if ($self->{USAGE_OPTIONS}->{-verbose} < 2) {
              $$self{PENDING}[-1][1] =~ s/^\s*SYNOPSIS\s*$/USAGE/;
          }
      } elsif ($element =~ /^head(\d+)$/ && $1) { # avoid 0
          my $idx = $1 - 1;
          $self->{USAGE_HEADINGS} = [] unless($self->{USAGE_HEADINGS});
          $self->{USAGE_HEADINGS}->[$idx] = $$self{PENDING}[-1][1];
      }
      if ($element =~ /^head\d+$/) {
          $$self{USAGE_SKIPPING} = 1;
          if (!$$self{USAGE_SELECT} || !@{ $$self{USAGE_SELECT} }) {
              $$self{USAGE_SKIPPING} = 0;
          } else {
              my @headings = @{$$self{USAGE_HEADINGS}};
              for my $section_spec ( @{$$self{USAGE_SELECT}} ) {
                  my $match = 1;
                  for (my $i = 0; $i < $Pod::Select::MAX_HEADING_LEVEL; ++$i) {
                      $headings[$i] = '' unless defined $headings[$i];
                      my $regex   = $section_spec->[$i];
                      my $negated = ($regex =~ s/^\!//);
                      $match  &= ($negated ? ($headings[$i] !~ /${regex}/)
                                           : ($headings[$i] =~ /${regex}/));
                      last unless ($match);
                  } # end heading levels
                  if ($match) {
                    $$self{USAGE_SKIPPING} = 0;
                    last;
                  }
              } # end sections
          }
  
          # Try to do some lowercasing instead of all-caps in headings, and use
          # a colon to end all headings.
          if($self->{USAGE_OPTIONS}->{-verbose} < 2) {
              local $_ = $$self{PENDING}[-1][1];
              s{([A-Z])([A-Z]+)}{((length($2) > 2) ? $1 : lc($1)) . lc($2)}ge;
              s/\s*$/:/  unless (/:\s*$/);
              $_ .= "\n";
              $$self{PENDING}[-1][1] = $_;
          }
      }
      if ($$self{USAGE_SKIPPING} && $element !~ m/^over-/) {
          pop @{ $$self{PENDING} };
      } else {
          $self->SUPER::_handle_element_end($element);
      }
  }
  
  # required for Pod::Simple API
  sub start_document {
      my $self = shift;
      $self->SUPER::start_document();
      my $msg = $self->{USAGE_OPTIONS}->{-message}  or  return 1;
      my $out_fh = $self->output_fh();
      print $out_fh "$msg\n";
  }
  
  # required for old Pod::Parser API
  sub begin_pod {
      my $self = shift;
      $self->SUPER::begin_pod();  ## Have to call superclass
      my $msg = $self->{USAGE_OPTIONS}->{-message}  or  return 1;
      my $out_fh = $self->output_handle();
      print $out_fh "$msg\n";
  }
  
  sub preprocess_paragraph {
      my $self = shift;
      local $_ = shift;
      my $line = shift;
      ## See if this is a heading and we arent printing the entire manpage.
      if (($self->{USAGE_OPTIONS}->{-verbose} < 2) && /^=head/) {
          ## Change the title of the SYNOPSIS section to USAGE
          s/^=head1\s+SYNOPSIS\s*$/=head1 USAGE/;
          ## Try to do some lowercasing instead of all-caps in headings
          s{([A-Z])([A-Z]+)}{((length($2) > 2) ? $1 : lc($1)) . lc($2)}ge;
          ## Use a colon to end all headings
          s/\s*$/:/  unless (/:\s*$/);
          $_ .= "\n";
      }
      return  $self->SUPER::preprocess_paragraph($_);
  }
  
  1; # keep require happy
POD_USAGE

$fatpacked{"darwin-2level/Cwd.pm"} = <<'DARWIN-2LEVEL_CWD';
  package Cwd;
  
  =head1 NAME
  
  Cwd - get pathname of current working directory
  
  =head1 SYNOPSIS
  
      use Cwd;
      my $dir = getcwd;
  
      use Cwd 'abs_path';
      my $abs_path = abs_path($file);
  
  =head1 DESCRIPTION
  
  This module provides functions for determining the pathname of the
  current working directory.  It is recommended that getcwd (or another
  *cwd() function) be used in I<all> code to ensure portability.
  
  By default, it exports the functions cwd(), getcwd(), fastcwd(), and
  fastgetcwd() (and, on Win32, getdcwd()) into the caller's namespace.  
  
  
  =head2 getcwd and friends
  
  Each of these functions are called without arguments and return the
  absolute path of the current working directory.
  
  =over 4
  
  =item getcwd
  
      my $cwd = getcwd();
  
  Returns the current working directory.
  
  Exposes the POSIX function getcwd(3) or re-implements it if it's not
  available.
  
  =item cwd
  
      my $cwd = cwd();
  
  The cwd() is the most natural form for the current architecture. For
  most systems it is identical to `pwd` (but without the trailing line
  terminator).
  
  =item fastcwd
  
      my $cwd = fastcwd();
  
  A more dangerous version of getcwd(), but potentially faster.
  
  It might conceivably chdir() you out of a directory that it can't
  chdir() you back into.  If fastcwd encounters a problem it will return
  undef but will probably leave you in a different directory.  For a
  measure of extra security, if everything appears to have worked, the
  fastcwd() function will check that it leaves you in the same directory
  that it started in. If it has changed it will C<die> with the message
  "Unstable directory path, current directory changed
  unexpectedly". That should never happen.
  
  =item fastgetcwd
  
    my $cwd = fastgetcwd();
  
  The fastgetcwd() function is provided as a synonym for cwd().
  
  =item getdcwd
  
      my $cwd = getdcwd();
      my $cwd = getdcwd('C:');
  
  The getdcwd() function is also provided on Win32 to get the current working
  directory on the specified drive, since Windows maintains a separate current
  working directory for each drive.  If no drive is specified then the current
  drive is assumed.
  
  This function simply calls the Microsoft C library _getdcwd() function.
  
  =back
  
  
  =head2 abs_path and friends
  
  These functions are exported only on request.  They each take a single
  argument and return the absolute pathname for it.  If no argument is
  given they'll use the current working directory.
  
  =over 4
  
  =item abs_path
  
    my $abs_path = abs_path($file);
  
  Uses the same algorithm as getcwd().  Symbolic links and relative-path
  components ("." and "..") are resolved to return the canonical
  pathname, just like realpath(3).
  
  =item realpath
  
    my $abs_path = realpath($file);
  
  A synonym for abs_path().
  
  =item fast_abs_path
  
    my $abs_path = fast_abs_path($file);
  
  A more dangerous, but potentially faster version of abs_path.
  
  =back
  
  =head2 $ENV{PWD}
  
  If you ask to override your chdir() built-in function, 
  
    use Cwd qw(chdir);
  
  then your PWD environment variable will be kept up to date.  Note that
  it will only be kept up to date if all packages which use chdir import
  it from Cwd.
  
  
  =head1 NOTES
  
  =over 4
  
  =item *
  
  Since the path seperators are different on some operating systems ('/'
  on Unix, ':' on MacPerl, etc...) we recommend you use the File::Spec
  modules wherever portability is a concern.
  
  =item *
  
  Actually, on Mac OS, the C<getcwd()>, C<fastgetcwd()> and C<fastcwd()>
  functions  are all aliases for the C<cwd()> function, which, on Mac OS,
  calls `pwd`. Likewise, the C<abs_path()> function is an alias for
  C<fast_abs_path()>.
  
  =back
  
  =head1 AUTHOR
  
  Originally by the perl5-porters.
  
  Maintained by Ken Williams <KWILLIAMS@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Portions of the C code in this library are copyright (c) 1994 by the
  Regents of the University of California.  All rights reserved.  The
  license on this code is compatible with the licensing of the rest of
  the distribution - please see the source code in F<Cwd.xs> for the
  details.
  
  =head1 SEE ALSO
  
  L<File::chdir>
  
  =cut
  
  use strict;
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);
  
  $VERSION = '3.33';
  my $xs_version = $VERSION;
  $VERSION = eval $VERSION;
  
  @ISA = qw/ Exporter /;
  @EXPORT = qw(cwd getcwd fastcwd fastgetcwd);
  push @EXPORT, qw(getdcwd) if $^O eq 'MSWin32';
  @EXPORT_OK = qw(chdir abs_path fast_abs_path realpath fast_realpath);
  
  # sys_cwd may keep the builtin command
  
  # All the functionality of this module may provided by builtins,
  # there is no sense to process the rest of the file.
  # The best choice may be to have this in BEGIN, but how to return from BEGIN?
  
  if ($^O eq 'os2') {
      local $^W = 0;
  
      *cwd                = defined &sys_cwd ? \&sys_cwd : \&_os2_cwd;
      *getcwd             = \&cwd;
      *fastgetcwd         = \&cwd;
      *fastcwd            = \&cwd;
  
      *fast_abs_path      = \&sys_abspath if defined &sys_abspath;
      *abs_path           = \&fast_abs_path;
      *realpath           = \&fast_abs_path;
      *fast_realpath      = \&fast_abs_path;
  
      return 1;
  }
  
  # Need to look up the feature settings on VMS.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_vms_feature;
  BEGIN {
      if ($^O eq 'VMS') {
          if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
              $use_vms_feature = 1;
          }
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _vms_unix_rpt {
      my $unix_rpt;
      if ($use_vms_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  # Need to look up the EFS character set mode.  This may become a dynamic
  # mode in the future.
  sub _vms_efs {
      my $efs;
      if ($use_vms_feature) {
          $efs = VMS::Feature::current("efs_charset");
      } else {
          my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
          $efs = $env_efs =~ /^[ET1]/i; 
      }
      return $efs;
  }
  
  
  # If loading the XS stuff doesn't work, we can fall back to pure perl
  eval {
    if ( $] >= 5.006 ) {
      require XSLoader;
      XSLoader::load( __PACKAGE__, $xs_version);
    } else {
      require DynaLoader;
      push @ISA, 'DynaLoader';
      __PACKAGE__->bootstrap( $xs_version );
    }
  };
  
  # Must be after the DynaLoader stuff:
  $VERSION = eval $VERSION;
  
  # Big nasty table of function aliases
  my %METHOD_MAP =
    (
     VMS =>
     {
      cwd			=> '_vms_cwd',
      getcwd		=> '_vms_cwd',
      fastcwd		=> '_vms_cwd',
      fastgetcwd		=> '_vms_cwd',
      abs_path		=> '_vms_abs_path',
      fast_abs_path	=> '_vms_abs_path',
     },
  
     MSWin32 =>
     {
      # We assume that &_NT_cwd is defined as an XSUB or in the core.
      cwd			=> '_NT_cwd',
      getcwd		=> '_NT_cwd',
      fastcwd		=> '_NT_cwd',
      fastgetcwd		=> '_NT_cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     dos => 
     {
      cwd			=> '_dos_cwd',
      getcwd		=> '_dos_cwd',
      fastgetcwd		=> '_dos_cwd',
      fastcwd		=> '_dos_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     # QNX4.  QNX6 has a $os of 'nto'.
     qnx =>
     {
      cwd			=> '_qnx_cwd',
      getcwd		=> '_qnx_cwd',
      fastgetcwd		=> '_qnx_cwd',
      fastcwd		=> '_qnx_cwd',
      abs_path		=> '_qnx_abs_path',
      fast_abs_path	=> '_qnx_abs_path',
     },
  
     cygwin =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     epoc =>
     {
      cwd			=> '_epoc_cwd',
      getcwd	        => '_epoc_cwd',
      fastgetcwd		=> '_epoc_cwd',
      fastcwd		=> '_epoc_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     MacOS =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
     },
    );
  
  $METHOD_MAP{NT} = $METHOD_MAP{MSWin32};
  
  
  # Find the pwd command in the expected locations.  We assume these
  # are safe.  This prevents _backtick_pwd() consulting $ENV{PATH}
  # so everything works under taint mode.
  my $pwd_cmd;
  foreach my $try ('/bin/pwd',
  		 '/usr/bin/pwd',
  		 '/QOpenSys/bin/pwd', # OS/400 PASE.
  		) {
  
      if( -x $try ) {
          $pwd_cmd = $try;
          last;
      }
  }
  my $found_pwd_cmd = defined($pwd_cmd);
  unless ($pwd_cmd) {
      # Isn't this wrong?  _backtick_pwd() will fail if somenone has
      # pwd in their path but it is not /bin/pwd or /usr/bin/pwd?
      # See [perl #16774]. --jhi
      $pwd_cmd = 'pwd';
  }
  
  # Lazy-load Carp
  sub _carp  { require Carp; Carp::carp(@_)  }
  sub _croak { require Carp; Carp::croak(@_) }
  
  # The 'natural and safe form' for UNIX (pwd may be setuid root)
  sub _backtick_pwd {
      # Localize %ENV entries in a way that won't create new hash keys
      my @localize = grep exists $ENV{$_}, qw(PATH IFS CDPATH ENV BASH_ENV);
      local @ENV{@localize};
      
      my $cwd = `$pwd_cmd`;
      # Belt-and-suspenders in case someone said "undef $/".
      local $/ = "\n";
      # `pwd` may fail e.g. if the disk is full
      chomp($cwd) if defined $cwd;
      $cwd;
  }
  
  # Since some ports may predefine cwd internally (e.g., NT)
  # we take care not to override an existing definition for cwd().
  
  unless ($METHOD_MAP{$^O}{cwd} or defined &cwd) {
      # The pwd command is not available in some chroot(2)'ed environments
      my $sep = $Config::Config{path_sep} || ':';
      my $os = $^O;  # Protect $^O from tainting
  
  
      # Try again to find a pwd, this time searching the whole PATH.
      if (defined $ENV{PATH} and $os ne 'MSWin32') {  # no pwd on Windows
  	my @candidates = split($sep, $ENV{PATH});
  	while (!$found_pwd_cmd and @candidates) {
  	    my $candidate = shift @candidates;
  	    $found_pwd_cmd = 1 if -x "$candidate/pwd";
  	}
      }
  
      # MacOS has some special magic to make `pwd` work.
      if( $os eq 'MacOS' || $found_pwd_cmd )
      {
  	*cwd = \&_backtick_pwd;
      }
      else {
  	*cwd = \&getcwd;
      }
  }
  
  if ($^O eq 'cygwin') {
    # We need to make sure cwd() is called with no args, because it's
    # got an arg-less prototype and will die if args are present.
    local $^W = 0;
    my $orig_cwd = \&cwd;
    *cwd = sub { &$orig_cwd() }
  }
  
  
  # set a reasonable (and very safe) default for fastgetcwd, in case it
  # isn't redefined later (20001212 rspier)
  *fastgetcwd = \&cwd;
  
  # A non-XS version of getcwd() - also used to bootstrap the perl build
  # process, when miniperl is running and no XS loading happens.
  sub _perl_getcwd
  {
      abs_path('.');
  }
  
  # By John Bazik
  #
  # Usage: $cwd = &fastcwd;
  #
  # This is a faster version of getcwd.  It's also more dangerous because
  # you might chdir out of a directory that you can't chdir back into.
      
  sub fastcwd_ {
      my($odev, $oino, $cdev, $cino, $tdev, $tino);
      my(@path, $path);
      local(*DIR);
  
      my($orig_cdev, $orig_cino) = stat('.');
      ($cdev, $cino) = ($orig_cdev, $orig_cino);
      for (;;) {
  	my $direntry;
  	($odev, $oino) = ($cdev, $cino);
  	CORE::chdir('..') || return undef;
  	($cdev, $cino) = stat('.');
  	last if $odev == $cdev && $oino == $cino;
  	opendir(DIR, '.') || return undef;
  	for (;;) {
  	    $direntry = readdir(DIR);
  	    last unless defined $direntry;
  	    next if $direntry eq '.';
  	    next if $direntry eq '..';
  
  	    ($tdev, $tino) = lstat($direntry);
  	    last unless $tdev != $odev || $tino != $oino;
  	}
  	closedir(DIR);
  	return undef unless defined $direntry; # should never happen
  	unshift(@path, $direntry);
      }
      $path = '/' . join('/', @path);
      if ($^O eq 'apollo') { $path = "/".$path; }
      # At this point $path may be tainted (if tainting) and chdir would fail.
      # Untaint it then check that we landed where we started.
      $path =~ /^(.*)\z/s		# untaint
  	&& CORE::chdir($1) or return undef;
      ($cdev, $cino) = stat('.');
      die "Unstable directory path, current directory changed unexpectedly"
  	if $cdev != $orig_cdev || $cino != $orig_cino;
      $path;
  }
  if (not defined &fastcwd) { *fastcwd = \&fastcwd_ }
  
  
  # Keeps track of current working directory in PWD environment var
  # Usage:
  #	use Cwd 'chdir';
  #	chdir $newdir;
  
  my $chdir_init = 0;
  
  sub chdir_init {
      if ($ENV{'PWD'} and $^O ne 'os2' and $^O ne 'dos' and $^O ne 'MSWin32') {
  	my($dd,$di) = stat('.');
  	my($pd,$pi) = stat($ENV{'PWD'});
  	if (!defined $dd or !defined $pd or $di != $pi or $dd != $pd) {
  	    $ENV{'PWD'} = cwd();
  	}
      }
      else {
  	my $wd = cwd();
  	$wd = Win32::GetFullPathName($wd) if $^O eq 'MSWin32';
  	$ENV{'PWD'} = $wd;
      }
      # Strip an automounter prefix (where /tmp_mnt/foo/bar == /foo/bar)
      if ($^O ne 'MSWin32' and $ENV{'PWD'} =~ m|(/[^/]+(/[^/]+/[^/]+))(.*)|s) {
  	my($pd,$pi) = stat($2);
  	my($dd,$di) = stat($1);
  	if (defined $pd and defined $dd and $di == $pi and $dd == $pd) {
  	    $ENV{'PWD'}="$2$3";
  	}
      }
      $chdir_init = 1;
  }
  
  sub chdir {
      my $newdir = @_ ? shift : '';	# allow for no arg (chdir to HOME dir)
      $newdir =~ s|///*|/|g unless $^O eq 'MSWin32';
      chdir_init() unless $chdir_init;
      my $newpwd;
      if ($^O eq 'MSWin32') {
  	# get the full path name *before* the chdir()
  	$newpwd = Win32::GetFullPathName($newdir);
      }
  
      return 0 unless CORE::chdir $newdir;
  
      if ($^O eq 'VMS') {
  	return $ENV{'PWD'} = $ENV{'DEFAULT'}
      }
      elsif ($^O eq 'MacOS') {
  	return $ENV{'PWD'} = cwd();
      }
      elsif ($^O eq 'MSWin32') {
  	$ENV{'PWD'} = $newpwd;
  	return 1;
      }
  
      if (ref $newdir eq 'GLOB') { # in case a file/dir handle is passed in
  	$ENV{'PWD'} = cwd();
      } elsif ($newdir =~ m#^/#s) {
  	$ENV{'PWD'} = $newdir;
      } else {
  	my @curdir = split(m#/#,$ENV{'PWD'});
  	@curdir = ('') unless @curdir;
  	my $component;
  	foreach $component (split(m#/#, $newdir)) {
  	    next if $component eq '.';
  	    pop(@curdir),next if $component eq '..';
  	    push(@curdir,$component);
  	}
  	$ENV{'PWD'} = join('/',@curdir) || '/';
      }
      1;
  }
  
  
  sub _perl_abs_path
  {
      my $start = @_ ? shift : '.';
      my($dotdots, $cwd, @pst, @cst, $dir, @tst);
  
      unless (@cst = stat( $start ))
      {
  	_carp("stat($start): $!");
  	return '';
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
          # NOTE that this routine assumes that '/' is the only directory separator.
  	
          my ($dir, $file) = $start =~ m{^(.*)/(.+)$}
  	    or return cwd() . '/' . $start;
  	
  	# Can't use "-l _" here, because the previous stat was a stat(), not an lstat().
  	if (-l $start) {
  	    my $link_target = readlink($start);
  	    die "Can't resolve link $start: $!" unless defined $link_target;
  	    
  	    require File::Spec;
              $link_target = $dir . '/' . $link_target
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return abs_path($link_target);
  	}
  	
  	return $dir ? abs_path($dir) . "/$file" : "/$file";
      }
  
      $cwd = '';
      $dotdots = $start;
      do
      {
  	$dotdots .= '/..';
  	@pst = @cst;
  	local *PARENT;
  	unless (opendir(PARENT, $dotdots))
  	{
  	    # probably a permissions issue.  Try the native command.
  	    return File::Spec->rel2abs( $start, _backtick_pwd() );
  	}
  	unless (@cst = stat($dotdots))
  	{
  	    _carp("stat($dotdots): $!");
  	    closedir(PARENT);
  	    return '';
  	}
  	if ($pst[0] == $cst[0] && $pst[1] == $cst[1])
  	{
  	    $dir = undef;
  	}
  	else
  	{
  	    do
  	    {
  		unless (defined ($dir = readdir(PARENT)))
  	        {
  		    _carp("readdir($dotdots): $!");
  		    closedir(PARENT);
  		    return '';
  		}
  		$tst[0] = $pst[0]+1 unless (@tst = lstat("$dotdots/$dir"))
  	    }
  	    while ($dir eq '.' || $dir eq '..' || $tst[0] != $pst[0] ||
  		   $tst[1] != $pst[1]);
  	}
  	$cwd = (defined $dir ? "$dir" : "" ) . "/$cwd" ;
  	closedir(PARENT);
      } while (defined $dir);
      chop($cwd) unless $cwd eq '/'; # drop the trailing /
      $cwd;
  }
  
  
  my $Curdir;
  sub fast_abs_path {
      local $ENV{PWD} = $ENV{PWD} || ''; # Guard against clobberage
      my $cwd = getcwd();
      require File::Spec;
      my $path = @_ ? shift : ($Curdir ||= File::Spec->curdir);
  
      # Detaint else we'll explode in taint mode.  This is safe because
      # we're not doing anything dangerous with it.
      ($path) = $path =~ /(.*)/;
      ($cwd)  = $cwd  =~ /(.*)/;
  
      unless (-e $path) {
   	_croak("$path: No such file or directory");
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
  	
  	my ($vol, $dir, $file) = File::Spec->splitpath($path);
  	return File::Spec->catfile($cwd, $path) unless length $dir;
  
  	if (-l $path) {
  	    my $link_target = readlink($path);
  	    die "Can't resolve link $path: $!" unless defined $link_target;
  	    
  	    $link_target = File::Spec->catpath($vol, $dir, $link_target)
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return fast_abs_path($link_target);
  	}
  	
  	return $dir eq File::Spec->rootdir
  	  ? File::Spec->catpath($vol, $dir, $file)
  	  : fast_abs_path(File::Spec->catpath($vol, $dir, '')) . '/' . $file;
      }
  
      if (!CORE::chdir($path)) {
   	_croak("Cannot chdir to $path: $!");
      }
      my $realpath = getcwd();
      if (! ((-d $cwd) && (CORE::chdir($cwd)))) {
   	_croak("Cannot chdir back to $cwd: $!");
      }
      $realpath;
  }
  
  # added function alias to follow principle of least surprise
  # based on previous aliasing.  --tchrist 27-Jan-00
  *fast_realpath = \&fast_abs_path;
  
  
  # --- PORTING SECTION ---
  
  # VMS: $ENV{'DEFAULT'} points to default directory at all times
  # 06-Mar-1996  Charles Bailey  bailey@newman.upenn.edu
  # Note: Use of Cwd::chdir() causes the logical name PWD to be defined
  #   in the process logical name table as the default device and directory
  #   seen by Perl. This may not be the same as the default device
  #   and directory seen by DCL after Perl exits, since the effects
  #   the CRTL chdir() function persist only until Perl exits.
  
  sub _vms_cwd {
      return $ENV{'DEFAULT'};
  }
  
  sub _vms_abs_path {
      return $ENV{'DEFAULT'} unless @_;
      my $path = shift;
  
      my $efs = _vms_efs;
      my $unix_rpt = _vms_unix_rpt;
  
      if (defined &VMS::Filespec::vmsrealpath) {
          my $path_unix = 0;
          my $path_vms = 0;
  
          $path_unix = 1 if ($path =~ m#(?<=\^)/#);
          $path_unix = 1 if ($path =~ /^\.\.?$/);
          $path_vms = 1 if ($path =~ m#[\[<\]]#);
          $path_vms = 1 if ($path =~ /^--?$/);
  
          my $unix_mode = $path_unix;
          if ($efs) {
              # In case of a tie, the Unix report mode decides.
              if ($path_vms == $path_unix) {
                  $unix_mode = $unix_rpt;
              } else {
                  $unix_mode = 0 if $path_vms;
              }
          }
  
          if ($unix_mode) {
              # Unix format
              return VMS::Filespec::unixrealpath($path);
          }
  
  	# VMS format
  
  	my $new_path = VMS::Filespec::vmsrealpath($path);
  
  	# Perl expects directories to be in directory format
  	$new_path = VMS::Filespec::pathify($new_path) if -d $path;
  	return $new_path;
      }
  
      # Fallback to older algorithm if correct ones are not
      # available.
  
      if (-l $path) {
          my $link_target = readlink($path);
          die "Can't resolve link $path: $!" unless defined $link_target;
  
          return _vms_abs_path($link_target);
      }
  
      # may need to turn foo.dir into [.foo]
      my $pathified = VMS::Filespec::pathify($path);
      $path = $pathified if defined $pathified;
  	
      return VMS::Filespec::rmsexpand($path);
  }
  
  sub _os2_cwd {
      $ENV{'PWD'} = `cmd /c cd`;
      chomp $ENV{'PWD'};
      $ENV{'PWD'} =~ s:\\:/:g ;
      return $ENV{'PWD'};
  }
  
  sub _win32_cwd {
      if (eval 'defined &DynaLoader::boot_DynaLoader') {
  	$ENV{'PWD'} = Win32::GetCwd();
      }
      else { # miniperl
  	chomp($ENV{'PWD'} = `cd`);
      }
      $ENV{'PWD'} =~ s:\\:/:g ;
      return $ENV{'PWD'};
  }
  
  *_NT_cwd = defined &Win32::GetCwd ? \&_win32_cwd : \&_os2_cwd;
  
  sub _dos_cwd {
      if (!defined &Dos::GetCwd) {
          $ENV{'PWD'} = `command /c cd`;
          chomp $ENV{'PWD'};
          $ENV{'PWD'} =~ s:\\:/:g ;
      } else {
          $ENV{'PWD'} = Dos::GetCwd();
      }
      return $ENV{'PWD'};
  }
  
  sub _qnx_cwd {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      $ENV{'PWD'} = `/usr/bin/fullpath -t`;
      chomp $ENV{'PWD'};
      return $ENV{'PWD'};
  }
  
  sub _qnx_abs_path {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $path = @_ ? shift : '.';
      local *REALPATH;
  
      defined( open(REALPATH, '-|') || exec '/usr/bin/fullpath', '-t', $path ) or
        die "Can't open /usr/bin/fullpath: $!";
      my $realpath = <REALPATH>;
      close REALPATH;
      chomp $realpath;
      return $realpath;
  }
  
  sub _epoc_cwd {
      $ENV{'PWD'} = EPOC::getcwd();
      return $ENV{'PWD'};
  }
  
  
  # Now that all the base-level functions are set up, alias the
  # user-level functions to the right places
  
  if (exists $METHOD_MAP{$^O}) {
    my $map = $METHOD_MAP{$^O};
    foreach my $name (keys %$map) {
      local $^W = 0;  # assignments trigger 'subroutine redefined' warning
      no strict 'refs';
      *{$name} = \&{$map->{$name}};
    }
  }
  
  # In case the XS version doesn't load.
  *abs_path = \&_perl_abs_path unless defined &abs_path;
  *getcwd = \&_perl_getcwd unless defined &getcwd;
  
  # added function alias for those of us more
  # used to the libc function.  --tchrist 27-Jan-00
  *realpath = \&abs_path;
  
  1;
DARWIN-2LEVEL_CWD

$fatpacked{"darwin-2level/File/Spec.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC';
  package File::Spec;
  
  use strict;
  use vars qw(@ISA $VERSION);
  
  $VERSION = '3.33';
  $VERSION = eval $VERSION;
  
  my %module = (MacOS   => 'Mac',
  	      MSWin32 => 'Win32',
  	      os2     => 'OS2',
  	      VMS     => 'VMS',
  	      epoc    => 'Epoc',
  	      NetWare => 'Win32', # Yes, File::Spec::Win32 works on NetWare.
  	      symbian => 'Win32', # Yes, File::Spec::Win32 works on symbian.
  	      dos     => 'OS2',   # Yes, File::Spec::OS2 works on DJGPP.
  	      cygwin  => 'Cygwin');
  
  
  my $module = $module{$^O} || 'Unix';
  
  require "File/Spec/$module.pm";
  @ISA = ("File::Spec::$module");
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::Spec - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec;
  
  	$x=File::Spec->catfile('a', 'b', 'c');
  
  which returns 'a/b/c' under Unix. Or:
  
  	use File::Spec::Functions;
  
  	$x = catfile('a', 'b', 'c');
  
  =head1 DESCRIPTION
  
  This module is designed to support operations commonly performed on file
  specifications (usually called "file names", but not to be confused with the
  contents of a file, or Perl's file handles), such as concatenating several
  directory and file names into a single path, or determining whether a path
  is rooted. It is based on code directly taken from MakeMaker 5.17, code
  written by Andreas KE<ouml>nig, Andy Dougherty, Charles Bailey, Ilya
  Zakharevich, Paul Schinder, and others.
  
  Since these functions are different for most operating systems, each set of
  OS specific routines is available in a separate module, including:
  
  	File::Spec::Unix
  	File::Spec::Mac
  	File::Spec::OS2
  	File::Spec::Win32
  	File::Spec::VMS
  
  The module appropriate for the current OS is automatically loaded by
  File::Spec. Since some modules (like VMS) make use of facilities available
  only under that OS, it may not be possible to load all modules under all
  operating systems.
  
  Since File::Spec is object oriented, subroutines should not be called directly,
  as in:
  
  	File::Spec::catfile('a','b');
  
  but rather as class methods:
  
  	File::Spec->catfile('a','b');
  
  For simple uses, L<File::Spec::Functions> provides convenient functional
  forms of these methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  X<canonpath>
  
  No physical check on the filesystem, but a logical cleanup of a
  path.
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =item catdir
  X<catdir>
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS/2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
      $path = File::Spec->catdir( @directories );
  
  =item catfile
  X<catfile>
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
      $path = File::Spec->catfile( @directories, $filename );
  
  =item curdir
  X<curdir>
  
  Returns a string representation of the current directory.
  
      $curdir = File::Spec->curdir();
  
  =item devnull
  X<devnull>
  
  Returns a string representation of the null device.
  
      $devnull = File::Spec->devnull();
  
  =item rootdir
  X<rootdir>
  
  Returns a string representation of the root directory.
  
      $rootdir = File::Spec->rootdir();
  
  =item tmpdir
  X<tmpdir>
  
  Returns a string representation of the first writable directory from a
  list of possible temporary directories.  Returns the current directory
  if no writable temporary directories are found.  The list of directories
  checked depends on the platform; e.g. File::Spec::Unix checks C<$ENV{TMPDIR}>
  (unless taint is on) and F</tmp>.
  
      $tmpdir = File::Spec->tmpdir();
  
  =item updir
  X<updir>
  
  Returns a string representation of the parent directory.
  
      $updir = File::Spec->updir();
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
      @paths = File::Spec->no_upwards( @paths );
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  case is not or is significant when comparing file specifications.
  Cygwin and Win32 accept an optional drive argument.
  
      $is_case_tolerant = File::Spec->case_tolerant();
  
  =item file_name_is_absolute
  
  Takes as its argument a path, and returns true if it is an absolute path.
  
      $is_absolute = File::Spec->file_name_is_absolute( $path );
  
  This does not consult the local filesystem on Unix, Win32, OS/2, or
  Mac OS (Classic).  It does consult the working environment for VMS
  (see L<File::Spec::VMS/file_name_is_absolute>).
  
  =item path
  X<path>
  
  Takes no argument.  Returns the environment variable C<PATH> (or the local
  platform's equivalent) as a list.
  
      @PATH = File::Spec->path();
  
  =item join
  X<join, path>
  
  join is the same as catfile.
  
  =item splitpath
  X<splitpath> X<split, path>
  
  Splits a path in to volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path, $no_file );
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless C<$no_file> is true or a
  trailing separator or F</.> or F</..> is present. On Unix, this means that C<$no_file>
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =item splitdir
  X<splitdir> X<split, dir>
  
  The opposite of L</catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  C<$directories> must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSes.
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, C<$volume> is ignored, and directory and file are concatenated.  A '/' is
  inserted if need be.  On other OSes, C<$volume> is significant.
  
      $full_path = File::Spec->catpath( $volume, $directory, $file );
  
  =item abs2rel
  X<abs2rel> X<absolute, path> X<relative, path>
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =item rel2abs()
  X<rel2abs> X<absolute, path> X<relative, path>
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is relative,
  then it is converted to absolute form using L</rel2abs()>. This means that it
  is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is absolute, it is cleaned up and returned using L</canonpath>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =back
  
  For further information, please see L<File::Spec::Unix>,
  L<File::Spec::Mac>, L<File::Spec::OS2>, L<File::Spec::Win32>, or
  L<File::Spec::VMS>.
  
  =head1 SEE ALSO
  
  L<File::Spec::Unix>, L<File::Spec::Mac>, L<File::Spec::OS2>,
  L<File::Spec::Win32>, L<File::Spec::VMS>, L<File::Spec::Functions>,
  L<ExtUtils::MakeMaker>
  
  =head1 AUTHOR
  
  Currently maintained by Ken Williams C<< <KWILLIAMS@cpan.org> >>.
  
  The vast majority of the code was written by
  Kenneth Albanowski C<< <kjahds@kjahds.com> >>,
  Andy Dougherty C<< <doughera@lafayette.edu> >>,
  Andreas KE<ouml>nig C<< <A.Koenig@franz.ww.TU-Berlin.DE> >>,
  Tim Bunce C<< <Tim.Bunce@ig.co.uk> >>.
  VMS support by Charles Bailey C<< <bailey@newman.upenn.edu> >>.
  OS/2 support by Ilya Zakharevich C<< <ilya@math.ohio-state.edu> >>.
  Mac support by Paul Schinder C<< <schinder@pobox.com> >>, and
  Thomas Wegner C<< <wegner_thomas@yahoo.com> >>.
  abs2rel() and rel2abs() written by Shigio Yamaguchi C<< <shigio@tamacom.com> >>,
  modified by Barrie Slaymaker C<< <barries@slaysys.com> >>.
  splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-2010 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_FILE_SPEC

$fatpacked{"darwin-2level/File/Spec/Cygwin.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_CYGWIN';
  package File::Spec::Cygwin;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.33';
  $VERSION = eval $VERSION;
  
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Cygwin - methods for Cygwin file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Cygwin; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  This module is still in beta.  Cygwin-knowledgeable folks are invited
  to offer patches and suggestions.
  
  =cut
  
  =pod
  
  =over 4
  
  =item canonpath
  
  Any C<\> (backslashes) are converted to C</> (forward slashes),
  and then File::Spec::Unix canonpath() is called on the result.
  
  =cut
  
  sub canonpath {
      my($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|\\|/|g;
  
      # Handle network path names beginning with double slash
      my $node = '';
      if ( $path =~ s@^(//[^/]+)(?:/|\z)@/@s ) {
          $node = $1;
      }
      return $node . $self->SUPER::canonpath($path);
  }
  
  sub catdir {
      my $self = shift;
      return unless @_;
  
      # Don't create something that looks like a //network/path
      if ($_[0] and ($_[0] eq '/' or $_[0] eq '\\')) {
          shift;
          return $self->SUPER::catdir('', @_);
      }
  
      $self->SUPER::catdir(@_);
  }
  
  =pod
  
  =item file_name_is_absolute
  
  True is returned if the file name begins with C<drive_letter:>,
  and if not, File::Spec::Unix file_name_is_absolute() is called.
  
  =cut
  
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return 1 if $file =~ m{^([a-z]:)?[\\/]}is; # C:/test
      return $self->SUPER::file_name_is_absolute($file);
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      /tmp
      $ENV{'TMP'}
      $ENV{'TEMP'}
      C:/temp
  
  Since Perl 5.8.0, if running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, "/tmp", $ENV{'TMP'}, $ENV{'TEMP'}, 'C:/temp' );
  }
  
  =item case_tolerant
  
  Override Unix. Cygwin case-tolerance depends on managed mount settings and
  as with MsWin32 on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Default: 1
  
  =cut
  
  sub case_tolerant {
    return 1 unless $^O eq 'cygwin'
      and defined &Cygwin::mount_flags;
  
    my $drive = shift;
    if (! $drive) {
        my @flags = split(/,/, Cygwin::mount_flags('/cygwin'));
        my $prefix = pop(@flags);
        if (! $prefix || $prefix eq 'cygdrive') {
            $drive = '/cygdrive/c';
        } elsif ($prefix eq '/') {
            $drive = '/c';
        } else {
            $drive = "$prefix/c";
        }
    }
    my $mntopts = Cygwin::mount_flags($drive);
    if ($mntopts and ($mntopts =~ /,managed/)) {
      return 0;
    }
    eval { require Win32API::File; } or return 1;
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  1;
DARWIN-2LEVEL_FILE_SPEC_CYGWIN

$fatpacked{"darwin-2level/File/Spec/Epoc.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_EPOC';
  package File::Spec::Epoc;
  
  use strict;
  use vars qw($VERSION @ISA);
  
  $VERSION = '3.33';
  $VERSION = eval $VERSION;
  
  require File::Spec::Unix;
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Epoc - methods for Epoc file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Epoc; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  This package is still work in progress ;-)
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =pod
  
  =over 4
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminated successive slashes and successive "/.".
  
  =back
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                        # xx/././xx -> xx/xx
      $path =~ s|^(\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(\.\./)+|/|s;                     # /../../xx -> xx
      $path =~  s|/\Z(?!\n)|| unless $path eq "/";          # xx/       -> xx
      return $path;
  }
  
  =pod
  
  =head1 AUTHOR
  
  o.flebbe@gmx.de
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
DARWIN-2LEVEL_FILE_SPEC_EPOC

$fatpacked{"darwin-2level/File/Spec/Functions.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_FUNCTIONS';
  package File::Spec::Functions;
  
  use File::Spec;
  use strict;
  
  use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);
  
  $VERSION = '3.33';
  $VERSION = eval $VERSION;
  
  require Exporter;
  
  @ISA = qw(Exporter);
  
  @EXPORT = qw(
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  );
  
  @EXPORT_OK = qw(
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  );
  
  %EXPORT_TAGS = ( ALL => [ @EXPORT_OK, @EXPORT ] );
  
  foreach my $meth (@EXPORT, @EXPORT_OK) {
      my $sub = File::Spec->can($meth);
      no strict 'refs';
      *{$meth} = sub {&$sub('File::Spec', @_)};
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::Functions - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec::Functions;
  	$x = catfile('a','b');
  
  =head1 DESCRIPTION
  
  This module exports convenience functions for all of the class methods
  provided by File::Spec.
  
  For a reference of available functions, please consult L<File::Spec::Unix>,
  which contains the entire set, and which is inherited by the modules for
  other platforms. For further information, please see L<File::Spec::Mac>,
  L<File::Spec::OS2>, L<File::Spec::Win32>, or L<File::Spec::VMS>.
  
  =head2 Exports
  
  The following functions are exported by default.
  
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  
  
  The following functions are exported only by request.
  
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  
  All the functions may be imported using the C<:ALL> tag.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  File::Spec, File::Spec::Unix, File::Spec::Mac, File::Spec::OS2,
  File::Spec::Win32, File::Spec::VMS, ExtUtils::MakeMaker
  
  =cut
  
DARWIN-2LEVEL_FILE_SPEC_FUNCTIONS

$fatpacked{"darwin-2level/File/Spec/Mac.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_MAC';
  package File::Spec::Mac;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.33';
  $VERSION = eval $VERSION;
  
  @ISA = qw(File::Spec::Unix);
  
  my $macfiles;
  if ($^O eq 'MacOS') {
  	$macfiles = eval { require Mac::Files };
  }
  
  sub case_tolerant { 1 }
  
  
  =head1 NAME
  
  File::Spec::Mac - File::Spec for Mac OS (Classic)
  
  =head1 SYNOPSIS
  
   require File::Spec::Mac; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  
  On Mac OS, there's nothing to be done. Returns what it's given.
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return $path;
  }
  
  =item catdir()
  
  Concatenate two or more directory names to form a path separated by colons
  (":") ending with a directory. Resulting paths are B<relative> by default,
  but can be forced to be absolute (but avoid this, see below). Automatically
  puts a trailing ":" on the end of the complete path, because that's what's
  done in MacPerl's environment and helps to distinguish a file path from a
  directory path.
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the resulting
  path is relative by default and I<not> absolute. This decision was made due
  to portability reasons. Since C<File::Spec-E<gt>catdir()> returns relative paths
  on all other operating systems, it will now also follow this convention on Mac
  OS. Note that this may break some existing scripts.
  
  The intended purpose of this routine is to concatenate I<directory names>.
  But because of the nature of Macintosh paths, some additional possibilities
  are allowed to make using this routine give reasonable results for some
  common situations. In other words, you are also allowed to concatenate
  I<paths> instead of directory names (strictly speaking, a string like ":a"
  is a path, but not a name, since it contains a punctuation character ":").
  
  So, beside calls like
  
      catdir("a") = ":a:"
      catdir("a","b") = ":a:b:"
      catdir() = ""                    (special case)
  
  calls like the following
  
      catdir(":a:") = ":a:"
      catdir(":a","b") = ":a:b:"
      catdir(":a:","b") = ":a:b:"
      catdir(":a:",":b:") = ":a:b:"
      catdir(":") = ":"
  
  are allowed.
  
  Here are the rules that are used in C<catdir()>; note that we try to be as
  compatible as possible to Unix:
  
  =over 2
  
  =item 1.
  
  The resulting path is relative by default, i.e. the resulting path will have a
  leading colon.
  
  =item 2.
  
  A trailing colon is added automatically to the resulting path, to denote a
  directory.
  
  =item 3.
  
  Generally, each argument has one leading ":" and one trailing ":"
  removed (if any). They are then joined together by a ":". Special
  treatment applies for arguments denoting updir paths like "::lib:",
  see (4), or arguments consisting solely of colons ("colon paths"),
  see (5).
  
  =item 4.
  
  When an updir path like ":::lib::" is passed as argument, the number
  of directories to climb up is handled correctly, not removing leading
  or trailing colons when necessary. E.g.
  
      catdir(":::a","::b","c")    = ":::a::b:c:"
      catdir(":::a::","::b","c")  = ":::a:::b:c:"
  
  =item 5.
  
  Adding a colon ":" or empty string "" to a path at I<any> position
  doesn't alter the path, i.e. these arguments are ignored. (When a ""
  is passed as the first argument, it has a special meaning, see
  (6)). This way, a colon ":" is handled like a "." (curdir) on Unix,
  while an empty string "" is generally ignored (see
  C<Unix-E<gt>canonpath()> ). Likewise, a "::" is handled like a ".."
  (updir), and a ":::" is handled like a "../.." etc.  E.g.
  
      catdir("a",":",":","b")   = ":a:b:"
      catdir("a",":","::",":b") = ":a::b:"
  
  =item 6.
  
  If the first argument is an empty string "" or is a volume name, i.e. matches
  the pattern /^[^:]+:/, the resulting path is B<absolute>.
  
  =item 7.
  
  Passing an empty string "" as the first argument to C<catdir()> is
  like passingC<File::Spec-E<gt>rootdir()> as the first argument, i.e.
  
      catdir("","a","b")          is the same as
  
      catdir(rootdir(),"a","b").
  
  This is true on Unix, where C<catdir("","a","b")> yields "/a/b" and
  C<rootdir()> is "/". Note that C<rootdir()> on Mac OS is the startup
  volume, which is the closest in concept to Unix' "/". This should help
  to run existing scripts originally written for Unix.
  
  =item 8.
  
  For absolute paths, some cleanup is done, to ensure that the volume
  name isn't immediately followed by updirs. This is invalid, because
  this would go beyond "root". Generally, these cases are handled like
  their Unix counterparts:
  
   Unix:
      Unix->catdir("","")                 =  "/"
      Unix->catdir("",".")                =  "/"
      Unix->catdir("","..")               =  "/"              # can't go beyond root
      Unix->catdir("",".","..","..","a")  =  "/a"
   Mac:
      Mac->catdir("","")                  =  rootdir()         # (e.g. "HD:")
      Mac->catdir("",":")                 =  rootdir()
      Mac->catdir("","::")                =  rootdir()         # can't go beyond root
      Mac->catdir("",":","::","::","a")   =  rootdir() . "a:"  # (e.g. "HD:a:")
  
  However, this approach is limited to the first arguments following
  "root" (again, see C<Unix-E<gt>canonpath()> ). If there are more
  arguments that move up the directory tree, an invalid path going
  beyond root can be created.
  
  =back
  
  As you've seen, you can force C<catdir()> to create an absolute path
  by passing either an empty string or a path that begins with a volume
  name as the first argument. However, you are strongly encouraged not
  to do so, since this is done only for backward compatibility. Newer
  versions of File::Spec come with a method called C<catpath()> (see
  below), that is designed to offer a portable solution for the creation
  of absolute paths.  It takes volume, directory and file portions and
  returns an entire path. While C<catdir()> is still suitable for the
  concatenation of I<directory names>, you are encouraged to use
  C<catpath()> to concatenate I<volume names> and I<directory
  paths>. E.g.
  
      $dir      = File::Spec->catdir("tmp","sources");
      $abs_path = File::Spec->catpath("MacintoshHD:", $dir,"");
  
  yields
  
      "MacintoshHD:tmp:sources:" .
  
  =cut
  
  sub catdir {
  	my $self = shift;
  	return '' unless @_;
  	my @args = @_;
  	my $first_arg;
  	my $relative;
  
  	# take care of the first argument
  
  	if ($args[0] eq '')  { # absolute path, rootdir
  		shift @args;
  		$relative = 0;
  		$first_arg = $self->rootdir;
  
  	} elsif ($args[0] =~ /^[^:]+:/) { # absolute path, volume name
  		$relative = 0;
  		$first_arg = shift @args;
  		# add a trailing ':' if need be (may be it's a path like HD:dir)
  		$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  
  	} else { # relative path
  		$relative = 1;
  		if ( $args[0] =~ /^::+\Z(?!\n)/ ) {
  			# updir colon path ('::', ':::' etc.), don't shift
  			$first_arg = ':';
  		} elsif ($args[0] eq ':') {
  			$first_arg = shift @args;
  		} else {
  			# add a trailing ':' if need be
  			$first_arg = shift @args;
  			$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  		}
  	}
  
  	# For all other arguments,
  	# (a) ignore arguments that equal ':' or '',
  	# (b) handle updir paths specially:
  	#     '::' 			-> concatenate '::'
  	#     '::' . '::' 	-> concatenate ':::' etc.
  	# (c) add a trailing ':' if need be
  
  	my $result = $first_arg;
  	while (@args) {
  		my $arg = shift @args;
  		unless (($arg eq '') || ($arg eq ':')) {
  			if ($arg =~ /^::+\Z(?!\n)/ ) { # updir colon path like ':::'
  				my $updir_count = length($arg) - 1;
  				while ((@args) && ($args[0] =~ /^::+\Z(?!\n)/) ) { # while updir colon path
  					$arg = shift @args;
  					$updir_count += (length($arg) - 1);
  				}
  				$arg = (':' x $updir_count);
  			} else {
  				$arg =~ s/^://s; # remove a leading ':' if any
  				$arg = "$arg:" unless ($arg =~ /:\Z(?!\n)/); # ensure trailing ':'
  			}
  			$result .= $arg;
  		}#unless
  	}
  
  	if ( ($relative) && ($result !~ /^:/) ) {
  		# add a leading colon if need be
  		$result = ":$result";
  	}
  
  	unless ($relative) {
  		# remove updirs immediately following the volume name
  		$result =~ s/([^:]+:)(:*)(.*)\Z(?!\n)/$1$3/;
  	}
  
  	return $result;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename. Resulting paths are B<relative>
  by default, but can be forced to be absolute (but avoid this).
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the
  resulting path is relative by default and I<not> absolute. This
  decision was made due to portability reasons. Since
  C<File::Spec-E<gt>catfile()> returns relative paths on all other
  operating systems, it will now also follow this convention on Mac OS.
  Note that this may break some existing scripts.
  
  The last argument is always considered to be the file portion. Since
  C<catfile()> uses C<catdir()> (see above) for the concatenation of the
  directory portions (if any), the following with regard to relative and
  absolute paths is true:
  
      catfile("")     = ""
      catfile("file") = "file"
  
  but
  
      catfile("","")        = rootdir()         # (e.g. "HD:")
      catfile("","file")    = rootdir() . file  # (e.g. "HD:file")
      catfile("HD:","file") = "HD:file"
  
  This means that C<catdir()> is called only when there are two or more
  arguments, as one might expect.
  
  Note that the leading ":" is removed from the filename, so that
  
      catfile("a","b","file")  = ":a:b:file"    and
  
      catfile("a","b",":file") = ":a:b:file"
  
  give the same answer.
  
  To concatenate I<volume names>, I<directory paths> and I<filenames>,
  you are encouraged to use C<catpath()> (see below).
  
  =cut
  
  sub catfile {
      my $self = shift;
      return '' unless @_;
      my $file = pop @_;
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $file =~ s/^://s;
      return $dir.$file;
  }
  
  =item curdir
  
  Returns a string representing the current directory. On Mac OS, this is ":".
  
  =cut
  
  sub curdir {
      return ":";
  }
  
  =item devnull
  
  Returns a string representing the null device. On Mac OS, this is "Dev:Null".
  
  =cut
  
  sub devnull {
      return "Dev:Null";
  }
  
  =item rootdir
  
  Returns a string representing the root directory.  Under MacPerl,
  returns the name of the startup volume, since that's the closest in
  concept, although other volumes aren't rooted there. The name has a
  trailing ":", because that's the correct specification for a volume
  name on Mac OS.
  
  If Mac::Files could not be loaded, the empty string is returned.
  
  =cut
  
  sub rootdir {
  #
  #  There's no real root directory on Mac OS. The name of the startup
  #  volume is returned, since that's the closest in concept.
  #
      return '' unless $macfiles;
      my $system = Mac::Files::FindFolder(&Mac::Files::kOnSystemDisk,
  	&Mac::Files::kSystemFolderType);
      $system =~ s/:.*\Z(?!\n)/:/s;
      return $system;
  }
  
  =item tmpdir
  
  Returns the contents of $ENV{TMPDIR}, if that directory exits or the
  current working directory otherwise. Under MacPerl, $ENV{TMPDIR} will
  contain a path like "MacintoshHD:Temporary Items:", which is a hidden
  directory on your startup volume.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR} );
  }
  
  =item updir
  
  Returns a string representing the parent directory. On Mac OS, this is "::".
  
  =cut
  
  sub updir {
      return "::";
  }
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true, if it is an absolute path.
  If the path has a leading ":", it's a relative path. Otherwise, it's an
  absolute path, unless the path doesn't contain any colons, i.e. it's a name
  like "a". In this particular case, the path is considered to be relative
  (i.e. it is considered to be a filename). Use ":" in the appropriate place
  in the path if you want to distinguish unambiguously. As a special case,
  the filename '' is always considered to be absolute. Note that with version
  1.2 of File::Spec::Mac, this does no longer consult the local filesystem.
  
  E.g.
  
      File::Spec->file_name_is_absolute("a");             # false (relative)
      File::Spec->file_name_is_absolute(":a:b:");         # false (relative)
      File::Spec->file_name_is_absolute("MacintoshHD:");  # true (absolute)
      File::Spec->file_name_is_absolute("");              # true (absolute)
  
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      if ($file =~ /:/) {
  	return (! ($file =~ m/^:/s) );
      } elsif ( $file eq '' ) {
          return 1 ;
      } else {
  	return 0; # i.e. a file like "a"
      }
  }
  
  =item path
  
  Returns the null list for the MacPerl application, since the concept is
  usually meaningless under Mac OS. But if you're using the MacPerl tool under
  MPW, it gives back $ENV{Commands} suitably split, as is done in
  :lib:ExtUtils:MM_Mac.pm.
  
  =cut
  
  sub path {
  #
  #  The concept is meaningless under the MacPerl application.
  #  Under MPW, it has a meaning.
  #
      return unless exists $ENV{Commands};
      return split(/,/, $ENV{Commands});
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path, $no_file );
  
  Splits a path into volume, directory, and filename portions.
  
  On Mac OS, assumes that the last part of the path is a filename unless
  $no_file is true or a trailing separator ":" is present.
  
  The volume portion is always returned with a trailing ":". The directory portion
  is always returned with a leading (to denote a relative path) and a trailing ":"
  (to denote a directory). The file portion is always returned I<without> a leading ":".
  Empty portions are returned as empty string ''.
  
  The results can be passed to C<catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file);
  
      if ( $nofile ) {
          ( $volume, $directory ) = $path =~ m|^((?:[^:]+:)?)(.*)|s;
      }
      else {
          $path =~
              m|^( (?: [^:]+: )? )
                 ( (?: .*: )? )
                 ( .* )
               |xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      $volume = '' unless defined($volume);
  	$directory = ":$directory" if ( $volume && $directory ); # take care of "HD::dir"
      if ($directory) {
          # Make sure non-empty directories begin and end in ':'
          $directory .= ':' unless (substr($directory,-1) eq ':');
          $directory = ":$directory" unless (substr($directory,0,1) eq ':');
      } else {
  	$directory = '';
      }
      $file = '' unless defined($file);
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of C<catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories should be only the directory portion of the path on systems
  that have the concept of a volume or that have path syntax that differentiates
  files from directories. Consider using C<splitpath()> otherwise.
  
  Unlike just splitting the directories on the separator, empty directory names
  (C<"">) can be returned. Since C<catdir()> on Mac OS always appends a trailing
  colon to distinguish a directory path from a file path, a single trailing colon
  will be ignored, i.e. there's no empty directory name after it.
  
  Hence, on Mac OS, both
  
      File::Spec->splitdir( ":a:b::c:" );    and
      File::Spec->splitdir( ":a:b::c" );
  
  yield:
  
      ( "a", "b", "::", "c")
  
  while
  
      File::Spec->splitdir( ":a:b::c::" );
  
  yields:
  
      ( "a", "b", "::", "c", "::")
  
  
  =cut
  
  sub splitdir {
  	my ($self, $path) = @_;
  	my @result = ();
  	my ($head, $sep, $tail, $volume, $directories);
  
  	return @result if ( (!defined($path)) || ($path eq '') );
  	return (':') if ($path eq ':');
  
  	( $volume, $sep, $directories ) = $path =~ m|^((?:[^:]+:)?)(:*)(.*)|s;
  
  	# deprecated, but handle it correctly
  	if ($volume) {
  		push (@result, $volume);
  		$sep .= ':';
  	}
  
  	while ($sep || $directories) {
  		if (length($sep) > 1) {
  			my $updir_count = length($sep) - 1;
  			for (my $i=0; $i<$updir_count; $i++) {
  				# push '::' updir_count times;
  				# simulate Unix '..' updirs
  				push (@result, '::');
  			}
  		}
  		$sep = '';
  		if ($directories) {
  			( $head, $sep, $tail ) = $directories =~ m|^((?:[^:]+)?)(:*)(.*)|s;
  			push (@result, $head);
  			$directories = $tail;
  		}
  	}
  	return @result;
  }
  
  
  =item catpath
  
      $path = File::Spec->catpath($volume,$directory,$file);
  
  Takes volume, directory and file portions and returns an entire path. On Mac OS,
  $volume, $directory and $file are concatenated.  A ':' is inserted if need be. You
  may pass an empty string for each portion. If all portions are empty, the empty
  string is returned. If $volume is empty, the result will be a relative path,
  beginning with a ':'. If $volume and $directory are empty, a leading ":" (if any)
  is removed form $file and the remainder is returned. If $file is empty, the
  resulting path will have a trailing ':'.
  
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( (! $volume) && (! $directory) ) {
  	$file =~ s/^:// if $file;
  	return $file ;
      }
  
      # We look for a volume in $volume, then in $directory, but not both
  
      my ($dir_volume, $dir_dirs) = $self->splitpath($directory, 1);
  
      $volume = $dir_volume unless length $volume;
      my $path = $volume; # may be ''
      $path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
  
      if ($directory) {
  	$directory = $dir_dirs if $volume;
  	$directory =~ s/^://; # remove leading ':' if any
  	$path .= $directory;
  	$path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
      }
  
      if ($file) {
  	$file =~ s/^://; # remove leading ':' if any
  	$path .= $file;
      }
  
      return $path;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path and returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then the current working directory is used.
  If $base is relative, then it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  If $path and $base appear to be on two different volumes, we will not
  attempt to resolve the two paths, and we will instead simply return
  $path.  Note that previous versions of this module ignored the volume
  of $base, which resulted in garbage results part of the time.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is relative, it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  Based on code written by Shigio Yamaguchi.
  
  
  =cut
  
  # maybe this should be done in canonpath() ?
  sub _resolve_updirs {
  	my $path = shift @_;
  	my $proceed;
  
  	# resolve any updirs, e.g. "HD:tmp::file" -> "HD:file"
  	do {
  		$proceed = ($path =~ s/^(.*):[^:]+::(.*?)\z/$1:$2/);
  	} while ($proceed);
  
  	return $path;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = $self->_cwd();
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
  	$base = _resolve_updirs( $base ); # resolve updirs in $base
      }
      else {
  	$base = _resolve_updirs( $base );
      }
  
      # Split up paths - ignore $base's file
      my ( $path_vol, $path_dirs, $path_file ) =  $self->splitpath( $path );
      my ( $base_vol, $base_dirs )             =  $self->splitpath( $base );
  
      return $path unless lc( $path_vol ) eq lc( $base_vol );
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_dirs );
      my @basechunks = $self->splitdir( $base_dirs );
  	
      while ( @pathchunks &&
  	    @basechunks &&
  	    lc( $pathchunks[0] ) eq lc( $basechunks[0] ) ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @pathchunks now has the directories to descend in to.
      # ensure relative path, even if @pathchunks is empty
      $path_dirs = $self->catdir( ':', @pathchunks );
  
      # @basechunks now contains the number of directories to climb out of.
      $base_dirs = (':' x @basechunks) . ':' ;
  
      return $self->catpath( '', $self->catdir( $base_dirs, $path_dirs ), $path_file ) ;
  }
  
  =item rel2abs
  
  Converts a relative path to an absolute path:
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then $base is set to the current working
  directory. If $base is relative, then it is converted to absolute form
  using C<rel2abs()>. This means that it is taken to be relative to the
  current working directory.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is already absolute, it is returned and $base is ignored.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base) = @_;
  
      if ( ! $self->file_name_is_absolute($path) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute($base) ) {
              $base = $self->rel2abs($base) ;
          }
  
  	# Split up paths
  
  	# igonore $path's volume
          my ( $path_dirs, $path_file ) = ($self->splitpath($path))[1,2] ;
  
          # ignore $base's file part
  	my ( $base_vol, $base_dirs ) = $self->splitpath($base) ;
  
  	# Glom them together
  	$path_dirs = ':' if ($path_dirs eq '');
  	$base_dirs =~ s/:$//; # remove trailing ':', if any
  	$base_dirs = $base_dirs . $path_dirs;
  
          $path = $self->catpath( $base_vol, $base_dirs, $path_file );
      }
      return $path;
  }
  
  
  =back
  
  =head1 AUTHORS
  
  See the authors list in I<File::Spec>. Mac OS support by Paul Schinder
  <schinder@pobox.com> and Thomas Wegner <wegner_thomas@yahoo.com>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
DARWIN-2LEVEL_FILE_SPEC_MAC

$fatpacked{"darwin-2level/File/Spec/OS2.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_OS2';
  package File::Spec::OS2;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.33';
  $VERSION = eval $VERSION;
  
  @ISA = qw(File::Spec::Unix);
  
  sub devnull {
      return "/dev/nul";
  }
  
  sub case_tolerant {
      return 1;
  }
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m{^([a-z]:)?[\\/]}is);
  }
  
  sub path {
      my $path = $ENV{PATH};
      $path =~ s:\\:/:g;
      my @path = split(';',$path);
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  sub _cwd {
      # In OS/2 the "require Cwd" is unnecessary bloat.
      return Cwd::sys_cwd();
  }
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      my @d = @ENV{qw(TMPDIR TEMP TMP)};	# function call could autovivivy
      $tmpdir = $_[0]->_tmpdir( @d, '/tmp', '/'  );
  }
  
  sub catdir {
      my $self = shift;
      my @args = @_;
      foreach (@args) {
  	tr[\\][/];
          # append a backslash to each argument unless it has one there
          $_ .= "/" unless m{/$};
      }
      return $self->canonpath(join('', @args));
  }
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s/^([a-z]:)/\l$1/s;
      $path =~ s|\\|/|g;
      $path =~ s|([^/])/+|$1/|g;                  # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                     # xx/././xx -> xx/xx
      $path =~ s|^(\./)+(?=[^/])||s;		# ./xx      -> xx
      $path =~ s|/\Z(?!\n)||
               unless $path =~ m#^([a-z]:)?/\Z(?!\n)#si;# xx/       -> xx
      $path =~ s{^/\.\.$}{/};                     # /..    -> /
      1 while $path =~ s{^/\.\.}{};               # /../xx -> /xx
      return $path;
  }
  
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^( (?:[a-zA-Z]:|(?:\\\\|//)[^\\/]+[\\/][^\\/]+)? ) 
                   (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( (?: [a-zA-Z]: |
                        (?:\\\\|//)[^\\/]+[\\/][^\\/]+
                    )?
                  )
                  ( (?:.*[\\\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      split m|[\\/]|, $directories, -1;
  }
  
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      $volume .= $1
          if ( $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '/' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      } else {
          $path = $self->canonpath( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = $self->_cwd();
      } elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
      } else {
          $base = $self->canonpath( $base ) ;
      }
  
      # Split up paths
      my ( $path_volume, $path_directories, $path_file ) = $self->splitpath( $path, 1 ) ;
      my ( $base_volume, $base_directories ) = $self->splitpath( $base, 1 ) ;
      return $path unless $path_volume eq $base_volume;
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # No need to catdir, we know these are well formed.
      $path_directories = CORE::join( '/', @pathchunks );
      $base_directories = CORE::join( '/', @basechunks );
  
      # $base_directories now contains the directories the resulting relative
      # path must ascend out of before it can descend to $path_directory.  So, 
      # replace all names with $parentDir
  
      #FA Need to replace between backslashes...
      $base_directories =~ s|[^\\/]+|..|g ;
  
      # Glue the two together, using a separator if necessary, and preventing an
      # empty result.
  
      #FA Must check that new directories are not empty.
      if ( $path_directories ne '' && $base_directories ne '' ) {
          $path_directories = "$base_directories/$path_directories" ;
      } else {
          $path_directories = "$base_directories$path_directories" ;
      }
  
      return $self->canonpath( 
          $self->catpath( "", $path_directories, $path_file ) 
      ) ;
  }
  
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      if ( ! $self->file_name_is_absolute( $path ) ) {
  
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path, 1 ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base, 1 ) ;
  
          $path = $self->catpath( 
              $base_volume, 
              $self->catdir( $base_directories, $path_directories ), 
              $path_file
          ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::OS2 - methods for OS/2 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::OS2; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  Amongst the changes made for OS/2 are...
  
  =over 4
  
  =item tmpdir
  
  Modifies the list of places temp directory information is looked for.
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      /tmp
      /
  
  =item splitpath
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_FILE_SPEC_OS2

$fatpacked{"darwin-2level/File/Spec/Unix.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_UNIX';
  package File::Spec::Unix;
  
  use strict;
  use vars qw($VERSION);
  
  $VERSION = '3.33';
  $VERSION = eval $VERSION;
  
  =head1 NAME
  
  File::Spec::Unix - File::Spec for Unix, base for other File::Spec modules
  
  =head1 SYNOPSIS
  
   require File::Spec::Unix; # Done automatically by File::Spec
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.  Other File::Spec
  modules, such as File::Spec::Mac, inherit from File::Spec::Unix and
  override specific methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminates successive slashes and successive "/.".
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
      
      # Handle POSIX-style node names beginning with double slash (qnx, nto)
      # (POSIX says: "a pathname that begins with two successive slashes
      # may be interpreted in an implementation-defined manner, although
      # more than two leading slashes shall be treated as a single slash.")
      my $node = '';
      my $double_slashes_special = $^O eq 'qnx' || $^O eq 'nto';
  
  
      if ( $double_slashes_special
           && ( $path =~ s{^(//[^/]+)/?\z}{}s || $path =~ s{^(//[^/]+)/}{/}s ) ) {
        $node = $1;
      }
      # This used to be
      # $path =~ s|/+|/|g unless ($^O eq 'cygwin');
      # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail
      # (Mainly because trailing "" directories didn't get stripped).
      # Why would cygwin avoid collapsing multiple slashes into one? --jhi
      $path =~ s|/{2,}|/|g;                            # xx////xx  -> xx/xx
      $path =~ s{(?:/\.)+(?:/|\z)}{/}g;                # xx/././xx -> xx/xx
      $path =~ s|^(?:\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(?:\.\./)+|/|;                      # /../../xx -> xx
      $path =~ s|^/\.\.$|/|;                         # /..       -> /
      $path =~ s|/\z|| unless $path eq "/";          # xx/       -> xx
      return "$node$path";
  }
  
  =item catdir()
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
  =cut
  
  sub catdir {
      my $self = shift;
  
      $self->canonpath(join('/', @_, '')); # '' because need a trailing '/'
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub catfile {
      my $self = shift;
      my $file = $self->canonpath(pop @_);
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $dir .= "/" unless substr($dir,-1) eq "/";
      return $dir.$file;
  }
  
  =item curdir
  
  Returns a string representation of the current directory.  "." on UNIX.
  
  =cut
  
  sub curdir { '.' }
  
  =item devnull
  
  Returns a string representation of the null device. "/dev/null" on UNIX.
  
  =cut
  
  sub devnull { '/dev/null' }
  
  =item rootdir
  
  Returns a string representation of the root directory.  "/" on UNIX.
  
  =cut
  
  sub rootdir { '/' }
  
  =item tmpdir
  
  Returns a string representation of the first writable directory from
  the following list or the current directory if none from the list are
  writable:
  
      $ENV{TMPDIR}
      /tmp
  
  Since perl 5.8.0, if running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  my $tmpdir;
  sub _tmpdir {
      return $tmpdir if defined $tmpdir;
      my $self = shift;
      my @dirlist = @_;
      {
  	no strict 'refs';
  	if (${"\cTAINT"}) { # Check for taint mode on perl >= 5.8.0
              require Scalar::Util;
  	    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;
  	}
      }
      foreach (@dirlist) {
  	next unless defined && -d && -w _;
  	$tmpdir = $_;
  	last;
      }
      $tmpdir = $self->curdir unless defined $tmpdir;
      $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);
      return $tmpdir;
  }
  
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, "/tmp" );
  }
  
  =item updir
  
  Returns a string representation of the parent directory.  ".." on UNIX.
  
  =cut
  
  sub updir { '..' }
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
  =cut
  
  sub no_upwards {
      my $self = shift;
      return grep(!/^\.{1,2}\z/s, @_);
  }
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  is not or is significant when comparing file specifications.
  
  =cut
  
  sub case_tolerant { 0 }
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true if it is an absolute path.
  
  This does not consult the local filesystem on Unix, Win32, OS/2 or Mac 
  OS (Classic).  It does consult the working environment for VMS (see
  L<File::Spec::VMS/file_name_is_absolute>).
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m:^/:s);
  }
  
  =item path
  
  Takes no argument, returns the environment variable PATH as an array.
  
  =cut
  
  sub path {
      return () unless exists $ENV{PATH};
      my @path = split(':', $ENV{PATH});
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  =item join
  
  join is the same as catfile.
  
  =cut
  
  sub join {
      my $self = shift;
      return $self->catfile(@_);
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path, $no_file );
  
  Splits a path into volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless $no_file is true or a 
  trailing separator or /. or /.. is present. On Unix this means that $no_file
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
  
      my ($volume,$directory,$file) = ('','','');
  
      if ( $nofile ) {
          $directory = $path;
      }
      else {
          $path =~ m|^ ( (?: .* / (?: \.\.?\z )? )? ) ([^/]*) |xs;
          $directory = $1;
          $file      = $2;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L</catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSs.
  
  On Unix,
  
      File::Spec->splitdir( "/a/b//c/" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      return split m|/|, $_[1], -1;  # Preserve trailing fields
  }
  
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and directory and file are concatenated.  A '/' is
  inserted if needed (though if the directory portion doesn't start with
  '/' it is not added).  On other OSs, $volume is significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( $directory ne ''                && 
           $file ne ''                     && 
           substr( $directory, -1 ) ne '/' && 
           substr( $file, 0, 1 ) ne '/' 
      ) {
          $directory .= "/$file" ;
      }
      else {
          $directory .= $file ;
      }
  
      return $directory ;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<cwd()|Cwd>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub abs2rel {
      my($self,$path,$base) = @_;
      $base = $self->_cwd() unless defined $base and length $base;
  
      ($path, $base) = map $self->canonpath($_), $path, $base;
  
      if (grep $self->file_name_is_absolute($_), $path, $base) {
  	($path, $base) = map $self->rel2abs($_), $path, $base;
      }
      else {
  	# save a couple of cwd()s if both paths are relative
  	($path, $base) = map $self->catdir('/', $_), $path, $base;
      }
  
      my ($path_volume) = $self->splitpath($path, 1);
      my ($base_volume) = $self->splitpath($base, 1);
  
      # Can't relativize across volumes
      return $path unless $path_volume eq $base_volume;
  
      my $path_directories = ($self->splitpath($path, 1))[1];
      my $base_directories = ($self->splitpath($base, 1))[1];
  
      # For UNC paths, the user might give a volume like //foo/bar that
      # strictly speaking has no directory portion.  Treat it as if it
      # had the root directory for that volume.
      if (!length($base_directories) and $self->file_name_is_absolute($base)) {
        $base_directories = $self->rootdir;
      }
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      if ($base_directories eq $self->rootdir) {
        shift @pathchunks;
        return $self->canonpath( $self->catpath('', $self->catdir( @pathchunks ), '') );
      }
  
      while (@pathchunks && @basechunks && $self->_same($pathchunks[0], $basechunks[0])) {
          shift @pathchunks ;
          shift @basechunks ;
      }
      return $self->curdir unless @pathchunks || @basechunks;
  
      # $base now contains the directories the resulting relative path 
      # must ascend out of before it can descend to $path_directory.
      my $result_dirs = $self->catdir( ($self->updir) x @basechunks, @pathchunks );
      return $self->canonpath( $self->catpath('', $result_dirs, '') );
  }
  
  sub _same {
    $_[1] eq $_[2];
  }
  
  =item rel2abs()
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores
  the $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is absolute, it is cleaned up and returned using L</canonpath()>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Glom them together
          $path = $self->catdir( $base, $path ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<File::Spec>
  
  =cut
  
  # Internal routine to File::Spec, no point in making this public since
  # it is the standard Cwd interface.  Most of the platform-specific
  # File::Spec subclasses use this.
  sub _cwd {
      require Cwd;
      Cwd::getcwd();
  }
  
  
  # Internal method to reduce xx\..\yy -> yy
  sub _collapse {
      my($fs, $path) = @_;
  
      my $updir  = $fs->updir;
      my $curdir = $fs->curdir;
  
      my($vol, $dirs, $file) = $fs->splitpath($path);
      my @dirs = $fs->splitdir($dirs);
      pop @dirs if @dirs && $dirs[-1] eq '';
  
      my @collapsed;
      foreach my $dir (@dirs) {
          if( $dir eq $updir              and   # if we have an updir
              @collapsed                  and   # and something to collapse
              length $collapsed[-1]       and   # and its not the rootdir
              $collapsed[-1] ne $updir    and   # nor another updir
              $collapsed[-1] ne $curdir         # nor the curdir
            ) 
          {                                     # then
              pop @collapsed;                   # collapse
          }
          else {                                # else
              push @collapsed, $dir;            # just hang onto it
          }
      }
  
      return $fs->catpath($vol,
                          $fs->catdir(@collapsed),
                          $file
                         );
  }
  
  
  1;
DARWIN-2LEVEL_FILE_SPEC_UNIX

$fatpacked{"darwin-2level/File/Spec/VMS.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_VMS';
  package File::Spec::VMS;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.33';
  $VERSION = eval $VERSION;
  
  @ISA = qw(File::Spec::Unix);
  
  use File::Basename;
  use VMS::Filespec;
  
  =head1 NAME
  
  File::Spec::VMS - methods for VMS file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::VMS; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  The default behavior is to allow either VMS or Unix syntax on input and to 
  return VMS syntax on output, even when Unix syntax was given on input.
  
  When used with a Perl of version 5.10 or greater and a CRTL possessing the
  relevant capabilities, override behavior depends on the CRTL features
  C<DECC$FILENAME_UNIX_REPORT> and C<DECC$EFS_CHARSET>.  When the
  C<DECC$EFS_CHARSET> feature is enabled and the input parameters are clearly
  in Unix syntax, the output will be in Unix syntax.  If
  C<DECC$FILENAME_UNIX_REPORT> is enabled and the output syntax cannot be
  determined from the input syntax, the output will be in Unix syntax.
  
  =over 4
  
  =cut
  
  # Need to look up the feature settings.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_feature;
  BEGIN {
      if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
          $use_feature = 1;
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _unix_rpt {
      my $unix_rpt;
      if ($use_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  # Need to look up the EFS character set mode.  This may become a dynamic
  # mode in the future.
  sub _efs {
      my $efs;
      if ($use_feature) {
          $efs = VMS::Feature::current("efs_charset");
      } else {
          my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
          $efs = $env_efs =~ /^[ET1]/i; 
      }
      return $efs;
  }
  
  =item canonpath (override)
  
  Removes redundant portions of file specifications according to the syntax
  detected.
  
  =cut
  
  
  sub canonpath {
      my($self,$path) = @_;
  
      return undef unless defined $path;
  
      my $efs = $self->_efs;
  
      if ($path =~ m|/|) { # Fake Unix
        my $pathify = $path =~ m|/\Z(?!\n)|;
        $path = $self->SUPER::canonpath($path);
  
        # Do not convert to VMS when EFS character sets are in use
        return $path if $efs;
  
        if ($pathify) { return vmspath($path); }
        else          { return vmsify($path);  }
      }
      else {
  
  #FIXME - efs parsing has different rules.  Characters in a VMS filespec
  #        are only delimiters if not preceded by '^';
  
  	$path =~ tr/<>/[]/;			# < and >       ==> [ and ]
  	$path =~ s/\]\[\./\.\]\[/g;		# ][.		==> .][
  	$path =~ s/\[000000\.\]\[/\[/g;		# [000000.][	==> [
  	$path =~ s/\[000000\./\[/g;		# [000000.	==> [
  	$path =~ s/\.\]\[000000\]/\]/g;		# .][000000]	==> ]
  	$path =~ s/\.\]\[/\./g;			# foo.][bar     ==> foo.bar
  	1 while ($path =~ s/([\[\.])(-+)\.(-+)([\.\]])/$1$2$3$4/);
  						# That loop does the following
  						# with any amount of dashes:
  						# .-.-.		==> .--.
  						# [-.-.		==> [--.
  						# .-.-]		==> .--]
  						# [-.-]		==> [--]
  	1 while ($path =~ s/([\[\.])[^\]\.]+\.-(-+)([\]\.])/$1$2$3/);
  						# That loop does the following
  						# with any amount (minimum 2)
  						# of dashes:
  						# .foo.--.	==> .-.
  						# .foo.--]	==> .-]
  						# [foo.--.	==> [-.
  						# [foo.--]	==> [-]
  						#
  						# And then, the remaining cases
  	$path =~ s/\[\.-/[-/;			# [.-		==> [-
  	$path =~ s/\.[^\]\.]+\.-\./\./g;	# .foo.-.	==> .
  	$path =~ s/\[[^\]\.]+\.-\./\[/g;	# [foo.-.	==> [
  	$path =~ s/\.[^\]\.]+\.-\]/\]/g;	# .foo.-]	==> ]
  	$path =~ s/\[[^\]\.]+\.-\]/\[000000\]/g;# [foo.-]       ==> [000000]
  	$path =~ s/\[\]// unless $path eq '[]';	# []		==>
  	return $path;
      }
  }
  
  =item catdir (override)
  
  Concatenates a list of file specifications, and returns the result as a
  directory specification.  No check is made for "impossible"
  cases (e.g. elements other than the first being absolute filespecs).
  
  =cut
  
  sub catdir {
      my $self = shift;
      my $dir = pop;
  
      my $efs = $self->_efs;
      my $unix_rpt = $self->_unix_rpt;
  
  
      my @dirs = grep {defined() && length()} @_;
      if ($efs) {
          # Legacy mode removes blank entries.
          # But that breaks existing generic perl code that
          # uses a blank path at the beginning of the array
          # to indicate an absolute path.
          # So put it back if found.
          if (@_) {
              if ($_[0] eq '') {
                  unshift @dirs, '';
              }
          }
      }
  
      my $rslt;
      if (@dirs) {
  	my $path = (@dirs == 1 ? $dirs[0] : $self->catdir(@dirs));
  	my ($spath,$sdir) = ($path,$dir);
  
          if ($efs) {
              # Extended character set in use, go into DWIM mode.
  
              # Now we need to identify what the directory is in
              # of the specification in order to merge them.
              my $path_unix = 0;
              $path_unix = 1 if ($path =~ m#/#);
              $path_unix = 1 if ($path =~ /^\.\.?$/);
              my $path_vms = 0;
              $path_vms = 1 if ($path =~ m#(?<!\^)[\[<\]:]#);
              $path_vms = 1 if ($path =~ /^--?$/);
              my $dir_unix = 0;
              $dir_unix = 1 if ($dir =~ m#/#);
              $dir_unix = 1 if ($dir =~ /^\.\.?$/);
              my $dir_vms = 0;
              $dir_vms = 1 if ($dir =~ m#(?<!\^)[\[<\]:]#);
              $dir_vms = 1 if ($dir =~ /^--?$/);
  
              my $unix_mode = 0;
              if (($path_unix != $dir_unix) && ($path_vms != $dir_vms)) {
                  # Ambiguous, so if in $unix_rpt mode then assume UNIX.
                  $unix_mode = 1 if $unix_rpt;
              } else {
                  $unix_mode = 1 if (!$path_vms && !$dir_vms && $unix_rpt);
                  $unix_mode = 1 if ($path_unix || $dir_unix);
              }
  
              if ($unix_mode) {
  
                  # Fix up mixed syntax imput as good as possible - GIGO
                  $path = unixify($path) if $path_vms;
                  $dir = unixify($dir) if $dir_vms;
  
                  $rslt = $path;
                  # Append a path delimiter
                  $rslt .= '/' unless ($rslt =~ m#/$#);
  
                  $rslt .= $dir;
                  return $self->SUPER::canonpath($rslt);
              } else {
  
                  #with <> posible instead of [.
                  # Normalize the brackets
                  # Fixme - need to not switch when preceded by ^.
                  $path =~ s/</\[/g;
                  $path =~ s/>/\]/g;
                  $dir =~ s/</\[/g;
                  $dir =~ s/>/\]/g;
  
                  # Fix up mixed syntax imput as good as possible - GIGO
                  $path = vmsify($path) if $path_unix;
                  $dir = vmsify($dir) if $dir_unix;
  
                  #Possible path values: foo: [.foo] [foo] foo, and $(foo)
                  #or starting with '-', or foo.dir
                  #If path is foo, it needs to be converted to [.foo]
  
                  # Fix up a bare path name.
                  unless ($path_vms) {
                      $path =~ s/\.dir\Z(?!\n)//i;
                      if (($path ne '') && ($path !~ /^-/)) {
                          # Non blank and not prefixed with '-', add a dot
                          $path = '[.' . $path;
                      } else {
                          # Just start a directory.
                          $path = '[' . $path;
                      }
                  } else {
                      $path =~ s/\]$//;
                  }
  
                  #Possible dir values: [.dir] dir and $(foo)
  
                  # No punctuation may have a trailing .dir
                  unless ($dir_vms) {
                      $dir =~ s/\.dir\Z(?!\n)//i;
                  } else {
  
                      #strip off the brackets
                      $dir =~ s/^\[//;
                      $dir =~ s/\]$//;
                  }
  
                  #strip off the leading dot if present.
                  $dir =~ s/^\.//;
  
                  # Now put the specifications together.
                  if ($dir ne '') {
                      # Add a separator unless this is an absolute path
                      $path .= '.' if ($path ne '[');
                      $rslt = $path . $dir . ']';
                  } else {
                      $rslt = $path . ']';
                  }
              }
  
  	} else {
  	    # Traditional ODS-2 mode.
  	    $spath =~ s/\.dir\Z(?!\n)//i; $sdir =~ s/\.dir\Z(?!\n)//i; 
  
  	    $sdir = $self->eliminate_macros($sdir)
  		unless $sdir =~ /^[\w\-]+\Z(?!\n)/s;
  	    $rslt = $self->fixpath($self->eliminate_macros($spath)."/$sdir",1);
  
  	    # Special case for VMS absolute directory specs: these will have
  	    # had device prepended during trip through Unix syntax in
  	    # eliminate_macros(), since Unix syntax has no way to express
  	    # "absolute from the top of this device's directory tree".
  	    if ($spath =~ /^[\[<][^.\-]/s) { $rslt =~ s/^[^\[<]+//s; }
  	} 
      } else {
  	# Single directory, just make sure it is in directory format
  	# Return an empty string on null input, and pass through macros.
  
  	if    (not defined $dir or not length $dir) { $rslt = ''; }
  	elsif ($dir =~ /^\$\([^\)]+\)\Z(?!\n)/s) { 
  	    $rslt = $dir;
  	} else {
              my $unix_mode = 0;
  
              if ($efs) {
                  my $dir_unix = 0;
                  $dir_unix = 1 if ($dir =~ m#/#);
                  $dir_unix = 1 if ($dir =~ /^\.\.?$/);
                  my $dir_vms = 0;
                  $dir_vms = 1 if ($dir =~ m#(?<!\^)[\[<\]:]#);
                  $dir_vms = 1 if ($dir =~ /^--?$/);
  
                  if ($dir_vms == $dir_unix) {
                      # Ambiguous, so if in $unix_rpt mode then assume UNIX.
                      $unix_mode = 1 if $unix_rpt;
                  } else {
                      $unix_mode = 1 if $dir_unix;
                  }
              }
  
              if ($unix_mode) {
                  return $dir;
              } else {
                  # For VMS, force it to be in directory format
  	 	$rslt = vmspath($dir);
  	    }
  	}
      }
      return $self->canonpath($rslt);
  }
  
  =item catfile (override)
  
  Concatenates a list of directory specifications with a filename specification
  to build a path.
  
  =cut
  
  sub catfile {
      my $self = shift;
      my $tfile = pop();
      my $file = $self->canonpath($tfile);
      my @files = grep {defined() && length()} @_;
  
      my $efs = $self->_efs;
      my $unix_rpt = $self->_unix_rpt;
  
      # Assume VMS mode
      my $unix_mode = 0;
      my $file_unix = 0;
      my $file_vms = 0;
      if ($efs) {
  
          # Now we need to identify format the file is in
          # of the specification in order to merge them.
          $file_unix = 1 if ($tfile =~ m#/#);
          $file_unix = 1 if ($tfile =~ /^\.\.?$/);
          $file_vms = 1 if ($tfile =~ m#(?<!\^)[\[<\]:]#);
          $file_vms = 1 if ($tfile =~ /^--?$/);
  
          # We may know for sure what the format is.
          if (($file_unix != $file_vms)) {
              $unix_mode = 1 if ($file_unix && $unix_rpt);
          }
      }
  
      my $rslt;
      if (@files) {
  	# concatenate the directories.
  	my $path;
          if (@files == 1) {
             $path = $files[0];
          } else {
              if ($file_vms) {
                  # We need to make sure this is in VMS mode to avoid doing
                  # both a vmsify and unixfy on the same path, as that may
                  # lose significant data.
                  my $i = @files - 1;
                  my $tdir = $files[$i];
                  my $tdir_vms = 0;
                  my $tdir_unix = 0;
                  $tdir_vms = 1 if ($tdir =~ m#(?<!\^)[\[<\]:]#);
                  $tdir_unix = 1 if ($tdir =~ m#/#);
                  $tdir_unix = 1 if ($tdir =~ /^\.\.?$/);
  
                  if (!$tdir_vms) {
                      if ($tdir_unix) { 
                          $tdir = vmspath($tdir);
                      } else {
                          $tdir =~ s/\.dir\Z(?!\n)//i;
                          $tdir = '[.' . $tdir . ']';
                      }
                      $files[$i] = $tdir;
                  }
              }
              $path = $self->catdir(@files);
          }
  	my $spath = $path;
  
          # Some thing building a VMS path in pieces may try to pass a
          # directory name in filename format, so normalize it.
  	$spath =~ s/\.dir\Z(?!\n)//i;
  
          # if the spath ends with a directory delimiter and the file is bare,
          # then just concat them.
  	if ($spath =~ /^(?<!\^)[^\)\]\/:>]+\)\Z(?!\n)/s && basename($file) eq $file) {
  	    $rslt = "$spath$file";
  	} else {
              if ($efs) {
  
                  # Now we need to identify what the directory is in
                  # of the specification in order to merge them.
                  my $spath_unix = 0;
                  $spath_unix = 1 if ($spath =~ m#/#);
                  $spath_unix = 1 if ($spath =~ /^\.\.?$/);
                  my $spath_vms = 0;
                  $spath_vms = 1 if ($spath =~ m#(?<!\^)[\[<\]:]#);
                  $spath_vms = 1 if ($spath =~ /^--?$/);
  
                  # Assume VMS mode
                  if (($spath_unix == $spath_vms) &&
                      ($file_unix == $file_vms)) {
                       # Ambigous, so if in $unix_rpt mode then assume UNIX.
                       $unix_mode = 1 if $unix_rpt;
                  } else {
                       $unix_mode = 1
                           if (($spath_unix || $file_unix) && $unix_rpt);
                  }
  
                  if (!$unix_mode) {
                      if ($spath_vms) {
                          $spath = '[' . $spath . ']' if $spath =~ /^-/;
                          $rslt = vmspath($spath);
                      } else {
                          $rslt = '[.' . $spath . ']';
                      }
                      $file = vmsify($file) if ($file_unix);
                  } else {
                      $spath = unixify($spath) if ($spath_vms);
                      $rslt = $spath;
                      $file = unixify($file) if ($file_vms);
  
                      # Unix merge may need a directory delimitor.
                      # A null path indicates root on Unix.
                      $rslt .= '/' unless ($rslt =~ m#/$#);
                  }
  
                  $rslt .= $file;
                  $rslt =~ s/\]\[//;
  
  	    } else {
  		# Traditional VMS Perl mode expects that this is done.
  		# Note for future maintainers:
  		# This is left here for compatibility with perl scripts
  		# that have come to expect this behavior, even though
  		# usually the Perl scripts ported to VMS have to be
  		# patched because of it changing Unix syntax file
  		# to VMS format.
  
  		$rslt = $self->eliminate_macros($spath);
  
  
  	        $rslt = vmsify($rslt.((defined $rslt) &&
  		    ($rslt ne '') ? '/' : '').unixify($file));
  	    }
  	}
      }
      else {
          # Only passed a single file?
          my $xfile = $file;
  
          # Traditional VMS perl expects this conversion.
          $xfile = vmsify($file) unless ($efs);
  
          $rslt = (defined($file) && length($file)) ? $xfile : '';
      }
      return $self->canonpath($rslt) unless $unix_rpt;
  
      # In Unix report mode, do not strip off redundent path information.
      return $rslt;
  }
  
  
  =item curdir (override)
  
  Returns a string representation of the current directory: '[]' or '.'
  
  =cut
  
  sub curdir {
      my $self = shift @_;
      return '.' if ($self->_unix_rpt);
      return '[]';
  }
  
  =item devnull (override)
  
  Returns a string representation of the null device: '_NLA0:' or '/dev/null'
  
  =cut
  
  sub devnull {
      my $self = shift @_;
      return '/dev/null' if ($self->_unix_rpt);
      return "_NLA0:";
  }
  
  =item rootdir (override)
  
  Returns a string representation of the root directory: 'SYS$DISK:[000000]'
  or '/'
  
  =cut
  
  sub rootdir {
      my $self = shift @_;
      if ($self->_unix_rpt) {
         # Root may exist, try it first.
         my $try = '/';
         my ($dev1, $ino1) = stat('/');
         my ($dev2, $ino2) = stat('.');
  
         # Perl falls back to '.' if it can not determine '/'
         if (($dev1 != $dev2) || ($ino1 != $ino2)) {
             return $try;
         }
         # Fall back to UNIX format sys$disk.
         return '/sys$disk/';
      }
      return 'SYS$DISK:[000000]';
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first writable directory
  from the following list or '' if none are writable:
  
      /tmp if C<DECC$FILENAME_UNIX_REPORT> is enabled.
      sys$scratch:
      $ENV{TMPDIR}
  
  Since perl 5.8.0, if running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      my $self = shift @_;
      return $tmpdir if defined $tmpdir;
      if ($self->_unix_rpt) {
          $tmpdir = $self->_tmpdir('/tmp', '/sys$scratch', $ENV{TMPDIR});
          return $tmpdir;
      }
  
      $tmpdir = $self->_tmpdir( 'sys$scratch:', $ENV{TMPDIR} );
  }
  
  =item updir (override)
  
  Returns a string representation of the parent directory: '[-]' or '..'
  
  =cut
  
  sub updir {
      my $self = shift @_;
      return '..' if ($self->_unix_rpt);
      return '[-]';
  }
  
  =item case_tolerant (override)
  
  VMS file specification syntax is case-tolerant.
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =item path (override)
  
  Translate logical name DCL$PATH as a searchlist, rather than trying
  to C<split> string value of C<$ENV{'PATH'}>.
  
  =cut
  
  sub path {
      my (@dirs,$dir,$i);
      while ($dir = $ENV{'DCL$PATH;' . $i++}) { push(@dirs,$dir); }
      return @dirs;
  }
  
  =item file_name_is_absolute (override)
  
  Checks for VMS directory spec as well as Unix separators.
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      # If it's a logical name, expand it.
      $file = $ENV{$file} while $file =~ /^[\w\$\-]+\Z(?!\n)/s && $ENV{$file};
      return scalar($file =~ m!^/!s             ||
  		  $file =~ m![<\[][^.\-\]>]!  ||
  		  $file =~ /:[^<\[]/);
  }
  
  =item splitpath (override)
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path, $no_file );
  
  Passing a true value for C<$no_file> indicates that the path being
  split only contains directory components, even on systems where you
  can usually (when not supporting a foreign syntax) tell the difference
  between directories and files at a glance.
  
  =cut
  
  sub splitpath {
      my($self,$path, $nofile) = @_;
      my($dev,$dir,$file)      = ('','','');
      my $efs = $self->_efs;
      my $vmsify_path = vmsify($path);
      if ($efs) {
          my $path_vms = 0;
          $path_vms = 1 if ($path =~ m#(?<!\^)[\[<\]:]#);
          $path_vms = 1 if ($path =~ /^--?$/);
          if (!$path_vms) {
              return $self->SUPER::splitpath($path, $nofile);
          }
          $vmsify_path = $path;
      }
  
      if ( $nofile ) {
          #vmsify('d1/d2/d3') returns '[.d1.d2]d3'
          #vmsify('/d1/d2/d3') returns 'd1:[d2]d3'
          if( $vmsify_path =~ /(.*)\](.+)/ ){
              $vmsify_path = $1.'.'.$2.']';
          }
          $vmsify_path =~ /(.+:)?(.*)/s;
          $dir = defined $2 ? $2 : ''; # dir can be '0'
          return ($1 || '',$dir,$file);
      }
      else {
          $vmsify_path =~ /(.+:)?([\[<].*[\]>])?(.*)/s;
          return ($1 || '',$2 || '',$3);
      }
  }
  
  =item splitdir (override)
  
  Split a directory specification into the components.
  
  =cut
  
  sub splitdir {
      my($self,$dirspec) = @_;
      my @dirs = ();
      return @dirs if ( (!defined $dirspec) || ('' eq $dirspec) );
  
      my $efs = $self->_efs;
  
      my $dir_unix = 0;
      $dir_unix = 1 if ($dirspec =~ m#/#);
      $dir_unix = 1 if ($dirspec =~ /^\.\.?$/);
  
      # Unix filespecs in EFS mode handled by Unix routines.
      if ($efs && $dir_unix) {
          return $self->SUPER::splitdir($dirspec);
      }
  
      # FIX ME, only split for VMS delimiters not prefixed with '^'.
  
      $dirspec =~ tr/<>/[]/;			# < and >	==> [ and ]
      $dirspec =~ s/\]\[\./\.\]\[/g;		# ][.		==> .][
      $dirspec =~ s/\[000000\.\]\[/\[/g;		# [000000.][	==> [
      $dirspec =~ s/\[000000\./\[/g;		# [000000.	==> [
      $dirspec =~ s/\.\]\[000000\]/\]/g;		# .][000000]	==> ]
      $dirspec =~ s/\.\]\[/\./g;			# foo.][bar	==> foo.bar
      while ($dirspec =~ s/(^|[\[\<\.])\-(\-+)($|[\]\>\.])/$1-.$2$3/g) {}
  						# That loop does the following
  						# with any amount of dashes:
  						# .--.		==> .-.-.
  						# [--.		==> [-.-.
  						# .--]		==> .-.-]
  						# [--]		==> [-.-]
      $dirspec = "[$dirspec]" unless $dirspec =~ /(?<!\^)[\[<]/; # make legal
      $dirspec =~ s/^(\[|<)\./$1/;
      @dirs = split /(?<!\^)\./, vmspath($dirspec);
      $dirs[0] =~ s/^[\[<]//s;  $dirs[-1] =~ s/[\]>]\Z(?!\n)//s;
      @dirs;
  }
  
  
  =item catpath (override)
  
  Construct a complete filespec.
  
  =cut
  
  sub catpath {
      my($self,$dev,$dir,$file) = @_;
      
      my $efs = $self->_efs;
      my $unix_rpt = $self->_unix_rpt;
  
      my $unix_mode = 0;
      my $dir_unix = 0;
      $dir_unix = 1 if ($dir =~ m#/#);
      $dir_unix = 1 if ($dir =~ /^\.\.?$/);
      my $dir_vms = 0;
      $dir_vms = 1 if ($dir =~ m#(?<!\^)[\[<\]:]#);
      $dir_vms = 1 if ($dir =~ /^--?$/);
  
      if ($efs && (length($dev) == 0)) {
          if ($dir_unix == $dir_vms) {
              $unix_mode = $unix_rpt;
          } else {
              $unix_mode = $dir_unix;
          }
      } 
  
      # We look for a volume in $dev, then in $dir, but not both
      # but only if using VMS syntax.
      if (!$unix_mode) {
          $dir = vmspath($dir) if $dir_unix;
          my ($dir_volume, $dir_dir, $dir_file) = $self->splitpath($dir);
          $dev = $dir_volume unless length $dev;
          $dir = length $dir_file ? $self->catfile($dir_dir, $dir_file) :
                                    $dir_dir;
      }
      if ($dev =~ m|^/+([^/]+)|) { $dev = "$1:"; }
      else { $dev .= ':' unless $dev eq '' or $dev =~ /:\Z(?!\n)/; }
      if (length($dev) or length($dir)) {
        if ($efs) {
            if ($unix_mode) {
                $dir .= '/' unless ($dir =~ m#/$#);
            } else {
                $dir = vmspath($dir) if (($dir =~ m#/#) || ($dir =~ /^\.\.?$/));
                $dir = "[$dir]" unless $dir =~ /^[\[<]/;
            }
        } else {
            $dir = "[$dir]" unless $dir =~ /[\[<\/]/;
            $dir = vmspath($dir);
        }
      }
      $dir = '' if length($dev) && ($dir eq '[]' || $dir eq '<>');
      "$dev$dir$file";
  }
  
  =item abs2rel (override)
  
  Attempt to convert a file specification to a relative specification.
  On a system with volumes, like VMS, this may not be possible.
  
  =cut
  
  sub abs2rel {
      my $self = shift;
      my($path,$base) = @_;
  
      my $efs = $self->_efs;
      my $unix_rpt = $self->_unix_rpt;
  
      # We need to identify what the directory is in
      # of the specification in order to process them
      my $path_unix = 0;
      $path_unix = 1 if ($path =~ m#/#);
      $path_unix = 1 if ($path =~ /^\.\.?$/);
      my $path_vms = 0;
      $path_vms = 1 if ($path =~ m#(?<!\^)[\[<\]:]#);
      $path_vms = 1 if ($path =~ /^--?$/);
  
      my $unix_mode = 0;
      if ($path_vms == $path_unix) {
          $unix_mode = $unix_rpt;
      } else {
          $unix_mode = $path_unix;
      }
  
      my $base_unix = 0;
      my $base_vms = 0;
  
      if (defined $base) {
          $base_unix = 1 if ($base =~ m#/#);
          $base_unix = 1 if ($base =~ /^\.\.?$/);
          $base_vms = 1 if ($base =~ m#(?<!\^)[\[<\]:]#);
          $base_vms = 1 if ($base =~ /^--?$/);
  
          if ($path_vms == $path_unix) {
              if ($base_vms == $base_unix) {
                  $unix_mode = $unix_rpt;
              } else {
                  $unix_mode = $base_unix;
              }
          } else {
              $unix_mode = 0 if $base_vms;
          }
      }
  
      if ($efs) {
          if ($unix_mode) {
              # We are UNIX mode.
              $base = unixpath($base) if $base_vms;
              $base = unixify($path) if $path_vms;
  
              # Here VMS is different, and in order to do this right
              # we have to take the realpath for both the path and the base
              # so that we can remove the common components.
  
              if ($path =~ m#^/#) {
                  if (defined $base) {
  
                      # For the shorterm, if the starting directories are
                      # common, remove them.
                      my $bq = qq($base);
                      $bq =~ s/\$/\\\$/;
                      $path =~ s/^$bq//i;
                  }
                  return $path;
              }
  
              return File::Spec::Unix::abs2rel( $self, $path, $base );
  
          } else {
              $base = vmspath($base) if $base_unix;
              $path = vmsify($path) if $path_unix;
          }
      }
  
      unless (defined $base and length $base) {
          $base = $self->_cwd();
          if ($efs) {
              $base_unix = 1 if ($base =~ m#/#);
              $base_unix = 1 if ($base =~ /^\.\.?$/);
              $base = vmspath($base) if $base_unix;
          }
      }
  
      for ($path, $base) { $_ = $self->canonpath($_) }
  
      # Are we even starting $path on the same (node::)device as $base?  Note that
      # logical paths or nodename differences may be on the "same device" 
      # but the comparison that ignores device differences so as to concatenate 
      # [---] up directory specs is not even a good idea in cases where there is 
      # a logical path difference between $path and $base nodename and/or device.
      # Hence we fall back to returning the absolute $path spec
      # if there is a case blind device (or node) difference of any sort
      # and we do not even try to call $parse() or consult %ENV for $trnlnm()
      # (this module needs to run on non VMS platforms after all).
      
      my ($path_volume, $path_directories, $path_file) = $self->splitpath($path);
      my ($base_volume, $base_directories, $base_file) = $self->splitpath($base);
      return $path unless lc($path_volume) eq lc($base_volume);
  
      for ($path, $base) { $_ = $self->rel2abs($_) }
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my $pathchunks = @pathchunks;
      unshift(@pathchunks,'000000') unless $pathchunks[0] eq '000000';
      my @basechunks = $self->splitdir( $base_directories );
      my $basechunks = @basechunks;
      unshift(@basechunks,'000000') unless $basechunks[0] eq '000000';
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @basechunks now contains the directories to climb out of,
      # @pathchunks now has the directories to descend in to.
      if ((@basechunks > 0) || ($basechunks != $pathchunks)) {
        $path_directories = join '.', ('-' x @basechunks, @pathchunks) ;
      }
      else {
        $path_directories = join '.', @pathchunks;
      }
      $path_directories = '['.$path_directories.']';
      return $self->canonpath( $self->catpath( '', $path_directories, $path_file ) ) ;
  }
  
  
  =item rel2abs (override)
  
  Return an absolute file specification from a relative one.
  
  =cut
  
  sub rel2abs {
      my $self = shift ;
      my ($path,$base ) = @_;
      return undef unless defined $path;
  
      my $efs = $self->_efs;
      my $unix_rpt = $self->_unix_rpt;
  
      # We need to identify what the directory is in
      # of the specification in order to process them
      my $path_unix = 0;
      $path_unix = 1 if ($path =~ m#/#);
      $path_unix = 1 if ($path =~ /^\.\.?$/);
      my $path_vms = 0;
      $path_vms = 1 if ($path =~ m#(?<!\^)[\[<\]:]#);
      $path_vms = 1 if ($path =~ /^--?$/);
  
      my $unix_mode = 0;
      if ($path_vms == $path_unix) {
          $unix_mode = $unix_rpt;
      } else {
          $unix_mode = $path_unix;
      }
  
      my $base_unix = 0;
      my $base_vms = 0;
  
      if (defined $base) {
          $base_unix = 1 if ($base =~ m#/#);
          $base_unix = 1 if ($base =~ /^\.\.?$/);
          $base_vms = 1 if ($base =~ m#(?<!\^)[\[<\]:]#);
          $base_vms = 1 if ($base =~ /^--?$/);
  
          # If we could not determine the path mode, see if we can find out
          # from the base.
          if ($path_vms == $path_unix) {
              if ($base_vms != $base_unix) {
                  $unix_mode = $base_unix;
              }
          }
      }
  
      if (!$efs) {
          # Legacy behavior, convert to VMS syntax.
          $unix_mode = 0;
          if (defined $base) {
              $base = vmspath($base) if $base =~ m/\//;
          }
  
          if ($path =~ m/\//) {
  	    $path = ( -d $path || $path =~ m/\/\z/  # educated guessing about
  		       ? vmspath($path)             # whether it's a directory
  		       : vmsify($path) );
          }
     }
  
      # Clean up and split up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
              $base = $self->_cwd;
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          if ($efs) {
              # base may have changed, so need to look up format again.
              if ($unix_mode) {
                  $base_vms = 1 if ($base =~ m#(?<!\^)[\[<\]:]#);
                  $base_vms = 1 if ($base =~ /^--?$/);
                  $base = unixpath($base) if $base_vms;
                  $base .= '/' unless ($base =~ m#/$#);
              } else {
                  $base_unix = 1 if ($base =~ m#/#);
                  $base_unix = 1 if ($base =~ /^\.\.?$/);
                  $base = vmspath($base) if $base_unix; 
              }
          }
  
          # Split up paths
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base ) ;
  
          $path_directories = '' if $path_directories eq '[]' ||
                                    $path_directories eq '<>';
          my $sep = '' ;
  
          if ($efs) {
              # Merge the paths assuming that the base is absolute.
              $base_directories = $self->catdir('',
                                                $base_directories,
                                                $path_directories);
          } else {
              # Legacy behavior assumes VMS only paths
              $sep = '.'
                  if ( $base_directories =~ m{[^.\]>]\Z(?!\n)} &&
                       $path_directories =~ m{^[^.\[<]}s
                  ) ;
              $base_directories = "$base_directories$sep$path_directories";
              $base_directories =~ s{\.?[\]>][\[<]\.?}{.};
          }
  
          $path_file = '' if ($path_file eq '.') && $unix_mode;
  
          $path = $self->catpath( $base_volume, $base_directories, $path_file );
     }
  
      return $self->canonpath( $path ) ;
  }
  
  
  # eliminate_macros() and fixpath() are MakeMaker-specific methods
  # which are used inside catfile() and catdir().  MakeMaker has its own
  # copies as of 6.06_03 which are the canonical ones.  We leave these
  # here, in peace, so that File::Spec continues to work with MakeMakers
  # prior to 6.06_03.
  # 
  # Please consider these two methods deprecated.  Do not patch them,
  # patch the ones in ExtUtils::MM_VMS instead.
  #
  # Update:  MakeMaker 6.48 is still using these routines on VMS.
  # so they need to be kept up to date with ExtUtils::MM_VMS.
  #
  # The traditional VMS mode using ODS-2 disks depends on these routines
  # being here.  These routines should not be called in when the
  # C<DECC$EFS_CHARSET> or C<DECC$FILENAME_UNIX_REPORT> modes are enabled.
  
  sub eliminate_macros {
      my($self,$path) = @_;
      return '' unless (defined $path) && ($path ne '');
      $self = {} unless ref $self;
  
      if ($path =~ /\s/) {
        return join ' ', map { $self->eliminate_macros($_) } split /\s+/, $path;
      }
  
      my $npath = unixify($path);
      # sometimes unixify will return a string with an off-by-one trailing null
      $npath =~ s{\0$}{};
  
      my($complex) = 0;
      my($head,$macro,$tail);
  
      # perform m##g in scalar context so it acts as an iterator
      while ($npath =~ m#(.*?)\$\((\S+?)\)(.*)#gs) { 
          if (defined $self->{$2}) {
              ($head,$macro,$tail) = ($1,$2,$3);
              if (ref $self->{$macro}) {
                  if (ref $self->{$macro} eq 'ARRAY') {
                      $macro = join ' ', @{$self->{$macro}};
                  }
                  else {
                      print "Note: can't expand macro \$($macro) containing ",ref($self->{$macro}),
                            "\n\t(using MMK-specific deferred substitutuon; MMS will break)\n";
                      $macro = "\cB$macro\cB";
                      $complex = 1;
                  }
              }
              else { ($macro = unixify($self->{$macro})) =~ s#/\Z(?!\n)##; }
              $npath = "$head$macro$tail";
          }
      }
      if ($complex) { $npath =~ s#\cB(.*?)\cB#\${$1}#gs; }
      $npath;
  }
  
  # Deprecated.  See the note above for eliminate_macros().
  
  # Catchall routine to clean up problem MM[SK]/Make macros.  Expands macros
  # in any directory specification, in order to avoid juxtaposing two
  # VMS-syntax directories when MM[SK] is run.  Also expands expressions which
  # are all macro, so that we can tell how long the expansion is, and avoid
  # overrunning DCL's command buffer when MM[KS] is running.
  
  # fixpath() checks to see whether the result matches the name of a
  # directory in the current default directory and returns a directory or
  # file specification accordingly.  C<$is_dir> can be set to true to
  # force fixpath() to consider the path to be a directory or false to force
  # it to be a file.
  
  sub fixpath {
      my($self,$path,$force_path) = @_;
      return '' unless $path;
      $self = bless {}, $self unless ref $self;
      my($fixedpath,$prefix,$name);
  
      if ($path =~ /\s/) {
        return join ' ',
               map { $self->fixpath($_,$force_path) }
  	     split /\s+/, $path;
      }
  
      if ($path =~ m#^\$\([^\)]+\)\Z(?!\n)#s || $path =~ m#[/:>\]]#) { 
          if ($force_path or $path =~ /(?:DIR\)|\])\Z(?!\n)/) {
              $fixedpath = vmspath($self->eliminate_macros($path));
          }
          else {
              $fixedpath = vmsify($self->eliminate_macros($path));
          }
      }
      elsif ((($prefix,$name) = ($path =~ m#^\$\(([^\)]+)\)(.+)#s)) && $self->{$prefix}) {
          my($vmspre) = $self->eliminate_macros("\$($prefix)");
          # is it a dir or just a name?
          $vmspre = ($vmspre =~ m|/| or $prefix =~ /DIR\Z(?!\n)/) ? vmspath($vmspre) : '';
          $fixedpath = ($vmspre ? $vmspre : $self->{$prefix}) . $name;
          $fixedpath = vmspath($fixedpath) if $force_path;
      }
      else {
          $fixedpath = $path;
          $fixedpath = vmspath($fixedpath) if $force_path;
      }
      # No hints, so we try to guess
      if (!defined($force_path) and $fixedpath !~ /[:>(.\]]/) {
          $fixedpath = vmspath($fixedpath) if -d $fixedpath;
      }
  
      # Trim off root dirname if it's had other dirs inserted in front of it.
      $fixedpath =~ s/\.000000([\]>])/$1/;
      # Special case for VMS absolute directory specs: these will have had device
      # prepended during trip through Unix syntax in eliminate_macros(), since
      # Unix syntax has no way to express "absolute from the top of this device's
      # directory tree".
      if ($path =~ /^[\[>][^.\-]/) { $fixedpath =~ s/^[^\[<]+//; }
      $fixedpath;
  }
  
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  An explanation of VMS file specs can be found at
  L<http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files>.
  
  =cut
  
  1;
DARWIN-2LEVEL_FILE_SPEC_VMS

$fatpacked{"darwin-2level/File/Spec/Win32.pm"} = <<'DARWIN-2LEVEL_FILE_SPEC_WIN32';
  package File::Spec::Win32;
  
  use strict;
  
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.33';
  $VERSION = eval $VERSION;
  
  @ISA = qw(File::Spec::Unix);
  
  # Some regexes we use for path splitting
  my $DRIVE_RX = '[a-zA-Z]:';
  my $UNC_RX = '(?:\\\\\\\\|//)[^\\\\/]+[\\\\/][^\\\\/]+';
  my $VOL_RX = "(?:$DRIVE_RX|$UNC_RX)";
  
  
  =head1 NAME
  
  File::Spec::Win32 - methods for Win32 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Win32; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =over 4
  
  =item devnull
  
  Returns a string representation of the null device.
  
  =cut
  
  sub devnull {
      return "nul";
  }
  
  sub rootdir { '\\' }
  
  
  =item tmpdir
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      SYS:/temp
      C:\system\temp
      C:/temp
      /tmp
      /
  
  The SYS:/temp is preferred in Novell NetWare and the C:\system\temp
  for Symbian (the File::Spec::Win32 is used also for those platforms).
  
  Since Perl 5.8.0, if running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( map( $ENV{$_}, qw(TMPDIR TEMP TMP) ),
  			      'SYS:/temp',
  			      'C:\system\temp',
  			      'C:/temp',
  			      '/tmp',
  			      '/'  );
  }
  
  =item case_tolerant
  
  MSWin32 case-tolerance depends on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Since XP FS_CASE_SENSITIVE is effectively disabled for the NT subsubsystem.
  See http://cygwin.com/ml/cygwin/2007-07/msg00891.html
  Default: 1
  
  =cut
  
  sub case_tolerant {
    eval { require Win32API::File; } or return 1;
    my $drive = shift || "C:";
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =item file_name_is_absolute
  
  As of right now, this returns 2 if the path is absolute with a
  volume, 1 if it's absolute with no volume, 0 otherwise.
  
  =cut
  
  sub file_name_is_absolute {
  
      my ($self,$file) = @_;
  
      if ($file =~ m{^($VOL_RX)}o) {
        my $vol = $1;
        return ($vol =~ m{^$UNC_RX}o ? 2
  	      : $file =~ m{^$DRIVE_RX[\\/]}o ? 2
  	      : 0);
      }
      return $file =~  m{^[\\/]} ? 1 : 0;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub catfile {
      shift;
  
      # Legacy / compatibility support
      #
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catfile('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub catdir {
      shift;
  
      # Legacy / compatibility support
      #
      return ""
      	unless @_;
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catdir('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub path {
      my @path = split(';', $ENV{PATH});
      s/"//g for @path;
      @path = grep length, @path;
      unshift(@path, ".");
      return @path;
  }
  
  =item canonpath
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminated successive slashes and successive "/.".
  On Win32 makes 
  
  	dir1\dir2\dir3\..\..\dir4 -> \dir\dir4 and even
  	dir1\dir2\dir3\...\dir4   -> \dir\dir4
  
  =cut
  
  sub canonpath {
      # Legacy / compatibility support
      #
      return $_[1] if !defined($_[1]) or $_[1] eq '';
      return _canon_cat( $_[1] );
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path, $no_file );
  
  Splits a path into volume, directory, and filename portions. Assumes that 
  the last file is a path unless the path ends in '\\', '\\.', '\\..'
  or $no_file is true.  On Win32 this means that $no_file true makes this return 
  ( $volume, $path, '' ).
  
  Separators accepted are \ and /.
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  The results can be passed to L</catpath> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^ ( $VOL_RX ? ) (.*) }sox;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( $VOL_RX ? )
                  ( (?:.*[\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }sox;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L<catdir()|File::Spec/catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, leading empty and 
  trailing directory entries can be returned, because these are significant
  on some OSs. So,
  
      File::Spec->splitdir( "/a/b/c" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      #
      # split() likes to forget about trailing null fields, so here we
      # check to be sure that there will not be any before handling the
      # simple case.
      #
      if ( $directories !~ m|[\\/]\Z(?!\n)| ) {
          return split( m|[\\/]|, $directories );
      }
      else {
          #
          # since there was a trailing separator, add a file name to the end, 
          # then do the split, then replace it with ''.
          #
          my( @directories )= split( m|[\\/]|, "${directories}dummy" ) ;
          $directories[ $#directories ]= '' ;
          return @directories ;
      }
  }
  
  
  =item catpath
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and this is just like catfile(). On other OSs,
  the $volume become significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      my $v;
      $volume .= $v
          if ( (($v) = $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s) &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '\\' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  sub _same {
    lc($_[1]) eq lc($_[2]);
  }
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      my $is_abs = $self->file_name_is_absolute($path);
  
      # Check for volume (should probably document the '2' thing...)
      return $self->canonpath( $path ) if $is_abs == 2;
  
      if ($is_abs) {
        # It's missing a volume, add one
        my $vol = ($self->splitpath( $self->_cwd() ))[0];
        return $self->canonpath( $vol . $path );
      }
  
      if ( !defined( $base ) || $base eq '' ) {
        require Cwd ;
        $base = Cwd::getdcwd( ($self->splitpath( $path ))[0] ) if defined &Cwd::getdcwd ;
        $base = $self->_cwd() unless defined $base ;
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
        $base = $self->rel2abs( $base ) ;
      }
      else {
        $base = $self->canonpath( $base ) ;
      }
  
      my ( $path_directories, $path_file ) =
        ($self->splitpath( $path, 1 ))[1,2] ;
  
      my ( $base_volume, $base_directories ) =
        $self->splitpath( $base, 1 ) ;
  
      $path = $self->catpath( 
  			   $base_volume, 
  			   $self->catdir( $base_directories, $path_directories ), 
  			   $path_file
  			  ) ;
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head2 Note For File::Spec::Win32 Maintainers
  
  Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  
  sub _canon_cat				# @path -> path
  {
      my ($first, @rest) = @_;
  
      my $volume = $first =~ s{ \A ([A-Za-z]:) ([\\/]?) }{}x	# drive letter
      	       ? ucfirst( $1 ).( $2 ? "\\" : "" )
  	       : $first =~ s{ \A (?:\\\\|//) ([^\\/]+)
  				 (?: [\\/] ([^\\/]+) )?
  	       			 [\\/]? }{}xs			# UNC volume
  	       ? "\\\\$1".( defined $2 ? "\\$2" : "" )."\\"
  	       : $first =~ s{ \A [\\/] }{}x			# root dir
  	       ? "\\"
  	       : "";
      my $path   = join "\\", $first, @rest;
  
      $path =~ tr#\\/#\\\\#s;		# xx/yy --> xx\yy & xx\\yy --> xx\yy
  
      					# xx/././yy --> xx/yy
      $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		\.
  		(?:\\\.)*		# and more
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}gx;
  
      # XXX I do not know whether more dots are supported by the OS supporting
      #     this ... annotation (NetWare or symbian but not MSWin32).
      #     Then .... could easily become ../../.. etc:
      # Replace \.\.\. by (\.\.\.+)  and substitute with
      # { $1 . ".." . "\\.." x (length($2)-2) }gex
  	     				# ... --> ../..
      $path =~ s{ (\A|\\)			# at begin or after a slash
      		\.\.\.
  		(?=\\|\z) 		# at end or followed by slash
  	     }{$1..\\..}gx;
      					# xx\yy\..\zz --> xx\zz
      while ( $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		[^\\]+			# rip this 'yy' off
  		\\\.\.
  		(?<!\A\.\.\\\.\.)	# do *not* replace ^..\..
  		(?<!\\\.\.\\\.\.)	# do *not* replace \..\..
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}sx ) {}
  
      $path =~ s#\A\\##;			# \xx --> xx  NOTE: this is *not* root
      $path =~ s#\\\z##;			# xx\ --> xx
  
      if ( $volume =~ m#\\\z# )
      {					# <vol>\.. --> <vol>\
  	$path =~ s{ \A			# at begin
  		    \.\.
  		    (?:\\\.\.)*		# and more
  		    (?:\\|\z) 		# at end or followed by slash
  		 }{}x;
  
  	return $1			# \\HOST\SHARE\ --> \\HOST\SHARE
  	    if    $path eq ""
  	      and $volume =~ m#\A(\\\\.*)\\\z#s;
      }
      return $path ne "" || $volume ? $volume.$path : ".";
  }
  
  1;
DARWIN-2LEVEL_FILE_SPEC_WIN32

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE
use strict;
use warnings;

use FindBin qw($Bin);
use lib "$Bin/../lib", "$Bin/../fatlib";
use App::shelly;

use Pod::Usage;

unless (caller) {
    my $app = App::shelly->new;
    $app->parse_options(@ARGV);
    if ( $app->{help} ) {
        pod2usage( verbose => 1, -exitval => 'noexit' );
    }
    $app->doit or exit(1);
}
__END__

=head1 NAME

App::shelly

=head1 SYNOPSIS

$ shly [options] [atom...]

=head1 OPTIONS

=over 4

=item B<-h, --help>

Show this help.

=item B<-I, --impl [implementation]>

Tell what Lisp implementation to use. The default is $LISP_IMPL.

=item B<-L, --load [library1,library2,...]>

Load libraries before executing the expression.

=item B<--verbose>

Print some informations.

=item B<--no-init>

Do not load the user init file.

=item B<--debug>

This flag is for Shelly developers.

=back

=cut
